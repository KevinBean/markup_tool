<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cable Drawing Markup Editor</title>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    
    <!-- pdf-lib for PDF export -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <!-- React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'editor-bg': 'var(--bg-primary)',
                        'panel-bg': 'var(--bg-secondary)',
                        'panel-border': 'var(--border-color)',
                        'panel-hover': 'var(--bg-hover)',
                        'text-primary': 'var(--text-primary)',
                        'text-secondary': 'var(--text-secondary)',
                        'text-muted': 'var(--text-muted)',
                        'accent': '#0ea5e9',
                        'accent-hover': '#38bdf8',
                        'success': '#22c55e',
                        'warning': '#f59e0b',
                        'danger': '#ef4444',
                    }
                }
            }
        }
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap');

        /* Theme CSS Variables */
        :root, .dark-theme {
            --bg-primary: #1a1a1a;
            --bg-secondary: #252525;
            --bg-tertiary: #2f2f2f;
            --bg-hover: #3f3f3f;
            --border-color: #3a3a3a;
            --text-primary: #e5e5e5;
            --text-secondary: #a3a3a3;
            --text-muted: #737373;
            --canvas-grid: #2a2a2a;
            --canvas-bg: #1e1e1e;
            --scrollbar-track: #1a1a1a;
            --scrollbar-thumb: #404040;
            --scrollbar-thumb-hover: #505050;
        }

        .light-theme {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e5e5e5;
            --bg-hover: #d4d4d4;
            --border-color: #d4d4d4;
            --text-primary: #171717;
            --text-secondary: #525252;
            --text-muted: #737373;
            --canvas-grid: #d0d0d0;
            --canvas-bg: #e8e8e8;
            --scrollbar-track: #f0f0f0;
            --scrollbar-thumb: #c0c0c0;
            --scrollbar-thumb-hover: #a0a0a0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }
        
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }

        /* Resize handle */
        .resize-handle {
            transition: background-color 0.15s ease;
        }
        .resize-handle:hover {
            background-color: var(--accent-color);
        }
        .resize-handle:active {
            background-color: var(--accent-color);
        }

        /* Canvas container */
        .canvas-container {
            position: relative;
            overflow: hidden;
            background:
                linear-gradient(90deg, var(--canvas-grid) 1px, transparent 1px),
                linear-gradient(var(--canvas-grid) 1px, transparent 1px),
                var(--canvas-bg);
            background-size: 20px 20px;
        }
        
        /* Selection box */
        .selection-box {
            border: 2px dashed #0ea5e9;
            background: rgba(14, 165, 233, 0.1);
            pointer-events: none;
        }
        
        /* Element handles */
        .handle {
            width: 10px;
            height: 10px;
            background: white;
            border: 2px solid #0ea5e9;
            position: absolute;
            cursor: pointer;
        }
        
        .handle-nw { cursor: nw-resize; }
        .handle-ne { cursor: ne-resize; }
        .handle-sw { cursor: sw-resize; }
        .handle-se { cursor: se-resize; }
        .handle-n { cursor: n-resize; }
        .handle-s { cursor: s-resize; }
        .handle-e { cursor: e-resize; }
        .handle-w { cursor: w-resize; }
        
        /* Tool button active state */
        .tool-btn.active {
            background: #0ea5e9 !important;
            color: white !important;
        }
        
        /* Tooltip */
        .tooltip {
            position: relative;
        }
        
        .tooltip::after {
            content: attr(data-tip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 8px;
            padding: 4px 8px;
            background: var(--bg-hover);
            color: var(--text-primary);
            font-size: 12px;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        
        .tooltip:hover::after {
            opacity: 1;
        }
        
        /* Drop zone */
        .drop-zone {
            transition: all 0.3s ease;
        }
        
        .drop-zone.drag-over {
            background: rgba(14, 165, 233, 0.2) !important;
            border-color: #0ea5e9 !important;
        }
        
        /* Loading spinner */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .spinner {
            animation: spin 1s linear infinite;
        }
        
        /* Snippet/Mask styling */
        .snippet-overlay {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .element-selected {
            outline: 2px solid #0ea5e9;
            outline-offset: 2px;
        }
        
        /* Input styling */
        input[type="number"], input[type="text"] {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #0ea5e9;
        }

        input[type="color"] {
            width: 32px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        select {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        /* Page navigation */
        .page-nav-btn {
            transition: all 0.2s;
        }

        .page-nav-btn:hover:not(:disabled) {
            background: var(--bg-hover);
        }

        .page-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Data View Table */
        .data-table {
            border-collapse: collapse;
            width: 100%;
        }

        .data-table th,
        .data-table td {
            text-align: left;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table th {
            background: var(--bg-secondary);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .data-table tr:hover {
            background: rgba(128, 128, 128, 0.1);
        }

        .data-table input {
            background: transparent;
            border: none;
            color: inherit;
            width: 100%;
            padding: 2px 4px;
            margin: -2px -4px;
        }

        .data-table input:focus {
            outline: 1px solid #0ea5e9;
            background: rgba(14, 165, 233, 0.1);
            border-radius: 2px;
        }

        /* Light theme overrides for Tailwind utility classes */
        .light-theme .text-white {
            color: var(--text-primary) !important;
        }

        .light-theme .text-gray-300,
        .light-theme .text-gray-400 {
            color: var(--text-secondary) !important;
        }

        .light-theme .text-gray-500,
        .light-theme .text-gray-600 {
            color: var(--text-muted) !important;
        }

        .light-theme .bg-gray-700,
        .light-theme .hover\:bg-gray-700:hover {
            background-color: var(--bg-hover) !important;
        }

        .light-theme .bg-gray-800 {
            background-color: var(--bg-tertiary) !important;
        }

        .light-theme .bg-\[\#1a1a1a\],
        .light-theme .bg-\[\#252525\] {
            background-color: var(--bg-secondary) !important;
        }

        .light-theme .border-gray-600,
        .light-theme .border-gray-700 {
            border-color: var(--border-color) !important;
        }

        .light-theme .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.15), 0 4px 6px -2px rgba(0, 0, 0, 0.1) !important;
        }

        /* Light theme - make the header text more readable */
        .light-theme header .text-white {
            color: #171717 !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        
        // ============================================
        // CONFIGURATION & CONSTANTS
        // ============================================
        
        const OPERATIONS = {
            SELECT: 'select',
            SNIPPET: 'snippet',
            MASK: 'mask',
            LINE: 'line',
            RECTANGLE: 'rectangle',
            CIRCLE: 'circle',
            ARROW: 'arrow',
            TEXT: 'text',
            INFO_POINT: 'info_point',
            PAN: 'pan',
            CALIBRATE: 'calibrate',
            MEASURE: 'measure',
            DIMENSION: 'dimension',
            SYMBOL: 'symbol',
            COMMENT: 'comment',
            POLYLINE: 'polyline',
            FREEHAND: 'freehand',
            CALLOUT: 'callout',
            POLYGON: 'polygon',
            ARC: 'arc',
            AREA: 'area',
            BEZIER: 'bezier',
            CLOUD: 'cloud',
            LEADER: 'leader'
        };
        
        const LAYERS = {
            PDF_BASE: 100,
            MASKS: 200,
            SNIPPETS: 300,
            ELEMENTS: 400,
            ANNOTATIONS: 500
        };
        
        const DEFAULT_STYLES = {
            stroke: '#000000',
            strokeWidth: 2,
            fill: 'none',
            fontSize: 14,
            fontFamily: 'Arial'
        };
        
        const ZOOM_LIMITS = { min: 0.1, max: 5.0 };
        const GRID_SIZE = 20;
        const RENDER_DPI = 150;

        // Info Point Categories with colors
        const INFO_CATEGORIES = {
            general: { label: 'General', color: '#0ea5e9' },      // Cyan/Blue
            note: { label: 'Note', color: '#8b5cf6' },            // Purple
            warning: { label: 'Warning', color: '#f59e0b' },      // Amber
            important: { label: 'Important', color: '#ef4444' },  // Red
            dimension: { label: 'Dimension', color: '#22c55e' },  // Green
            specification: { label: 'Specification', color: '#ec4899' }, // Pink
            reference: { label: 'Reference', color: '#64748b' }   // Slate
        };

        // Info Point Priority levels with colors
        const INFO_PRIORITIES = {
            low: { label: 'Low', color: '#64748b' },       // Slate
            medium: { label: 'Medium', color: '#f59e0b' }, // Amber
            high: { label: 'High', color: '#ef4444' }      // Red
        };

        // Info Point Marker Styles - what's displayed inside the circle
        const INFO_MARKER_STYLES = {
            number: { label: 'Number', description: '1, 2, 3...' },
            letter: { label: 'Letter', description: 'A, B, C...' },
            icon: { label: 'Icon', description: 'ⓘ info symbol' },
            none: { label: 'None', description: 'Empty circle' }
        };

        // Comment Status options
        const COMMENT_STATUSES = {
            pending: { label: 'Pending', color: '#f59e0b', icon: '⏳' },
            approved: { label: 'Approved', color: '#22c55e', icon: '✓' },
            revision: { label: 'Needs Revision', color: '#ef4444', icon: '⚠' },
            resolved: { label: 'Resolved', color: '#64748b', icon: '✗' }
        };

        // ============================================
        // HV CABLE SYMBOL LIBRARY
        // ============================================

        const HV_SYMBOL_CATEGORIES = {
            joints: { label: 'Joints', color: '#ef4444' },
            terminations: { label: 'Terminations', color: '#f59e0b' },
            accessories: { label: 'Accessories', color: '#22c55e' },
            cable: { label: 'Cable Elements', color: '#0ea5e9' },
            schematic: { label: 'Schematic', color: '#8b5cf6' }
        };

        const HV_SYMBOLS = {
            // Joints
            'joint-straight': {
                id: 'joint-straight',
                name: 'Straight Joint',
                category: 'joints',
                width: 60,
                height: 30,
                render: (ctx, x, y, w, h, rotation) => {
                    ctx.save();
                    ctx.translate(x + w/2, y + h/2);
                    ctx.rotate(rotation * Math.PI / 180);
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(-w/2, -h/4, w, h/2);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-w/2, -h/4, w, h/2);
                    ctx.beginPath();
                    ctx.moveTo(-w/4, -h/4);
                    ctx.lineTo(-w/4, h/4);
                    ctx.moveTo(w/4, -h/4);
                    ctx.lineTo(w/4, h/4);
                    ctx.stroke();
                    ctx.restore();
                },
                svg: `<rect x="0" y="7.5" width="60" height="15" fill="#ef4444" stroke="#000" stroke-width="2"/><line x1="15" y1="7.5" x2="15" y2="22.5" stroke="#000" stroke-width="2"/><line x1="45" y1="7.5" x2="45" y2="22.5" stroke="#000" stroke-width="2"/>`
            },
            'joint-transition': {
                id: 'joint-transition',
                name: 'Transition Joint',
                category: 'joints',
                width: 70,
                height: 30,
                svg: `<polygon points="0,10 20,5 50,5 70,10 70,20 50,25 20,25 0,20" fill="#ef4444" stroke="#000" stroke-width="2"/><line x1="20" y1="5" x2="20" y2="25" stroke="#000" stroke-width="1.5"/><line x1="50" y1="5" x2="50" y2="25" stroke="#000" stroke-width="1.5"/>`
            },
            'joint-stop': {
                id: 'joint-stop',
                name: 'Stop Joint',
                category: 'joints',
                width: 50,
                height: 40,
                svg: `<rect x="5" y="5" width="40" height="30" fill="#ef4444" stroke="#000" stroke-width="2"/><line x1="5" y1="20" x2="0" y2="20" stroke="#000" stroke-width="3"/><circle cx="25" cy="20" r="8" fill="none" stroke="#000" stroke-width="2"/>`
            },
            'joint-flexible': {
                id: 'joint-flexible',
                name: 'Flexible Joint',
                category: 'joints',
                width: 80,
                height: 30,
                svg: `<path d="M0,15 Q20,5 40,15 Q60,25 80,15" fill="none" stroke="#ef4444" stroke-width="8"/><path d="M0,15 Q20,5 40,15 Q60,25 80,15" fill="none" stroke="#000" stroke-width="2"/>`
            },

            // Terminations
            'term-outdoor': {
                id: 'term-outdoor',
                name: 'Outdoor Termination',
                category: 'terminations',
                width: 30,
                height: 60,
                svg: `<rect x="5" y="30" width="20" height="30" fill="#f59e0b" stroke="#000" stroke-width="2"/><path d="M15,30 L5,10 L15,0 L25,10 Z" fill="#f59e0b" stroke="#000" stroke-width="2"/><line x1="15" y1="60" x2="15" y2="70" stroke="#000" stroke-width="3"/>`
            },
            'term-gis': {
                id: 'term-gis',
                name: 'GIS Termination',
                category: 'terminations',
                width: 40,
                height: 50,
                svg: `<rect x="5" y="10" width="30" height="40" rx="5" fill="#f59e0b" stroke="#000" stroke-width="2"/><circle cx="20" cy="30" r="10" fill="none" stroke="#000" stroke-width="2"/><line x1="20" y1="0" x2="20" y2="10" stroke="#000" stroke-width="3"/>`
            },
            'term-transformer': {
                id: 'term-transformer',
                name: 'Transformer Termination',
                category: 'terminations',
                width: 50,
                height: 50,
                svg: `<circle cx="25" cy="20" r="15" fill="none" stroke="#000" stroke-width="2"/><circle cx="25" cy="35" r="15" fill="none" stroke="#000" stroke-width="2"/><rect x="10" y="0" width="30" height="10" fill="#f59e0b" stroke="#000" stroke-width="2"/>`
            },
            'term-indoor': {
                id: 'term-indoor',
                name: 'Indoor Termination',
                category: 'terminations',
                width: 30,
                height: 50,
                svg: `<rect x="5" y="20" width="20" height="30" fill="#f59e0b" stroke="#000" stroke-width="2"/><ellipse cx="15" cy="10" rx="10" ry="10" fill="#f59e0b" stroke="#000" stroke-width="2"/><line x1="15" y1="50" x2="15" y2="60" stroke="#000" stroke-width="3"/>`
            },

            // Accessories
            'link-box': {
                id: 'link-box',
                name: 'Link Box',
                category: 'accessories',
                width: 50,
                height: 40,
                svg: `<rect x="5" y="5" width="40" height="30" fill="#22c55e" stroke="#000" stroke-width="2"/><text x="25" y="25" text-anchor="middle" font-size="12" font-weight="bold">LB</text>`
            },
            'svl': {
                id: 'svl',
                name: 'Sheath Voltage Limiter',
                category: 'accessories',
                width: 40,
                height: 40,
                svg: `<rect x="5" y="5" width="30" height="30" fill="#22c55e" stroke="#000" stroke-width="2"/><path d="M12,20 L20,10 L20,30 L28,20" fill="none" stroke="#000" stroke-width="2"/>`
            },
            'cross-bond-box': {
                id: 'cross-bond-box',
                name: 'Cross-bonding Box',
                category: 'accessories',
                width: 60,
                height: 40,
                svg: `<rect x="5" y="5" width="50" height="30" fill="#22c55e" stroke="#000" stroke-width="2"/><line x1="15" y1="10" x2="45" y2="30" stroke="#000" stroke-width="2"/><line x1="15" y1="30" x2="45" y2="10" stroke="#000" stroke-width="2"/><text x="30" y="38" text-anchor="middle" font-size="8">CB</text>`
            },
            'earth-point': {
                id: 'earth-point',
                name: 'Earth Point',
                category: 'accessories',
                width: 30,
                height: 40,
                svg: `<line x1="15" y1="0" x2="15" y2="15" stroke="#000" stroke-width="2"/><line x1="5" y1="15" x2="25" y2="15" stroke="#000" stroke-width="3"/><line x1="8" y1="22" x2="22" y2="22" stroke="#000" stroke-width="2.5"/><line x1="11" y1="29" x2="19" y2="29" stroke="#000" stroke-width="2"/>`
            },
            'ct': {
                id: 'ct',
                name: 'Current Transformer',
                category: 'accessories',
                width: 40,
                height: 40,
                svg: `<circle cx="20" cy="20" r="15" fill="none" stroke="#000" stroke-width="2"/><circle cx="20" cy="20" r="10" fill="none" stroke="#000" stroke-width="2"/><text x="20" y="24" text-anchor="middle" font-size="10" font-weight="bold">CT</text>`
            },
            'surge-arrester': {
                id: 'surge-arrester',
                name: 'Surge Arrester',
                category: 'accessories',
                width: 30,
                height: 50,
                svg: `<rect x="8" y="5" width="14" height="35" fill="#22c55e" stroke="#000" stroke-width="2"/><line x1="15" y1="0" x2="15" y2="5" stroke="#000" stroke-width="3"/><line x1="5" y1="45" x2="25" y2="45" stroke="#000" stroke-width="3"/><line x1="8" y1="50" x2="22" y2="50" stroke="#000" stroke-width="2"/>`
            },

            // Cable Elements
            'cable-single': {
                id: 'cable-single',
                name: 'Single-core Cable',
                category: 'cable',
                width: 20,
                height: 60,
                svg: `<line x1="10" y1="0" x2="10" y2="60" stroke="#0ea5e9" stroke-width="8"/><line x1="10" y1="0" x2="10" y2="60" stroke="#000" stroke-width="1"/>`
            },
            'cable-three': {
                id: 'cable-three',
                name: 'Three-core Cable',
                category: 'cable',
                width: 40,
                height: 60,
                svg: `<line x1="10" y1="0" x2="10" y2="60" stroke="#ef4444" stroke-width="6"/><line x1="20" y1="0" x2="20" y2="60" stroke="#f59e0b" stroke-width="6"/><line x1="30" y1="0" x2="30" y2="60" stroke="#0ea5e9" stroke-width="6"/><ellipse cx="20" cy="30" rx="18" ry="8" fill="none" stroke="#000" stroke-width="1.5" stroke-dasharray="4,2"/>`
            },
            'duct': {
                id: 'duct',
                name: 'Cable Duct',
                category: 'cable',
                width: 60,
                height: 30,
                svg: `<rect x="0" y="5" width="60" height="20" fill="none" stroke="#666" stroke-width="2"/><circle cx="15" cy="15" r="6" fill="#0ea5e9" stroke="#000" stroke-width="1"/><circle cx="30" cy="15" r="6" fill="#0ea5e9" stroke="#000" stroke-width="1"/><circle cx="45" cy="15" r="6" fill="#0ea5e9" stroke="#000" stroke-width="1"/>`
            },
            'trough': {
                id: 'trough',
                name: 'Cable Trough',
                category: 'cable',
                width: 70,
                height: 30,
                svg: `<path d="M0,5 L10,25 L60,25 L70,5" fill="none" stroke="#666" stroke-width="2"/><line x1="0" y1="5" x2="70" y2="5" stroke="#666" stroke-width="2"/><circle cx="25" cy="15" r="5" fill="#0ea5e9"/><circle cx="45" cy="15" r="5" fill="#0ea5e9"/>`
            },
            'manhole': {
                id: 'manhole',
                name: 'Manhole/Chamber',
                category: 'cable',
                width: 50,
                height: 50,
                svg: `<rect x="5" y="5" width="40" height="40" fill="#444" stroke="#000" stroke-width="2"/><rect x="15" y="0" width="20" height="10" fill="#666" stroke="#000" stroke-width="1"/><text x="25" y="32" text-anchor="middle" font-size="10" fill="#fff">MH</text>`
            },
            'cable-marker': {
                id: 'cable-marker',
                name: 'Cable Route Marker',
                category: 'cable',
                width: 20,
                height: 40,
                svg: `<rect x="5" y="20" width="10" height="20" fill="#f59e0b" stroke="#000" stroke-width="1"/><polygon points="10,0 0,20 20,20" fill="#f59e0b" stroke="#000" stroke-width="1"/>`
            },

            // Schematic Symbols
            'ground': {
                id: 'ground',
                name: 'Ground Symbol',
                category: 'schematic',
                width: 30,
                height: 30,
                svg: `<line x1="15" y1="0" x2="15" y2="10" stroke="#000" stroke-width="2"/><line x1="5" y1="10" x2="25" y2="10" stroke="#000" stroke-width="3"/><line x1="8" y1="16" x2="22" y2="16" stroke="#000" stroke-width="2.5"/><line x1="11" y1="22" x2="19" y2="22" stroke="#000" stroke-width="2"/><line x1="14" y1="28" x2="16" y2="28" stroke="#000" stroke-width="1.5"/>`
            },
            'phase-r': {
                id: 'phase-r',
                name: 'Phase R (Red)',
                category: 'schematic',
                width: 30,
                height: 30,
                svg: `<circle cx="15" cy="15" r="12" fill="#ef4444" stroke="#000" stroke-width="2"/><text x="15" y="20" text-anchor="middle" font-size="14" font-weight="bold" fill="#fff">R</text>`
            },
            'phase-y': {
                id: 'phase-y',
                name: 'Phase Y (Yellow)',
                category: 'schematic',
                width: 30,
                height: 30,
                svg: `<circle cx="15" cy="15" r="12" fill="#f59e0b" stroke="#000" stroke-width="2"/><text x="15" y="20" text-anchor="middle" font-size="14" font-weight="bold" fill="#000">Y</text>`
            },
            'phase-b': {
                id: 'phase-b',
                name: 'Phase B (Blue)',
                category: 'schematic',
                width: 30,
                height: 30,
                svg: `<circle cx="15" cy="15" r="12" fill="#0ea5e9" stroke="#000" stroke-width="2"/><text x="15" y="20" text-anchor="middle" font-size="14" font-weight="bold" fill="#fff">B</text>`
            },
            'neutral': {
                id: 'neutral',
                name: 'Neutral',
                category: 'schematic',
                width: 30,
                height: 30,
                svg: `<circle cx="15" cy="15" r="12" fill="#64748b" stroke="#000" stroke-width="2"/><text x="15" y="20" text-anchor="middle" font-size="14" font-weight="bold" fill="#fff">N</text>`
            },
            'test-point': {
                id: 'test-point',
                name: 'Test Point',
                category: 'schematic',
                width: 30,
                height: 30,
                svg: `<circle cx="15" cy="15" r="10" fill="none" stroke="#8b5cf6" stroke-width="2"/><circle cx="15" cy="15" r="4" fill="#8b5cf6"/><text x="15" y="28" text-anchor="middle" font-size="8">TP</text>`
            },
            'disconnect': {
                id: 'disconnect',
                name: 'Disconnect Point',
                category: 'schematic',
                width: 40,
                height: 20,
                svg: `<line x1="0" y1="10" x2="15" y2="10" stroke="#000" stroke-width="2"/><line x1="25" y1="10" x2="40" y2="10" stroke="#000" stroke-width="2"/><circle cx="15" cy="10" r="4" fill="none" stroke="#000" stroke-width="2"/><circle cx="25" cy="10" r="4" fill="none" stroke="#000" stroke-width="2"/>`
            },
            'splice': {
                id: 'splice',
                name: 'Cable Splice',
                category: 'schematic',
                width: 40,
                height: 20,
                svg: `<line x1="0" y1="10" x2="40" y2="10" stroke="#000" stroke-width="3"/><ellipse cx="20" cy="10" rx="10" ry="6" fill="#ef4444" stroke="#000" stroke-width="1.5"/>`
            }
        };

        // ============================================
        // CABLE SPECIFICATION SYSTEM
        // ============================================

        const CABLE_SPEC_FIELDS = {
            electrical: {
                label: 'Electrical',
                fields: {
                    voltageClass: { label: 'Voltage Class', type: 'select', options: ['11kV', '33kV', '66kV', '110kV', '132kV', '220kV', '275kV', '330kV', '400kV', '500kV'] },
                    conductorSize: { label: 'Conductor Size (mm²)', type: 'select', options: ['95', '120', '150', '185', '240', '300', '400', '500', '630', '800', '1000', '1200', '1400', '1600', '2000', '2500'] },
                    conductorMaterial: { label: 'Conductor Material', type: 'select', options: ['Cu', 'Al'] }
                }
            },
            insulation: {
                label: 'Insulation',
                fields: {
                    insulationType: { label: 'Insulation Type', type: 'select', options: ['XLPE', 'EPR', 'PILC', 'PPL'] },
                    sheathType: { label: 'Sheath Type', type: 'select', options: ['Lead', 'Aluminium', 'Copper Wire Screen', 'Corrugated Al', 'None'] }
                }
            },
            physical: {
                label: 'Physical',
                fields: {
                    cores: { label: 'Number of Cores', type: 'select', options: ['1', '3'] },
                    outerDiameter: { label: 'Outer Diameter (mm)', type: 'number' },
                    weight: { label: 'Weight (kg/m)', type: 'number' },
                    bendingRadius: { label: 'Min Bending Radius (mm)', type: 'number' }
                }
            },
            installation: {
                label: 'Installation',
                fields: {
                    installationType: { label: 'Installation Type', type: 'select', options: ['Direct Buried', 'Duct', 'Trough', 'Tunnel', 'Bridge', 'Submarine'] },
                    depth: { label: 'Depth (m)', type: 'number' }
                }
            }
        };

        const CABLE_TEMPLATES = {
            '132kV-1000Cu': {
                name: '132kV 1000mm² Cu XLPE',
                voltageClass: '132kV',
                conductorSize: '1000',
                conductorMaterial: 'Cu',
                insulationType: 'XLPE',
                sheathType: 'Copper Wire Screen',
                cores: '1',
                outerDiameter: 95,
                weight: 12.5,
                bendingRadius: 1900
            },
            '220kV-1600Cu': {
                name: '220kV 1600mm² Cu XLPE',
                voltageClass: '220kV',
                conductorSize: '1600',
                conductorMaterial: 'Cu',
                insulationType: 'XLPE',
                sheathType: 'Copper Wire Screen',
                cores: '1',
                outerDiameter: 115,
                weight: 18.2,
                bendingRadius: 2300
            },
            '400kV-2500Cu': {
                name: '400kV 2500mm² Cu XLPE',
                voltageClass: '400kV',
                conductorSize: '2500',
                conductorMaterial: 'Cu',
                insulationType: 'XLPE',
                sheathType: 'Copper Wire Screen',
                cores: '1',
                outerDiameter: 140,
                weight: 28.5,
                bendingRadius: 2800
            },
            '33kV-300Al': {
                name: '33kV 300mm² Al XLPE 3-core',
                voltageClass: '33kV',
                conductorSize: '300',
                conductorMaterial: 'Al',
                insulationType: 'XLPE',
                sheathType: 'Aluminium',
                cores: '3',
                outerDiameter: 75,
                weight: 8.5,
                bendingRadius: 750
            },
            '11kV-185Al': {
                name: '11kV 185mm² Al XLPE 3-core',
                voltageClass: '11kV',
                conductorSize: '185',
                conductorMaterial: 'Al',
                insulationType: 'XLPE',
                sheathType: 'Aluminium',
                cores: '3',
                outerDiameter: 55,
                weight: 4.2,
                bendingRadius: 550
            }
        };

        // ============================================
        // FILL PATTERNS FOR CABLE INSTALLATIONS
        // ============================================

        const FILL_PATTERNS = {
            solid: { id: 'solid', name: 'Solid', description: 'Solid fill color' },
            hatch: { id: 'hatch', name: 'Hatch', description: 'Diagonal lines (sand/granular)' },
            crosshatch: { id: 'crosshatch', name: 'Crosshatch', description: 'Grid pattern (concrete/CBS)' },
            dots: { id: 'dots', name: 'Dots', description: 'Dotted pattern (gravel/aggregate)' },
            horizontal: { id: 'horizontal', name: 'Horizontal', description: 'Horizontal lines (clay/soil layers)' },
            vertical: { id: 'vertical', name: 'Vertical', description: 'Vertical lines (backfill)' },
            brick: { id: 'brick', name: 'Brick', description: 'Brick pattern (masonry/tiles)' },
            wave: { id: 'wave', name: 'Wave', description: 'Wavy lines (water/fluid)' },
            cable: { id: 'cable', name: 'Cable Core', description: 'Cable cross-section' },
            duct: { id: 'duct', name: 'Duct', description: 'Empty duct/conduit' }
        };

        const INSTALLATION_PRESETS = {
            'native-soil': { name: 'Native Soil', fill: '#8B7355', pattern: 'dots', opacity: 0.7 },
            'sand-bedding': { name: 'Sand Bedding', fill: '#F4D03F', pattern: 'hatch', opacity: 0.6 },
            'cbs': { name: 'Cement Bound Sand', fill: '#95A5A6', pattern: 'crosshatch', opacity: 0.7 },
            'concrete': { name: 'Concrete', fill: '#BDC3C7', pattern: 'crosshatch', opacity: 0.8 },
            'gravel': { name: 'Gravel/Aggregate', fill: '#7F8C8D', pattern: 'dots', opacity: 0.8 },
            'clay': { name: 'Clay', fill: '#CD6839', pattern: 'horizontal', opacity: 0.6 },
            'water': { name: 'Water/Wet Area', fill: '#3498DB', pattern: 'wave', opacity: 0.5 },
            'duct-empty': { name: 'Empty Duct', fill: '#2C3E50', pattern: 'duct', opacity: 0.3 },
            'duct-occupied': { name: 'Occupied Duct', fill: '#E74C3C', pattern: 'cable', opacity: 0.8 },
            'warning-tape': { name: 'Warning Tape', fill: '#F1C40F', pattern: 'horizontal', opacity: 0.9 },
            'protective-tile': { name: 'Protective Tile', fill: '#E67E22', pattern: 'brick', opacity: 0.8 }
        };

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        const generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const distance = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

        // Snap coordinate to grid
        const snapToGrid = (value, gridSize) => Math.round(value / gridSize) * gridSize;

        // Calculate polygon area using Shoelace formula
        const calculatePolygonArea = (points) => {
            if (!points || points.length < 3) return 0;
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return Math.abs(area / 2);
        };

        // Calculate alignment guides for an element being dragged
        const GUIDE_THRESHOLD = 8; // Pixels within which to snap
        const calculateAlignmentGuides = (draggedBounds, allElements, excludeId) => {
            const guides = [];
            const snapAdjustments = { x: 0, y: 0 };

            // Get edges and center of dragged element
            const draggedEdges = {
                left: draggedBounds.x,
                right: draggedBounds.x + (draggedBounds.width || 0),
                top: draggedBounds.y,
                bottom: draggedBounds.y + (draggedBounds.height || 0),
                centerX: draggedBounds.x + (draggedBounds.width || 0) / 2,
                centerY: draggedBounds.y + (draggedBounds.height || 0) / 2
            };

            let closestX = { dist: GUIDE_THRESHOLD, value: null, type: null };
            let closestY = { dist: GUIDE_THRESHOLD, value: null, type: null };

            allElements.forEach(el => {
                if (el.id === excludeId || el.visible === false) return;

                // Get element bounds
                let elBounds;
                if (el.x1 !== undefined) {
                    // Line/Arrow type
                    elBounds = {
                        left: Math.min(el.x1, el.x2),
                        right: Math.max(el.x1, el.x2),
                        top: Math.min(el.y1, el.y2),
                        bottom: Math.max(el.y1, el.y2)
                    };
                } else if (el.x !== undefined) {
                    elBounds = {
                        left: el.x,
                        right: el.x + (el.width || 0),
                        top: el.y,
                        bottom: el.y + (el.height || 0)
                    };
                } else return;

                elBounds.centerX = (elBounds.left + elBounds.right) / 2;
                elBounds.centerY = (elBounds.top + elBounds.bottom) / 2;

                // Check horizontal alignments (vertical guide lines)
                const xChecks = [
                    { dragEdge: 'left', elEdge: 'left' },
                    { dragEdge: 'left', elEdge: 'right' },
                    { dragEdge: 'right', elEdge: 'left' },
                    { dragEdge: 'right', elEdge: 'right' },
                    { dragEdge: 'centerX', elEdge: 'centerX' }
                ];

                xChecks.forEach(({ dragEdge, elEdge }) => {
                    const dist = Math.abs(draggedEdges[dragEdge] - elBounds[elEdge]);
                    if (dist < closestX.dist) {
                        closestX = { dist, value: elBounds[elEdge], type: `${dragEdge}-${elEdge}` };
                    }
                });

                // Check vertical alignments (horizontal guide lines)
                const yChecks = [
                    { dragEdge: 'top', elEdge: 'top' },
                    { dragEdge: 'top', elEdge: 'bottom' },
                    { dragEdge: 'bottom', elEdge: 'top' },
                    { dragEdge: 'bottom', elEdge: 'bottom' },
                    { dragEdge: 'centerY', elEdge: 'centerY' }
                ];

                yChecks.forEach(({ dragEdge, elEdge }) => {
                    const dist = Math.abs(draggedEdges[dragEdge] - elBounds[elEdge]);
                    if (dist < closestY.dist) {
                        closestY = { dist, value: elBounds[elEdge], type: `${dragEdge}-${elEdge}` };
                    }
                });
            });

            // Calculate snap adjustments
            if (closestX.value !== null) {
                const dragEdge = closestX.type.split('-')[0];
                if (dragEdge === 'left') snapAdjustments.x = closestX.value - draggedEdges.left;
                else if (dragEdge === 'right') snapAdjustments.x = closestX.value - draggedEdges.right;
                else if (dragEdge === 'centerX') snapAdjustments.x = closestX.value - draggedEdges.centerX;
                guides.push({ type: 'vertical', x: closestX.value });
            }

            if (closestY.value !== null) {
                const dragEdge = closestY.type.split('-')[0];
                if (dragEdge === 'top') snapAdjustments.y = closestY.value - draggedEdges.top;
                else if (dragEdge === 'bottom') snapAdjustments.y = closestY.value - draggedEdges.bottom;
                else if (dragEdge === 'centerY') snapAdjustments.y = closestY.value - draggedEdges.centerY;
                guides.push({ type: 'horizontal', y: closestY.value });
            }

            return { guides, snapAdjustments };
        };

        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func(...args), delay);
            };
        };
        
        const pointInRect = (point, rect) => {
            return point.x >= rect.x &&
                   point.x <= rect.x + rect.width &&
                   point.y >= rect.y &&
                   point.y <= rect.y + rect.height;
        };

        // Calculate distance from a point to a line segment
        const pointToLineDistance = (point, x1, y1, x2, y2) => {
            const A = point.x - x1;
            const B = point.y - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = point.x - xx;
            const dy = point.y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        };

        // Check if a point is inside a circle
        const pointInCircle = (point, cx, cy, radius) => {
            return distance(point, { x: cx, y: cy }) <= radius;
        };

        // Capture a region from an image source as base64 data URL
        const captureRegion = async (imageSource, x, y, width, height) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    // Draw the cropped region
                    ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = () => resolve(null);
                img.src = imageSource;
            });
        };

        // ============================================
        // ICONS
        // ============================================
        
        const Icons = {
            Cursor: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                    <path d="M13 13l6 6"/>
                </svg>
            ),
            Scissors: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="6" cy="6" r="3"/>
                    <circle cx="6" cy="18" r="3"/>
                    <line x1="20" y1="4" x2="8.12" y2="15.88"/>
                    <line x1="14.47" y1="14.48" x2="20" y2="20"/>
                    <line x1="8.12" y1="8.12" x2="12" y2="12"/>
                </svg>
            ),
            Square: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
            ),
            Mask: () => (
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
            ),
            Line: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="5" y1="19" x2="19" y2="5"/>
                </svg>
            ),
            Circle: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="12" cy="12" r="9"/>
                </svg>
            ),
            Arrow: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="5" y1="12" x2="19" y2="12"/>
                    <polyline points="12 5 19 12 12 19"/>
                </svg>
            ),
            Type: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="4 7 4 4 20 4 20 7"/>
                    <line x1="9" y1="20" x2="15" y2="20"/>
                    <line x1="12" y1="4" x2="12" y2="20"/>
                </svg>
            ),
            Ruler: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                    <line x1="12" y1="11" x2="12" y2="17"/>
                    <line x1="9" y1="17" x2="15" y2="17"/>
                </svg>
            ),
            Move: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="5 9 2 12 5 15"/>
                    <polyline points="9 5 12 2 15 5"/>
                    <polyline points="15 19 12 22 9 19"/>
                    <polyline points="19 9 22 12 19 15"/>
                    <line x1="2" y1="12" x2="22" y2="12"/>
                    <line x1="12" y1="2" x2="12" y2="22"/>
                </svg>
            ),
            ZoomIn: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="11" cy="11" r="8"/>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                    <line x1="11" y1="8" x2="11" y2="14"/>
                    <line x1="8" y1="11" x2="14" y2="11"/>
                </svg>
            ),
            ZoomOut: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="11" cy="11" r="8"/>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                    <line x1="8" y1="11" x2="14" y2="11"/>
                </svg>
            ),
            Fit: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
            ),
            Undo: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M3 7v6h6"/>
                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                </svg>
            ),
            Redo: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M21 7v6h-6"/>
                    <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/>
                </svg>
            ),
            Download: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            ),
            Upload: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
            ),
            File: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                </svg>
            ),
            Save: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                    <polyline points="17 21 17 13 7 13 7 21"/>
                    <polyline points="7 3 7 8 15 8"/>
                </svg>
            ),
            Folder: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                </svg>
            ),
            Trash: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="3 6 5 6 21 6"/>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                </svg>
            ),
            Copy: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                </svg>
            ),
            Grid: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="3" width="7" height="7"/>
                    <rect x="14" y="3" width="7" height="7"/>
                    <rect x="14" y="14" width="7" height="7"/>
                    <rect x="3" y="14" width="7" height="7"/>
                </svg>
            ),
            Magnet: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M6 15V9a6 6 0 0 1 12 0v6"/>
                    <path d="M6 9H2v6h4"/>
                    <path d="M18 9h4v6h-4"/>
                    <rect x="2" y="9" width="4" height="2" fill="currentColor"/>
                    <rect x="18" y="9" width="4" height="2" fill="currentColor"/>
                </svg>
            ),
            AlignGuide: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="12" y1="2" x2="12" y2="22"/>
                    <line x1="2" y1="12" x2="22" y2="12"/>
                    <rect x="8" y="8" width="8" height="8" fill="none"/>
                </svg>
            ),
            Callout: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                </svg>
            ),
            Ruler: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/>
                    <line x1="15" y1="5" x2="19" y2="9"/>
                    <line x1="12" y1="8" x2="13" y2="9"/>
                    <line x1="9" y1="11" x2="10" y2="12"/>
                    <line x1="6" y1="14" x2="7" y2="15"/>
                </svg>
            ),
            Polygon: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"/>
                </svg>
            ),
            Arc: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M4 20 Q12 4 20 20"/>
                    <circle cx="4" cy="20" r="2" fill="currentColor"/>
                    <circle cx="20" cy="20" r="2" fill="currentColor"/>
                </svg>
            ),
            Area: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polygon points="4 18 12 4 20 18 4 18" fill="currentColor" fillOpacity="0.2"/>
                    <text x="12" y="16" fontSize="8" textAnchor="middle" fill="currentColor">A</text>
                </svg>
            ),
            Bezier: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M4 18 Q12 4 20 18" strokeLinecap="round"/>
                    <circle cx="4" cy="18" r="2" fill="currentColor"/>
                    <circle cx="20" cy="18" r="2" fill="currentColor"/>
                    <circle cx="12" cy="4" r="2" fill="none" strokeDasharray="2 1"/>
                </svg>
            ),
            Cloud: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M4 12 Q4 8 8 8 Q8 4 12 4 Q16 4 16 8 Q20 8 20 12 Q20 16 16 16 Q16 20 12 20 Q8 20 8 16 Q4 16 4 12" fill="currentColor" fillOpacity="0.1"/>
                </svg>
            ),
            Leader: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M4 18 L12 10 L20 10" strokeLinecap="round" strokeLinejoin="round"/>
                    <circle cx="4" cy="18" r="2" fill="currentColor"/>
                    <line x1="14" y1="6" x2="22" y2="6" strokeWidth="1.5"/>
                </svg>
            ),
            Layers: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polygon points="12 2 2 7 12 12 22 7 12 2"/>
                    <polyline points="2 17 12 22 22 17"/>
                    <polyline points="2 12 12 17 22 12"/>
                </svg>
            ),
            Settings: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
            ),
            ChevronLeft: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="15 18 9 12 15 6"/>
                </svg>
            ),
            ChevronRight: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="9 18 15 12 9 6"/>
                </svg>
            ),
            X: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            ),
            Check: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="20 6 9 17 4 12"/>
                </svg>
            ),
            Eye: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
            ),
            EyeOff: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/>
                    <line x1="1" y1="1" x2="23" y2="23"/>
                </svg>
            ),
            Lock: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                </svg>
            ),
            Unlock: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                    <path d="M7 11V7a5 5 0 0 1 9.9-1"/>
                </svg>
            ),
            RotateCw: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="23 4 23 10 17 10"/>
                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                </svg>
            ),
            InfoPoint: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="12" y1="16" x2="12" y2="12"/>
                    <line x1="12" y1="8" x2="12.01" y2="8"/>
                </svg>
            ),
            Library: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                </svg>
            ),
            Table: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <line x1="3" y1="9" x2="21" y2="9"/>
                    <line x1="3" y1="15" x2="21" y2="15"/>
                    <line x1="9" y1="3" x2="9" y2="21"/>
                    <line x1="15" y1="3" x2="15" y2="21"/>
                </svg>
            ),
            Plus: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="12" y1="5" x2="12" y2="19"/>
                    <line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
            ),
            Minus: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
            ),
            List: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="8" y1="6" x2="21" y2="6"/>
                    <line x1="8" y1="12" x2="21" y2="12"/>
                    <line x1="8" y1="18" x2="21" y2="18"/>
                    <circle cx="4" cy="6" r="1" fill="currentColor"/>
                    <circle cx="4" cy="12" r="1" fill="currentColor"/>
                    <circle cx="4" cy="18" r="1" fill="currentColor"/>
                </svg>
            ),
            Calibrate: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="3" y1="12" x2="21" y2="12"/>
                    <line x1="3" y1="8" x2="3" y2="16"/>
                    <line x1="21" y1="8" x2="21" y2="16"/>
                    <line x1="8" y1="10" x2="8" y2="14"/>
                    <line x1="12" y1="9" x2="12" y2="15"/>
                    <line x1="16" y1="10" x2="16" y2="14"/>
                    <text x="12" y="21" textAnchor="middle" fontSize="6" fill="currentColor" stroke="none">m</text>
                </svg>
            ),
            Measure: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="4" y1="20" x2="20" y2="4"/>
                    <line x1="4" y1="20" x2="7" y2="17"/>
                    <line x1="20" y1="4" x2="17" y2="7"/>
                    <line x1="4" y1="17" x2="4" y2="20"/>
                    <line x1="4" y1="20" x2="7" y2="20"/>
                    <line x1="17" y1="4" x2="20" y2="4"/>
                    <line x1="20" y1="4" x2="20" y2="7"/>
                    <text x="12" y="15" textAnchor="middle" fontSize="6" fill="currentColor" stroke="none">25m</text>
                </svg>
            ),
            Component: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="4" y="8" width="16" height="8" rx="1"/>
                    <line x1="8" y1="8" x2="8" y2="16"/>
                    <line x1="16" y1="8" x2="16" y2="16"/>
                    <line x1="0" y1="12" x2="4" y2="12"/>
                    <line x1="20" y1="12" x2="24" y2="12"/>
                </svg>
            ),
            ChevronDown: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="6 9 12 15 18 9"/>
                </svg>
            ),
            Settings: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
            ),
            Library: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                    <line x1="12" y1="6" x2="12" y2="12"/>
                    <line x1="9" y1="9" x2="15" y2="9"/>
                </svg>
            ),
            Sun: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="12" cy="12" r="5"/>
                    <line x1="12" y1="1" x2="12" y2="3"/>
                    <line x1="12" y1="21" x2="12" y2="23"/>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                    <line x1="1" y1="12" x2="3" y2="12"/>
                    <line x1="21" y1="12" x2="23" y2="12"/>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                </svg>
            ),
            Moon: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                </svg>
            ),
            Pages: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="3" width="14" height="18" rx="2"/>
                    <rect x="7" y="6" width="14" height="18" rx="2"/>
                </svg>
            ),
            Template: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                    <line x1="3" y1="9" x2="21" y2="9"/>
                    <line x1="9" y1="21" x2="9" y2="9"/>
                </svg>
            ),
            Comment: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                </svg>
            ),
            Polyline: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="4 17 8 11 13 15 20 7"/>
                    <circle cx="4" cy="17" r="2" fill="currentColor"/>
                    <circle cx="8" cy="11" r="2" fill="currentColor"/>
                    <circle cx="13" cy="15" r="2" fill="currentColor"/>
                    <circle cx="20" cy="7" r="2" fill="currentColor"/>
                </svg>
            ),
            Pencil: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                </svg>
            ),
            Image: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21 15 16 10 5 21"/>
                </svg>
            ),
            Star: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                </svg>
            ),
            Clock: () => (
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                </svg>
            ),
        };
        
        // ============================================
        // HISTORY MANAGER (Undo/Redo)
        // ============================================
        
        const useHistory = (initialState, maxSize = 50) => {
            const [history, setHistory] = useState([initialState]);
            const [index, setIndex] = useState(0);
            
            const current = history[index];
            
            const push = useCallback((state) => {
                setHistory(prev => {
                    const newHistory = prev.slice(0, index + 1);
                    newHistory.push(state);
                    if (newHistory.length > maxSize) {
                        newHistory.shift();
                        return newHistory;
                    }
                    return newHistory;
                });
                setIndex(prev => Math.min(prev + 1, maxSize - 1));
            }, [index, maxSize]);
            
            const undo = useCallback(() => {
                setIndex(prev => Math.max(0, prev - 1));
            }, []);
            
            const redo = useCallback(() => {
                setIndex(prev => Math.min(history.length - 1, prev + 1));
            }, [history.length]);
            
            const canUndo = index > 0;
            const canRedo = index < history.length - 1;
            
            return { current, push, undo, redo, canUndo, canRedo };
        };
        
        // ============================================
        // PDF LOADER
        // ============================================
        
        const loadPDF = async (file, dpi = RENDER_DPI) => {
            return new Promise(async (resolve, reject) => {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    const pages = [];
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const viewport = page.getViewport({ scale: dpi / 72 });
                        
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        
                        await page.render({
                            canvasContext: context,
                            viewport: viewport
                        }).promise;
                        
                        pages.push({
                            pageNumber: i,
                            width: viewport.width,
                            height: viewport.height,
                            imageData: canvas.toDataURL('image/png'),
                            elements: [],
                            masks: [],
                            snippets: []
                        });
                    }
                    
                    resolve({
                        fileName: file.name,
                        pageCount: pdf.numPages,
                        pages: pages
                    });
                } catch (error) {
                    reject(error);
                }
            });
        };

        // ============================================
        // IMAGE LOADER
        // ============================================

        const loadImage = async (file) => {
            return new Promise((resolve, reject) => {
                try {
                    const reader = new FileReader();

                    reader.onload = (e) => {
                        const img = new Image();

                        img.onload = () => {
                            // Create canvas to normalize image format
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');

                            // Use original image dimensions
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // Draw image to canvas
                            context.drawImage(img, 0, 0);

                            // Convert to PNG data URL for consistency
                            const imageData = canvas.toDataURL('image/png');

                            resolve({
                                fileName: file.name,
                                pageCount: 1,
                                pages: [{
                                    pageNumber: 1,
                                    width: img.width,
                                    height: img.height,
                                    imageData: imageData,
                                    elements: [],
                                    masks: [],
                                    snippets: []
                                }]
                            });
                        };

                        img.onerror = () => {
                            reject(new Error('Failed to load image'));
                        };

                        img.src = e.target.result;
                    };

                    reader.onerror = () => {
                        reject(new Error('Failed to read file'));
                    };

                    reader.readAsDataURL(file);
                } catch (error) {
                    reject(error);
                }
            });
        };

        // ============================================
        // PDF EXPORTER
        // ============================================

        const exportToPDF = async (canvasRef, fileName = 'markup-export.pdf') => {
            const { PDFDocument } = PDFLib;
            
            const canvas = canvasRef.current;
            const imageData = canvas.toDataURL('image/png');
            
            const pdfDoc = await PDFDocument.create();
            const pngImage = await pdfDoc.embedPng(imageData);
            
            const page = pdfDoc.addPage([canvas.width * 72 / RENDER_DPI, canvas.height * 72 / RENDER_DPI]);
            page.drawImage(pngImage, {
                x: 0,
                y: 0,
                width: canvas.width * 72 / RENDER_DPI,
                height: canvas.height * 72 / RENDER_DPI
            });
            
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            link.click();
            
            URL.revokeObjectURL(url);
        };
        
        // ============================================
        // TOOL BUTTON COMPONENT
        // ============================================
        
        const ToolButton = ({ icon: Icon, label, active, onClick, shortcut, disabled }) => (
            <button
                className={`
                    tool-btn w-10 h-10 flex items-center justify-center rounded-lg
                    transition-all duration-200 tooltip
                    ${active ? 'bg-accent text-white' : 'bg-panel-bg text-gray-400 hover:bg-gray-700 hover:text-white'}
                    ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
                `}
                onClick={onClick}
                disabled={disabled}
                data-tip={`${label}${shortcut ? ` (${shortcut})` : ''}`}
            >
                <div className="w-5 h-5">
                    <Icon />
                </div>
            </button>
        );

        // ============================================
        // COLLAPSIBLE SECTION COMPONENT
        // ============================================

        const CollapsibleSection = ({ title, collapsed, onToggle, children }) => (
            <div className="border-b border-panel-border">
                <button
                    className="w-full p-2 flex items-center justify-between text-left hover:bg-gray-800/50 transition-colors"
                    onClick={onToggle}
                >
                    <span className="text-[10px] text-gray-500 uppercase tracking-wider">{title}</span>
                    <span className={`text-gray-500 text-xs transition-transform ${collapsed ? '' : 'rotate-180'}`}>▼</span>
                </button>
                {!collapsed && (
                    <div className="px-3 pb-3">
                        {children}
                    </div>
                )}
            </div>
        );

        // ============================================
        // PROPERTIES PANEL COMPONENT
        // ============================================

        const PropertiesPanel = ({ selection, onUpdate, styles, onStyleChange }) => {
            if (!selection) {
                return (
                    <div className="p-4 text-gray-500 text-sm">
                        No element selected
                    </div>
                );
            }

            const isInfoPoint = selection.type === 'info_point';
            const isLine = selection.type === 'line';
            const isArrow = selection.type === 'arrow';
            const isText = selection.type === 'text';
            const isLineOrArrow = isLine || isArrow;
            const isSymbol = selection.type === 'symbol';
            const isMeasurement = selection.type === 'measurement';

            return (
                <div className="p-4 space-y-4">
                    <div className="text-xs text-gray-400 uppercase tracking-wider mb-2">
                        {selection.type === 'info_point' ? 'Info Point' : selection.type} Properties
                    </div>

                    {/* Name and Lock */}
                    <div className="space-y-2">
                        <div className="flex items-center justify-between">
                            <div className="text-xs text-gray-500">Name</div>
                            <label className="flex items-center gap-1 cursor-pointer" title={selection.locked ? "Unlock element" : "Lock element"}>
                                <input
                                    type="checkbox"
                                    checked={selection.locked || false}
                                    onChange={(e) => onUpdate({ locked: e.target.checked })}
                                    className="hidden"
                                />
                                <span className={`p-1 rounded ${selection.locked ? 'text-yellow-500 bg-yellow-500/20' : 'text-gray-500 hover:text-gray-300'}`}>
                                    {selection.locked ? <Icons.Lock /> : <Icons.Unlock />}
                                </span>
                            </label>
                        </div>
                        <input
                            type="text"
                            value={selection.name || ''}
                            onChange={(e) => onUpdate({ name: e.target.value })}
                            className="w-full"
                            placeholder="Element name"
                        />
                    </div>

                    {/* Line/Arrow-specific position (start and end points) */}
                    {isLineOrArrow && (
                        <>
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Start Point</div>
                                <div className="grid grid-cols-2 gap-2">
                                    <div>
                                        <label className="text-xs text-gray-400">X1</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.x1 || 0)}
                                            onChange={(e) => onUpdate({ x1: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-xs text-gray-400">Y1</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.y1 || 0)}
                                            onChange={(e) => onUpdate({ y1: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                </div>
                            </div>
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">End Point</div>
                                <div className="grid grid-cols-2 gap-2">
                                    <div>
                                        <label className="text-xs text-gray-400">X2</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.x2 || 0)}
                                            onChange={(e) => onUpdate({ x2: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-xs text-gray-400">Y2</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.y2 || 0)}
                                            onChange={(e) => onUpdate({ y2: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                </div>
                            </div>
                        </>
                    )}

                    {/* Position - for non-line/arrow elements */}
                    {!isLineOrArrow && (
                        <div className="space-y-2">
                            <div className="text-xs text-gray-500">Position</div>
                            <div className="grid grid-cols-2 gap-2">
                                <div>
                                    <label className="text-xs text-gray-400">X</label>
                                    <input
                                        type="number"
                                        value={Math.round(selection.x || 0)}
                                        onChange={(e) => onUpdate({ x: parseFloat(e.target.value) })}
                                        className="w-full"
                                    />
                                </div>
                                <div>
                                    <label className="text-xs text-gray-400">Y</label>
                                    <input
                                        type="number"
                                        value={Math.round(selection.y || 0)}
                                        onChange={(e) => onUpdate({ y: parseFloat(e.target.value) })}
                                        className="w-full"
                                    />
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Arrow-specific options */}
                    {isArrow && (
                        <div className="space-y-2 pt-2 border-t border-panel-border">
                            <div className="text-xs text-gray-500">Arrow Style</div>
                            <label className="flex items-center gap-2 cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={selection.arrowStart || false}
                                    onChange={(e) => onUpdate({ arrowStart: e.target.checked })}
                                    className="w-4 h-4 rounded border-gray-600 bg-gray-700 text-accent focus:ring-accent"
                                />
                                <span className="text-xs text-gray-300">Arrow at start</span>
                            </label>
                            <label className="flex items-center gap-2 cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={selection.arrowEnd !== false}
                                    onChange={(e) => onUpdate({ arrowEnd: e.target.checked })}
                                    className="w-4 h-4 rounded border-gray-600 bg-gray-700 text-accent focus:ring-accent"
                                />
                                <span className="text-xs text-gray-300">Arrow at end</span>
                            </label>
                        </div>
                    )}

                    {/* Text-specific options */}
                    {isText && (
                        <div className="space-y-3 pt-2 border-t border-panel-border">
                            <div className="text-xs text-gray-500">Text Content</div>
                            <textarea
                                value={selection.content || ''}
                                onChange={(e) => onUpdate({ content: e.target.value })}
                                className="w-full h-20 text-sm"
                                placeholder="Enter text..."
                            />
                            <div className="text-xs text-gray-500">Font</div>
                            <div className="grid grid-cols-2 gap-2">
                                <div>
                                    <label className="text-xs text-gray-400">Size</label>
                                    <input
                                        type="number"
                                        value={selection.fontSize || 14}
                                        onChange={(e) => onUpdate({ fontSize: parseInt(e.target.value) })}
                                        className="w-full"
                                        min="8"
                                        max="72"
                                    />
                                </div>
                                <div>
                                    <label className="text-xs text-gray-400">Family</label>
                                    <select
                                        value={selection.fontFamily || 'Arial'}
                                        onChange={(e) => onUpdate({ fontFamily: e.target.value })}
                                        className="w-full"
                                    >
                                        <option value="Arial">Arial</option>
                                        <option value="Helvetica">Helvetica</option>
                                        <option value="Times New Roman">Times</option>
                                        <option value="Courier New">Courier</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                    </select>
                                </div>
                            </div>
                            <div className="text-xs text-gray-500">Colors</div>
                            <div className="flex items-center gap-4">
                                <div className="flex items-center gap-2">
                                    <label className="text-xs text-gray-400">Text</label>
                                    <input
                                        type="color"
                                        value={selection.color || '#000000'}
                                        onChange={(e) => onUpdate({ color: e.target.value })}
                                        className="w-8 h-6"
                                    />
                                </div>
                                <div className="flex items-center gap-2">
                                    <label className="text-xs text-gray-400">Bg</label>
                                    <input
                                        type="color"
                                        value={selection.backgroundColor === 'transparent' ? '#ffffff' : (selection.backgroundColor || '#ffffff')}
                                        onChange={(e) => onUpdate({ backgroundColor: e.target.value })}
                                        className="w-8 h-6"
                                    />
                                    <label className="flex items-center gap-1 cursor-pointer">
                                        <input
                                            type="checkbox"
                                            checked={selection.backgroundColor === 'transparent'}
                                            onChange={(e) => onUpdate({ backgroundColor: e.target.checked ? 'transparent' : '#ffffff' })}
                                            className="w-3 h-3"
                                        />
                                        <span className="text-xs text-gray-400">None</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Size - for non-info-point elements */}
                    {(selection.width !== undefined) && (
                        <div className="space-y-2">
                            <div className="text-xs text-gray-500">Size</div>
                            <div className="grid grid-cols-2 gap-2">
                                <div>
                                    <label className="text-xs text-gray-400">W</label>
                                    <input
                                        type="number"
                                        value={Math.round(selection.width || 0)}
                                        onChange={(e) => onUpdate({ width: parseFloat(e.target.value) })}
                                        className="w-full"
                                    />
                                </div>
                                <div>
                                    <label className="text-xs text-gray-400">H</label>
                                    <input
                                        type="number"
                                        value={Math.round(selection.height || 0)}
                                        onChange={(e) => onUpdate({ height: parseFloat(e.target.value) })}
                                        className="w-full"
                                    />
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Snippet-specific options */}
                    {selection.type === 'snippet' && (
                        <div className="space-y-2 pt-2 border-t border-panel-border">
                            <div className="text-xs text-gray-500">Display Options</div>
                            <label className="flex items-center gap-2 cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={selection.hideBorder || false}
                                    onChange={(e) => onUpdate({ hideBorder: e.target.checked })}
                                    className="w-4 h-4 rounded border-gray-600 bg-gray-700 text-accent focus:ring-accent"
                                />
                                <span className="text-xs text-gray-300">Hide border when not selected</span>
                            </label>
                        </div>
                    )}

                    {/* Info Point specific fields */}
                    {isInfoPoint && (
                        <>
                            {/* Visual Badge */}
                            <div className="flex items-center gap-2 p-2 bg-[#1a1a1a] rounded-lg">
                                <div
                                    className="w-8 h-8 rounded-full flex items-center justify-center text-white font-bold text-sm"
                                    style={{
                                        backgroundColor: (INFO_CATEGORIES[selection.category] || INFO_CATEGORIES.general).color,
                                        fontStyle: selection.markerStyle === 'icon' ? 'italic' : 'normal'
                                    }}
                                >
                                    {(() => {
                                        const style = selection.markerStyle || 'number';
                                        if (style === 'number') return selection.number || 1;
                                        if (style === 'letter') {
                                            let n = selection.number || 1;
                                            let letter = '';
                                            while (n > 0) { n--; letter = String.fromCharCode(65 + (n % 26)) + letter; n = Math.floor(n / 26); }
                                            return letter;
                                        }
                                        if (style === 'icon') return 'i';
                                        return '';
                                    })()}
                                </div>
                                <div className="flex-1">
                                    <div className="text-sm font-medium text-white">{selection.label || 'Untitled Point'}</div>
                                    <div className="text-xs text-gray-500 capitalize">{selection.category || 'general'}</div>
                                </div>
                                <div
                                    className="w-2 h-2 rounded-full"
                                    style={{ backgroundColor: (INFO_PRIORITIES[selection.priority] || INFO_PRIORITIES.medium).color }}
                                    title={`Priority: ${selection.priority || 'medium'}`}
                                />
                            </div>

                            {/* Label */}
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Label</div>
                                <input
                                    type="text"
                                    value={selection.label || ''}
                                    onChange={(e) => onUpdate({ label: e.target.value })}
                                    className="w-full"
                                    placeholder="Short label"
                                />
                            </div>

                            {/* Description */}
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Description</div>
                                <textarea
                                    value={selection.description || ''}
                                    onChange={(e) => onUpdate({ description: e.target.value })}
                                    className="w-full bg-[#1a1a1a] border border-[#3a3a3a] text-[#e5e5e5] p-2 rounded text-xs"
                                    rows={3}
                                    placeholder="Detailed information..."
                                />
                            </div>

                            {/* Category */}
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Category</div>
                                <div className="flex items-center gap-2">
                                    <select
                                        value={selection.category || 'general'}
                                        onChange={(e) => {
                                            const newCategory = e.target.value;
                                            const newColor = INFO_CATEGORIES[newCategory].color;
                                            onUpdate({ category: newCategory, color: newColor });
                                        }}
                                        className="flex-1"
                                    >
                                        {Object.entries(INFO_CATEGORIES).map(([key, { label }]) => (
                                            <option key={key} value={key}>{label}</option>
                                        ))}
                                    </select>
                                    <div
                                        className="w-6 h-6 rounded-full border border-gray-600"
                                        style={{ backgroundColor: (INFO_CATEGORIES[selection.category] || INFO_CATEGORIES.general).color }}
                                    />
                                </div>
                            </div>

                            {/* Priority */}
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Priority</div>
                                <div className="flex gap-1">
                                    {Object.entries(INFO_PRIORITIES).map(([key, { label, color }]) => (
                                        <button
                                            key={key}
                                            onClick={() => onUpdate({ priority: key })}
                                            className={`flex-1 py-1.5 px-2 text-xs rounded transition-all ${
                                                selection.priority === key
                                                    ? 'text-white ring-2 ring-white/30'
                                                    : 'text-gray-300 hover:opacity-80'
                                            }`}
                                            style={{
                                                backgroundColor: selection.priority === key ? color : `${color}40`,
                                                borderBottom: selection.priority === key ? `2px solid ${color}` : 'none'
                                            }}
                                        >
                                            {label}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* Marker Style - what's displayed inside the circle */}
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Marker Style</div>
                                <div className="flex gap-1">
                                    {Object.entries(INFO_MARKER_STYLES).map(([key, { label, description }]) => {
                                        const isActive = (selection.markerStyle || 'number') === key;
                                        // Display preview based on style
                                        let preview = '';
                                        if (key === 'number') preview = String(selection.number || 1);
                                        else if (key === 'letter') {
                                            let n = selection.number || 1;
                                            let letter = '';
                                            while (n > 0) { n--; letter = String.fromCharCode(65 + (n % 26)) + letter; n = Math.floor(n / 26); }
                                            preview = letter;
                                        }
                                        else if (key === 'icon') preview = 'i';
                                        else preview = '-';
                                        return (
                                            <button
                                                key={key}
                                                onClick={() => onUpdate({ markerStyle: key })}
                                                className={`flex-1 py-1.5 px-1 text-xs rounded transition-all flex flex-col items-center gap-0.5 ${
                                                    isActive
                                                        ? 'bg-accent text-white ring-2 ring-white/30'
                                                        : 'bg-[#2a2a2a] text-gray-300 hover:bg-[#3a3a3a]'
                                                }`}
                                                title={description}
                                            >
                                                <span className="font-bold text-sm" style={{ fontStyle: key === 'icon' ? 'italic' : 'normal' }}>{preview}</span>
                                                <span className="text-[10px] opacity-70">{label}</span>
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>

                            {/* Tags */}
                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Tags</div>
                                <input
                                    type="text"
                                    value={(selection.tags || []).join(', ')}
                                    onChange={(e) => {
                                        const tags = e.target.value.split(',').map(t => t.trim()).filter(t => t);
                                        onUpdate({ tags });
                                    }}
                                    className="w-full"
                                    placeholder="tag1, tag2, tag3..."
                                />
                                {/* Tag chips preview */}
                                {selection.tags && selection.tags.length > 0 && (
                                    <div className="flex flex-wrap gap-1">
                                        {selection.tags.map((tag, idx) => (
                                            <span
                                                key={idx}
                                                className="px-2 py-0.5 text-xs bg-accent/20 text-accent rounded-full"
                                            >
                                                {tag}
                                            </span>
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* Appearance Settings */}
                            <div className="space-y-2 pt-2 border-t border-panel-border">
                                <div className="text-xs text-gray-500">Appearance</div>

                                {/* Custom Color Override */}
                                <div className="flex items-center gap-2">
                                    <label className="text-xs text-gray-400 w-16">Color</label>
                                    <input
                                        type="color"
                                        value={selection.color || '#0ea5e9'}
                                        onChange={(e) => onUpdate({ color: e.target.value })}
                                    />
                                    <span className="text-xs text-gray-400 flex-1">{selection.color || '#0ea5e9'}</span>
                                    <button
                                        onClick={() => onUpdate({ color: INFO_CATEGORIES[selection.category || 'general'].color })}
                                        className="px-2 py-0.5 text-xs bg-gray-700 text-gray-300 rounded hover:bg-gray-600"
                                        title="Reset to category color"
                                    >
                                        Reset
                                    </button>
                                </div>

                                {/* Point Size */}
                                <div className="flex items-center gap-2">
                                    <label className="text-xs text-gray-400 w-16">Size</label>
                                    <input
                                        type="range"
                                        value={selection.radius || 12}
                                        onChange={(e) => onUpdate({ radius: parseFloat(e.target.value) })}
                                        className="flex-1"
                                        min="8"
                                        max="24"
                                    />
                                    <span className="text-xs text-gray-400 w-6">{selection.radius || 12}</span>
                                </div>
                            </div>

                            {/* Metadata Editor */}
                            <div className="pt-2 border-t border-panel-border">
                                <MetadataEditor
                                    metadata={selection.metadata || {}}
                                    onUpdate={onUpdate}
                                />
                            </div>
                        </>
                    )}

                    {/* Symbol-specific fields */}
                    {isSymbol && (
                        <>
                            <div className="space-y-2 pt-2 border-t border-panel-border">
                                <div className="text-xs text-gray-500">Symbol Info</div>
                                <div className="p-2 bg-[#1a1a1a] rounded">
                                    <div className="text-sm text-white">{HV_SYMBOLS[selection.symbolId]?.name || selection.symbolId}</div>
                                    <div className="text-xs text-gray-500">{HV_SYMBOLS[selection.symbolId]?.category || 'Unknown'}</div>
                                </div>
                            </div>

                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Transform</div>
                                <div className="flex items-center gap-2">
                                    <label className="text-xs text-gray-400 w-16">Rotation</label>
                                    <input
                                        type="number"
                                        value={selection.rotation || 0}
                                        onChange={(e) => onUpdate({ rotation: parseFloat(e.target.value) })}
                                        className="w-16"
                                        step="15"
                                    />
                                    <span className="text-xs text-gray-400">°</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <label className="text-xs text-gray-400 w-16">Scale</label>
                                    <input
                                        type="number"
                                        value={selection.scale || 1}
                                        onChange={(e) => onUpdate({ scale: parseFloat(e.target.value) })}
                                        className="w-16"
                                        step="0.1"
                                        min="0.5"
                                        max="3"
                                    />
                                </div>
                            </div>

                            {/* Symbol Specs (for joints, terminations, etc.) */}
                            <div className="space-y-2 pt-2 border-t border-panel-border">
                                <div className="text-xs text-gray-500">Specifications</div>
                                {['jointId', 'circuit', 'phase', 'chainage', 'manufacturer', 'status'].map(field => (
                                    <div key={field} className="flex items-center gap-2">
                                        <label className="text-xs text-gray-400 w-20 capitalize">{field.replace(/([A-Z])/g, ' $1').trim()}</label>
                                        <input
                                            type="text"
                                            value={selection.specs?.[field] || ''}
                                            onChange={(e) => onUpdate({ specs: { ...selection.specs, [field]: e.target.value } })}
                                            className="flex-1"
                                            placeholder={field}
                                        />
                                    </div>
                                ))}
                            </div>
                        </>
                    )}

                    {/* Measurement-specific fields */}
                    {isMeasurement && (
                        <>
                            <div className="space-y-2 pt-2 border-t border-panel-border">
                                <div className="text-xs text-gray-500">Distance</div>
                                <div className="p-3 bg-[#1a1a1a] rounded space-y-2">
                                    <div className="flex justify-between items-center">
                                        <span className="text-xs text-gray-400">Pixels</span>
                                        <span className="text-sm text-white font-mono">{selection.pixelDistance?.toFixed(1) || 0} px</span>
                                    </div>
                                    {selection.realDistance !== null && (
                                        <div className="flex justify-between items-center">
                                            <span className="text-xs text-gray-400">Real</span>
                                            <span className="text-sm text-green-400 font-mono font-bold">
                                                {selection.realDistance?.toFixed(2)} {selection.unit === 'meters' ? 'm' : 'ft'}
                                            </span>
                                        </div>
                                    )}
                                </div>
                            </div>

                            <div className="space-y-2">
                                <div className="text-xs text-gray-500">Endpoints</div>
                                <div className="grid grid-cols-2 gap-2">
                                    <div>
                                        <label className="text-xs text-gray-400">X1</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.x1 || 0)}
                                            onChange={(e) => onUpdate({ x1: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-xs text-gray-400">Y1</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.y1 || 0)}
                                            onChange={(e) => onUpdate({ y1: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                </div>
                                <div className="grid grid-cols-2 gap-2">
                                    <div>
                                        <label className="text-xs text-gray-400">X2</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.x2 || 0)}
                                            onChange={(e) => onUpdate({ x2: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-xs text-gray-400">Y2</label>
                                        <input
                                            type="number"
                                            value={Math.round(selection.y2 || 0)}
                                            onChange={(e) => onUpdate({ y2: parseFloat(e.target.value) })}
                                            className="w-full"
                                        />
                                    </div>
                                </div>
                            </div>
                        </>
                    )}

                    {/* Rotation - for rectangles, circles, snippets, masks */}
                    {(selection.type === 'rectangle' || selection.type === 'circle' || selection.type === 'snippet' || selection.type === 'mask') && (
                        <div className="space-y-2 pt-2 border-t border-panel-border">
                            <div className="text-xs text-gray-500">Rotation</div>
                            <div className="flex items-center gap-2">
                                <input
                                    type="number"
                                    value={selection.rotation || 0}
                                    onChange={(e) => onUpdate({ rotation: parseFloat(e.target.value) % 360 })}
                                    className="w-20"
                                    step="15"
                                />
                                <span className="text-xs text-gray-400">degrees</span>
                                <button
                                    className="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded"
                                    onClick={() => onUpdate({ rotation: ((selection.rotation || 0) + 90) % 360 })}
                                    title="Rotate 90° clockwise"
                                >
                                    +90°
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Style - for non-info-point, non-symbol, non-measurement elements */}
                    {!isInfoPoint && !isSymbol && !isMeasurement && !isText && (
                        <div className="space-y-2 pt-2 border-t border-panel-border">
                            <div className="text-xs text-gray-500">Style</div>
                            <div className="flex items-center gap-2">
                                <label className="text-xs text-gray-400 w-16">Stroke</label>
                                <input
                                    type="color"
                                    value={selection.stroke || styles.stroke || '#000000'}
                                    onChange={(e) => onUpdate({ stroke: e.target.value })}
                                />
                                <input
                                    type="number"
                                    value={selection.strokeWidth || styles.strokeWidth || 2}
                                    onChange={(e) => onUpdate({ strokeWidth: parseFloat(e.target.value) })}
                                    className="w-16"
                                    min="1"
                                    max="20"
                                />
                            </div>
                            <div className="flex items-center gap-2">
                                <label className="text-xs text-gray-400 w-16">Fill</label>
                                <input
                                    type="color"
                                    value={(selection.fill && selection.fill !== 'none') ? selection.fill : '#ffffff'}
                                    onChange={(e) => onUpdate({ fill: e.target.value })}
                                />
                                <button
                                    className={`px-2 py-1 text-xs rounded ${(!selection.fill || selection.fill === 'none') ? 'bg-accent text-white' : 'bg-gray-700 text-gray-300'}`}
                                    onClick={() => onUpdate({ fill: (!selection.fill || selection.fill === 'none') ? '#ffffff' : 'none' })}
                                >
                                    None
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Fill Pattern - for rectangles and circles */}
                    {(selection.type === 'rectangle' || selection.type === 'circle') && (
                        <div className="space-y-3 pt-2 border-t border-panel-border">
                            <div className="text-xs text-gray-500">Fill Pattern (Cable Installation)</div>

                            {/* Pattern Type */}
                            <div className="space-y-1">
                                <label className="text-xs text-gray-400">Pattern</label>
                                <select
                                    value={selection.fillPattern || 'solid'}
                                    onChange={(e) => onUpdate({ fillPattern: e.target.value })}
                                    className="w-full"
                                >
                                    {Object.entries(FILL_PATTERNS).map(([id, pattern]) => (
                                        <option key={id} value={id}>{pattern.name} - {pattern.description}</option>
                                    ))}
                                </select>
                            </div>

                            {/* Opacity */}
                            <div className="flex items-center gap-2">
                                <label className="text-xs text-gray-400 w-20">Opacity</label>
                                <input
                                    type="range"
                                    value={(selection.fillOpacity || 1) * 100}
                                    onChange={(e) => onUpdate({ fillOpacity: parseFloat(e.target.value) / 100 })}
                                    className="flex-1"
                                    min="10"
                                    max="100"
                                />
                                <span className="text-xs text-gray-400 w-8">{Math.round((selection.fillOpacity || 1) * 100)}%</span>
                            </div>

                            {/* Installation Presets */}
                            <div className="space-y-1">
                                <label className="text-xs text-gray-400">Quick Presets</label>
                                <div className="grid grid-cols-2 gap-1 max-h-32 overflow-y-auto">
                                    {Object.entries(INSTALLATION_PRESETS).map(([id, preset]) => (
                                        <button
                                            key={id}
                                            onClick={() => onUpdate({
                                                fill: preset.fill,
                                                fillPattern: preset.pattern,
                                                fillOpacity: preset.opacity
                                            })}
                                            className="flex items-center gap-1.5 px-2 py-1.5 text-[10px] bg-gray-800 hover:bg-gray-700 rounded text-left"
                                            title={preset.name}
                                        >
                                            <span
                                                className="w-4 h-4 rounded-sm border border-gray-600 flex-shrink-0"
                                                style={{ backgroundColor: preset.fill, opacity: preset.opacity }}
                                            />
                                            <span className="truncate text-gray-300">{preset.name}</span>
                                        </button>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        
        // ============================================
        // LAYER PANEL COMPONENT
        // ============================================
        
        const LayerPanel = ({ snippets, masks, elements, infoPoints, symbols = [], measurements = [], bezierCurves = [], cloudAnnotations = [], leaderLines = [], onSelectItem, selectedId, onDeleteItem, onToggleVisibility, onToggleLock }) => {
            const [searchQuery, setSearchQuery] = useState('');
            const [typeFilter, setTypeFilter] = useState('all'); // 'all', 'snippet', 'mask', 'element', 'symbol', 'measurement', 'infoPoint'

            // Filter function
            const filterItems = (items) => {
                if (!searchQuery) return items;
                return items.filter(item =>
                    (item.name || '').toLowerCase().includes(searchQuery.toLowerCase())
                );
            };

            const renderItem = (item, type) => (
                <div
                    key={item.id}
                    className={`
                        flex items-center gap-2 p-2 rounded cursor-pointer
                        ${selectedId === item.id ? 'bg-accent/20 border border-accent' : 'hover:bg-gray-700'}
                    `}
                    onClick={() => onSelectItem(item, type)}
                >
                    <button
                        className="w-5 h-5 text-gray-400 hover:text-white"
                        onClick={(e) => {
                            e.stopPropagation();
                            onToggleVisibility(item.id, type);
                        }}
                    >
                        {item.visible !== false ? <Icons.Eye /> : <Icons.EyeOff />}
                    </button>
                    {item.locked && (
                        <span className="text-yellow-500 text-xs">🔒</span>
                    )}
                    <span className="flex-1 text-sm truncate">
                        {item.name || `${type} ${item.id.slice(-4)}`}
                    </span>
                    <button
                        className="w-5 h-5 text-gray-400 hover:text-danger"
                        onClick={(e) => {
                            e.stopPropagation();
                            if (!item.locked) onDeleteItem(item.id, type);
                        }}
                        disabled={item.locked}
                        title={item.locked ? "Unlock to delete" : "Delete"}
                    >
                        <Icons.Trash />
                    </button>
                </div>
            );

            // Apply filters
            const filteredSnippets = typeFilter === 'all' || typeFilter === 'snippet' ? filterItems(snippets) : [];
            const filteredMasks = typeFilter === 'all' || typeFilter === 'mask' ? filterItems(masks) : [];
            const filteredElements = typeFilter === 'all' || typeFilter === 'element' ? filterItems(elements) : [];
            const filteredSymbols = typeFilter === 'all' || typeFilter === 'symbol' ? filterItems(symbols) : [];
            const filteredMeasurements = typeFilter === 'all' || typeFilter === 'measurement' ? filterItems(measurements) : [];
            const filteredInfoPoints = typeFilter === 'all' || typeFilter === 'infoPoint' ? filterItems(infoPoints) : [];
            const filteredBeziers = typeFilter === 'all' || typeFilter === 'bezier' ? filterItems(bezierCurves) : [];
            const filteredClouds = typeFilter === 'all' || typeFilter === 'cloud' ? filterItems(cloudAnnotations) : [];
            const filteredLeaders = typeFilter === 'all' || typeFilter === 'leader' ? filterItems(leaderLines) : [];

            const totalCount = filteredSnippets.length + filteredMasks.length + filteredElements.length +
                              filteredSymbols.length + filteredMeasurements.length + filteredInfoPoints.length +
                              filteredBeziers.length + filteredClouds.length + filteredLeaders.length;

            return (
                <div className="p-2 space-y-3">
                    {/* Search and Filter */}
                    <div className="space-y-2">
                        <input
                            type="text"
                            placeholder="Search layers..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            className="w-full px-3 py-1.5 text-sm bg-gray-800 border border-gray-700 rounded focus:border-accent focus:outline-none"
                        />
                        <select
                            value={typeFilter}
                            onChange={(e) => setTypeFilter(e.target.value)}
                            className="w-full px-2 py-1 text-sm bg-gray-800 border border-gray-700 rounded"
                        >
                            <option value="all">All Types ({snippets.length + masks.length + elements.length + symbols.length + measurements.length + infoPoints.length + bezierCurves.length + cloudAnnotations.length + leaderLines.length})</option>
                            <option value="snippet">Snippets ({snippets.length})</option>
                            <option value="mask">Masks ({masks.length})</option>
                            <option value="element">Elements ({elements.length})</option>
                            <option value="symbol">Symbols ({symbols.length})</option>
                            <option value="measurement">Measurements ({measurements.length})</option>
                            <option value="infoPoint">Info Points ({infoPoints.length})</option>
                            <option value="bezier">Bezier Curves ({bezierCurves.length})</option>
                            <option value="cloud">Cloud Annotations ({cloudAnnotations.length})</option>
                            <option value="leader">Leader Lines ({leaderLines.length})</option>
                        </select>
                        {searchQuery && (
                            <div className="text-xs text-gray-500">
                                Found {totalCount} item{totalCount !== 1 ? 's' : ''}
                            </div>
                        )}
                    </div>

                    {/* Snippets */}
                    {filteredSnippets.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Scissors /></div>
                                <span>Snippets ({filteredSnippets.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredSnippets.map(s => renderItem(s, 'snippet'))}
                            </div>
                        </div>
                    )}

                    {/* Masks */}
                    {filteredMasks.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Mask /></div>
                                <span>Masks ({filteredMasks.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredMasks.map(m => renderItem(m, 'mask'))}
                            </div>
                        </div>
                    )}

                    {/* Elements */}
                    {filteredElements.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Layers /></div>
                                <span>Elements ({filteredElements.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredElements.map(e => renderItem(e, 'element'))}
                            </div>
                        </div>
                    )}

                    {/* Symbols */}
                    {filteredSymbols.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Component /></div>
                                <span>Symbols ({filteredSymbols.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredSymbols.map(s => renderItem(s, 'symbol'))}
                            </div>
                        </div>
                    )}

                    {/* Measurements */}
                    {filteredMeasurements.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Measure /></div>
                                <span>Measurements ({filteredMeasurements.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredMeasurements.map(m => renderItem(m, 'measurement'))}
                            </div>
                        </div>
                    )}

                    {/* Info Points */}
                    {filteredInfoPoints.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.InfoPoint /></div>
                                <span>Info Points ({filteredInfoPoints.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredInfoPoints.map(p => renderItem(p, 'infoPoint'))}
                            </div>
                        </div>
                    )}

                    {/* Bezier Curves */}
                    {filteredBeziers.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Bezier /></div>
                                <span>Bezier Curves ({filteredBeziers.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredBeziers.map(b => renderItem(b, 'bezier'))}
                            </div>
                        </div>
                    )}

                    {/* Cloud Annotations */}
                    {filteredClouds.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Cloud /></div>
                                <span>Cloud Annotations ({filteredClouds.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredClouds.map(c => renderItem(c, 'cloud'))}
                            </div>
                        </div>
                    )}

                    {/* Leader Lines */}
                    {filteredLeaders.length > 0 && (
                        <div>
                            <div className="flex items-center gap-2 px-2 py-1 text-xs text-gray-400 uppercase tracking-wider">
                                <div className="w-4 h-4"><Icons.Leader /></div>
                                <span>Leader Lines ({filteredLeaders.length})</span>
                            </div>
                            <div className="space-y-1">
                                {filteredLeaders.map(l => renderItem(l, 'leader'))}
                            </div>
                        </div>
                    )}

                    {/* Empty state */}
                    {totalCount === 0 && (
                        <div className="text-center text-gray-500 py-4 text-sm">
                            {searchQuery ? 'No matching items found' : 'No layers yet'}
                        </div>
                    )}
                </div>
            );
        };

        // ============================================
        // METADATA EDITOR COMPONENT (Obsidian-style key-value pairs)
        // ============================================

        const MetadataEditor = ({ metadata = {}, onUpdate }) => {
            const [newKey, setNewKey] = useState('');
            const [newValue, setNewValue] = useState('');

            const handleAddField = () => {
                if (newKey.trim()) {
                    const updatedMetadata = {
                        ...metadata,
                        [newKey.trim()]: newValue
                    };
                    onUpdate({ metadata: updatedMetadata });
                    setNewKey('');
                    setNewValue('');
                }
            };

            const handleUpdateField = (key, value) => {
                const updatedMetadata = {
                    ...metadata,
                    [key]: value
                };
                onUpdate({ metadata: updatedMetadata });
            };

            const handleDeleteField = (keyToDelete) => {
                const updatedMetadata = { ...metadata };
                delete updatedMetadata[keyToDelete];
                onUpdate({ metadata: updatedMetadata });
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    handleAddField();
                }
            };

            const entries = Object.entries(metadata);

            return (
                <div className="space-y-2">
                    <div className="text-xs text-gray-500 flex items-center justify-between">
                        <span>Metadata</span>
                        <span className="text-gray-600">{entries.length} fields</span>
                    </div>

                    {/* Existing metadata fields */}
                    {entries.length > 0 && (
                        <div className="space-y-1 max-h-40 overflow-y-auto">
                            {entries.map(([key, value]) => (
                                <div key={key} className="flex items-center gap-1 group">
                                    <span className="text-xs text-accent w-20 truncate" title={key}>
                                        {key}:
                                    </span>
                                    <input
                                        type="text"
                                        value={value}
                                        onChange={(e) => handleUpdateField(key, e.target.value)}
                                        className="flex-1 text-xs py-0.5"
                                        placeholder="value"
                                    />
                                    <button
                                        onClick={() => handleDeleteField(key)}
                                        className="w-4 h-4 text-gray-500 hover:text-danger opacity-0 group-hover:opacity-100 transition-opacity"
                                    >
                                        <Icons.Minus />
                                    </button>
                                </div>
                            ))}
                        </div>
                    )}

                    {/* Add new field */}
                    <div className="flex items-center gap-1 pt-1 border-t border-panel-border">
                        <input
                            type="text"
                            value={newKey}
                            onChange={(e) => setNewKey(e.target.value)}
                            onKeyDown={handleKeyDown}
                            className="w-20 text-xs py-0.5"
                            placeholder="key"
                        />
                        <input
                            type="text"
                            value={newValue}
                            onChange={(e) => setNewValue(e.target.value)}
                            onKeyDown={handleKeyDown}
                            className="flex-1 text-xs py-0.5"
                            placeholder="value"
                        />
                        <button
                            onClick={handleAddField}
                            disabled={!newKey.trim()}
                            className="w-5 h-5 text-gray-400 hover:text-accent disabled:opacity-30 disabled:cursor-not-allowed"
                        >
                            <Icons.Plus />
                        </button>
                    </div>
                </div>
            );
        };

        // ============================================
        // DATA VIEW PANEL COMPONENT (Obsidian Dataview-style table)
        // ============================================

        const DataViewPanel = ({ infoPoints, onSelectItem, selectedId, onUpdateInfoPoint }) => {
            const [sortField, setSortField] = useState('name');
            const [sortDirection, setSortDirection] = useState('asc');
            const [filterText, setFilterText] = useState('');

            // Collect all unique metadata keys across all info points
            const allMetadataKeys = useMemo(() => {
                const keys = new Set();
                infoPoints.forEach(point => {
                    Object.keys(point.metadata || {}).forEach(key => keys.add(key));
                });
                return Array.from(keys).sort();
            }, [infoPoints]);

            // Filter and sort info points
            const sortedPoints = useMemo(() => {
                let filtered = infoPoints.filter(point => {
                    if (!filterText) return true;
                    const searchLower = filterText.toLowerCase();

                    // Search in name, label, description
                    if ((point.name || '').toLowerCase().includes(searchLower)) return true;
                    if ((point.label || '').toLowerCase().includes(searchLower)) return true;
                    if ((point.description || '').toLowerCase().includes(searchLower)) return true;

                    // Search in metadata values
                    for (const value of Object.values(point.metadata || {})) {
                        if (String(value).toLowerCase().includes(searchLower)) return true;
                    }
                    return false;
                });

                return filtered.sort((a, b) => {
                    let aVal, bVal;

                    if (sortField === 'name') {
                        aVal = a.name || '';
                        bVal = b.name || '';
                    } else if (sortField === 'label') {
                        aVal = a.label || '';
                        bVal = b.label || '';
                    } else {
                        // Metadata field
                        aVal = (a.metadata || {})[sortField] || '';
                        bVal = (b.metadata || {})[sortField] || '';
                    }

                    const comparison = String(aVal).localeCompare(String(bVal));
                    return sortDirection === 'asc' ? comparison : -comparison;
                });
            }, [infoPoints, filterText, sortField, sortDirection]);

            const handleSort = (field) => {
                if (sortField === field) {
                    setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
                } else {
                    setSortField(field);
                    setSortDirection('asc');
                }
            };

            const SortIndicator = ({ field }) => {
                if (sortField !== field) return null;
                return (
                    <span className="ml-1 text-accent">
                        {sortDirection === 'asc' ? '↑' : '↓'}
                    </span>
                );
            };

            const handleCellEdit = (pointId, field, value) => {
                const point = infoPoints.find(p => p.id === pointId);
                if (!point) return;

                if (field === 'name' || field === 'label') {
                    onUpdateInfoPoint(pointId, { [field]: value });
                } else {
                    // It's a metadata field
                    const updatedMetadata = {
                        ...(point.metadata || {}),
                        [field]: value
                    };
                    onUpdateInfoPoint(pointId, { metadata: updatedMetadata });
                }
            };

            // Export to CSV
            const handleExportCSV = () => {
                const headers = ['Name', 'Label', ...allMetadataKeys];
                const rows = sortedPoints.map(point => [
                    point.name || '',
                    point.label || '',
                    ...allMetadataKeys.map(key => (point.metadata || {})[key] || '')
                ]);

                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
                ].join('\n');

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'info-points-data.csv';
                link.click();
                URL.revokeObjectURL(url);
            };

            if (infoPoints.length === 0) {
                return (
                    <div className="p-4 text-center">
                        <div className="w-12 h-12 mx-auto mb-3 text-gray-600">
                            <Icons.Table />
                        </div>
                        <div className="text-gray-400 text-sm">No Info Points</div>
                        <div className="text-gray-600 text-xs mt-1">
                            Add info points to see metadata table
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full">
                    {/* Header with filter and export */}
                    <div className="p-2 border-b border-panel-border space-y-2">
                        <div className="flex items-center justify-between">
                            <span className="text-xs text-gray-400 uppercase tracking-wider">
                                Data View ({sortedPoints.length}/{infoPoints.length})
                            </span>
                            <button
                                onClick={handleExportCSV}
                                className="px-2 py-1 text-xs bg-gray-700 text-gray-300 rounded hover:bg-gray-600 flex items-center gap-1"
                            >
                                <div className="w-3 h-3"><Icons.Download /></div>
                                CSV
                            </button>
                        </div>
                        <input
                            type="text"
                            value={filterText}
                            onChange={(e) => setFilterText(e.target.value)}
                            placeholder="Filter..."
                            className="w-full text-xs"
                        />
                    </div>

                    {/* Table */}
                    <div className="flex-1 overflow-auto">
                        <table className="w-full text-xs">
                            <thead className="sticky top-0 bg-panel-bg">
                                <tr className="text-left text-gray-400">
                                    <th
                                        className="p-2 cursor-pointer hover:text-white whitespace-nowrap"
                                        onClick={() => handleSort('name')}
                                    >
                                        Name<SortIndicator field="name" />
                                    </th>
                                    <th
                                        className="p-2 cursor-pointer hover:text-white whitespace-nowrap"
                                        onClick={() => handleSort('label')}
                                    >
                                        Label<SortIndicator field="label" />
                                    </th>
                                    {allMetadataKeys.map(key => (
                                        <th
                                            key={key}
                                            className="p-2 cursor-pointer hover:text-white whitespace-nowrap text-accent"
                                            onClick={() => handleSort(key)}
                                        >
                                            {key}<SortIndicator field={key} />
                                        </th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {sortedPoints.map(point => (
                                    <tr
                                        key={point.id}
                                        className={`
                                            border-t border-panel-border hover:bg-gray-800 cursor-pointer
                                            ${selectedId === point.id ? 'bg-accent/20' : ''}
                                        `}
                                        onClick={() => onSelectItem(point, 'infoPoint')}
                                    >
                                        <td className="p-2">
                                            <input
                                                type="text"
                                                value={point.name || ''}
                                                onChange={(e) => handleCellEdit(point.id, 'name', e.target.value)}
                                                onClick={(e) => e.stopPropagation()}
                                                className="w-full bg-transparent border-none p-0 text-white"
                                            />
                                        </td>
                                        <td className="p-2">
                                            <input
                                                type="text"
                                                value={point.label || ''}
                                                onChange={(e) => handleCellEdit(point.id, 'label', e.target.value)}
                                                onClick={(e) => e.stopPropagation()}
                                                className="w-full bg-transparent border-none p-0 text-gray-300"
                                            />
                                        </td>
                                        {allMetadataKeys.map(key => (
                                            <td key={key} className="p-2">
                                                <input
                                                    type="text"
                                                    value={(point.metadata || {})[key] || ''}
                                                    onChange={(e) => handleCellEdit(point.id, key, e.target.value)}
                                                    onClick={(e) => e.stopPropagation()}
                                                    className="w-full bg-transparent border-none p-0 text-gray-400"
                                                    placeholder="—"
                                                />
                                            </td>
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>

                    {/* Footer with metadata keys summary */}
                    {allMetadataKeys.length > 0 && (
                        <div className="p-2 border-t border-panel-border text-xs text-gray-600">
                            Fields: {allMetadataKeys.join(', ')}
                        </div>
                    )}
                </div>
            );
        };

        // ============================================
        // INFO SUMMARY MODAL COMPONENT
        // ============================================

        const InfoSummaryModal = ({ isOpen, onClose, infoPoints, onSelectItem }) => {
            const [groupBy, setGroupBy] = useState('none');
            const [sortBy, setSortBy] = useState('number');

            // Sort and group points - all hooks must be called before any early return
            const { sortedPoints, groupedPoints } = useMemo(() => {
                // Sort points
                const sorted = [...infoPoints].sort((a, b) => {
                    switch (sortBy) {
                        case 'number': return (a.number || 0) - (b.number || 0);
                        case 'label': return (a.label || '').localeCompare(b.label || '');
                        case 'category': return (a.category || '').localeCompare(b.category || '');
                        case 'priority':
                            const priorityOrder = { high: 0, medium: 1, low: 2 };
                            return (priorityOrder[a.priority] || 1) - (priorityOrder[b.priority] || 1);
                        default: return 0;
                    }
                });

                // Group points
                let grouped;
                if (groupBy === 'none') {
                    grouped = { 'All Points': sorted };
                } else {
                    grouped = sorted.reduce((groups, point) => {
                        const key = groupBy === 'category'
                            ? (INFO_CATEGORIES[point.category] || INFO_CATEGORIES.general).label
                            : (INFO_PRIORITIES[point.priority] || INFO_PRIORITIES.medium).label;
                        if (!groups[key]) groups[key] = [];
                        groups[key].push(point);
                        return groups;
                    }, {});
                }

                return { sortedPoints: sorted, groupedPoints: grouped };
            }, [infoPoints, sortBy, groupBy]);

            if (!isOpen) return null;

            // Export to Markdown
            const handleExportMarkdown = () => {
                let markdown = '# Info Points Summary\n\n';

                if (groupBy === 'none') {
                    markdown += '| # | Label | Description | Category | Priority | Tags | Position |\n';
                    markdown += '|---|-------|-------------|----------|----------|------|----------|\n';
                    sortedPoints.forEach(point => {
                        const tags = (point.tags || []).join(', ');
                        const pos = `(${Math.round(point.x)}, ${Math.round(point.y)})`;
                        markdown += `| ${point.number || ''} | ${point.label || ''} | ${(point.description || '').replace(/\n/g, ' ')} | ${point.category || 'general'} | ${point.priority || 'medium'} | ${tags} | ${pos} |\n`;
                    });
                } else {
                    Object.entries(groupedPoints).forEach(([groupName, points]) => {
                        markdown += `## ${groupName}\n\n`;
                        markdown += '| # | Label | Description | Tags | Position |\n';
                        markdown += '|---|-------|-------------|------|----------|\n';
                        points.forEach(point => {
                            const tags = (point.tags || []).join(', ');
                            const pos = `(${Math.round(point.x)}, ${Math.round(point.y)})`;
                            markdown += `| ${point.number || ''} | ${point.label || ''} | ${(point.description || '').replace(/\n/g, ' ')} | ${tags} | ${pos} |\n`;
                        });
                        markdown += '\n';
                    });
                }

                // Copy to clipboard
                navigator.clipboard.writeText(markdown).then(() => {
                    alert('Markdown table copied to clipboard!');
                }).catch(() => {
                    // Fallback: create a blob and download
                    const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'info-points-summary.md';
                    link.click();
                    URL.revokeObjectURL(url);
                });
            };

            const handleRowClick = (point) => {
                onSelectItem(point, 'infoPoint');
                onClose();
            };

            return (
                <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50" onClick={onClose}>
                    <div
                        className="bg-panel-bg rounded-xl shadow-2xl w-[900px] max-w-[90vw] max-h-[85vh] flex flex-col"
                        onClick={e => e.stopPropagation()}
                    >
                        {/* Header */}
                        <div className="flex items-center justify-between p-4 border-b border-panel-border">
                            <div className="flex items-center gap-3">
                                <div className="w-8 h-8 text-accent"><Icons.Table /></div>
                                <div>
                                    <h2 className="text-lg font-semibold text-white">Info Points Summary</h2>
                                    <p className="text-xs text-gray-400">{infoPoints.length} points total</p>
                                </div>
                            </div>
                            <button onClick={onClose} className="p-2 hover:bg-gray-700 rounded-lg text-gray-400 hover:text-white">
                                <div className="w-5 h-5"><Icons.X /></div>
                            </button>
                        </div>

                        {/* Controls */}
                        <div className="flex items-center gap-4 p-3 border-b border-panel-border bg-[#1a1a1a]">
                            <div className="flex items-center gap-2">
                                <label className="text-xs text-gray-400">Group by:</label>
                                <select
                                    value={groupBy}
                                    onChange={(e) => setGroupBy(e.target.value)}
                                    className="text-xs"
                                >
                                    <option value="none">None</option>
                                    <option value="category">Category</option>
                                    <option value="priority">Priority</option>
                                </select>
                            </div>
                            <div className="flex items-center gap-2">
                                <label className="text-xs text-gray-400">Sort by:</label>
                                <select
                                    value={sortBy}
                                    onChange={(e) => setSortBy(e.target.value)}
                                    className="text-xs"
                                >
                                    <option value="number">Number</option>
                                    <option value="label">Label</option>
                                    <option value="category">Category</option>
                                    <option value="priority">Priority</option>
                                </select>
                            </div>
                            <div className="flex-1" />
                            <button
                                onClick={handleExportMarkdown}
                                className="px-3 py-1.5 text-xs bg-accent text-white rounded hover:bg-accent-hover flex items-center gap-1"
                            >
                                <div className="w-4 h-4"><Icons.Copy /></div>
                                Copy as Markdown
                            </button>
                        </div>

                        {/* Table Content */}
                        <div className="flex-1 overflow-auto p-4">
                            {infoPoints.length === 0 ? (
                                <div className="text-center py-12 text-gray-500">
                                    <div className="w-16 h-16 mx-auto mb-4 text-gray-600"><Icons.InfoPoint /></div>
                                    <p>No info points yet</p>
                                    <p className="text-xs mt-1">Press I to add an info point</p>
                                </div>
                            ) : (
                                Object.entries(groupedPoints).map(([groupName, points]) => (
                                    <div key={groupName} className="mb-6">
                                        {groupBy !== 'none' && (
                                            <div className="flex items-center gap-2 mb-2">
                                                <div
                                                    className="w-3 h-3 rounded-full"
                                                    style={{
                                                        backgroundColor: groupBy === 'category'
                                                            ? Object.values(INFO_CATEGORIES).find(c => c.label === groupName)?.color
                                                            : Object.values(INFO_PRIORITIES).find(p => p.label === groupName)?.color
                                                    }}
                                                />
                                                <h3 className="text-sm font-medium text-white">{groupName}</h3>
                                                <span className="text-xs text-gray-500">({points.length})</span>
                                            </div>
                                        )}
                                        <table className="data-table text-sm">
                                            <thead>
                                                <tr>
                                                    <th className="w-10">#</th>
                                                    <th className="w-32">Label</th>
                                                    <th>Description</th>
                                                    {groupBy !== 'category' && <th className="w-24">Category</th>}
                                                    {groupBy !== 'priority' && <th className="w-20">Priority</th>}
                                                    <th className="w-32">Tags</th>
                                                    <th className="w-24">Position</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {points.map(point => (
                                                    <tr
                                                        key={point.id}
                                                        onClick={() => handleRowClick(point)}
                                                        className="cursor-pointer"
                                                    >
                                                        <td>
                                                            <div
                                                                className="w-6 h-6 rounded-full flex items-center justify-center text-white text-xs font-bold"
                                                                style={{ backgroundColor: (INFO_CATEGORIES[point.category] || INFO_CATEGORIES.general).color }}
                                                            >
                                                                {point.number}
                                                            </div>
                                                        </td>
                                                        <td className="font-medium text-white">{point.label || '—'}</td>
                                                        <td className="text-gray-300 truncate max-w-xs" title={point.description}>
                                                            {point.description || '—'}
                                                        </td>
                                                        {groupBy !== 'category' && (
                                                            <td>
                                                                <span
                                                                    className="px-2 py-0.5 text-xs rounded-full text-white"
                                                                    style={{ backgroundColor: (INFO_CATEGORIES[point.category] || INFO_CATEGORIES.general).color }}
                                                                >
                                                                    {(INFO_CATEGORIES[point.category] || INFO_CATEGORIES.general).label}
                                                                </span>
                                                            </td>
                                                        )}
                                                        {groupBy !== 'priority' && (
                                                            <td>
                                                                <span
                                                                    className="px-2 py-0.5 text-xs rounded text-white"
                                                                    style={{ backgroundColor: (INFO_PRIORITIES[point.priority] || INFO_PRIORITIES.medium).color }}
                                                                >
                                                                    {(INFO_PRIORITIES[point.priority] || INFO_PRIORITIES.medium).label}
                                                                </span>
                                                            </td>
                                                        )}
                                                        <td>
                                                            <div className="flex flex-wrap gap-1">
                                                                {(point.tags || []).slice(0, 3).map((tag, idx) => (
                                                                    <span key={idx} className="px-1.5 py-0.5 text-xs bg-gray-700 text-gray-300 rounded">
                                                                        {tag}
                                                                    </span>
                                                                ))}
                                                                {(point.tags || []).length > 3 && (
                                                                    <span className="text-xs text-gray-500">+{point.tags.length - 3}</span>
                                                                )}
                                                            </div>
                                                        </td>
                                                        <td className="text-gray-400 text-xs mono">
                                                            {Math.round(point.x)}, {Math.round(point.y)}
                                                        </td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                ))
                            )}
                        </div>

                        {/* Footer */}
                        <div className="p-3 border-t border-panel-border bg-[#1a1a1a] text-xs text-gray-500">
                            Click on a row to select the info point on canvas
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================
        // CALIBRATION DIALOG COMPONENT
        // ============================================

        const CalibrationDialog = ({ isOpen, onClose, onConfirm, calibrationPoints }) => {
            const [knownDistance, setKnownDistance] = useState('');
            const [unit, setUnit] = useState('meters');

            if (!isOpen) return null;

            const pixelDist = calibrationPoints.length === 2
                ? Math.round(distance(calibrationPoints[0], calibrationPoints[1]))
                : 0;

            const handleConfirm = () => {
                const dist = parseFloat(knownDistance);
                if (dist > 0) {
                    onConfirm(dist, unit);
                }
            };

            return (
                <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50" onClick={onClose}>
                    <div className="bg-panel-bg rounded-xl shadow-2xl w-96 p-6" onClick={e => e.stopPropagation()}>
                        <div className="flex items-center gap-3 mb-4">
                            <div className="w-8 h-8 text-accent"><Icons.Calibrate /></div>
                            <h2 className="text-lg font-semibold text-white">Scale Calibration</h2>
                        </div>

                        <div className="space-y-4">
                            <div className="text-sm text-gray-400">
                                You've selected two points that are <span className="text-white font-mono">{pixelDist}px</span> apart.
                            </div>

                            <div>
                                <label className="block text-xs text-gray-400 mb-1">Known Distance</label>
                                <div className="flex gap-2">
                                    <input
                                        type="number"
                                        value={knownDistance}
                                        onChange={(e) => setKnownDistance(e.target.value)}
                                        placeholder="Enter distance"
                                        className="flex-1"
                                        autoFocus
                                    />
                                    <select
                                        value={unit}
                                        onChange={(e) => setUnit(e.target.value)}
                                        className="w-24"
                                    >
                                        <option value="meters">meters</option>
                                        <option value="feet">feet</option>
                                    </select>
                                </div>
                            </div>

                            <div className="text-xs text-gray-500">
                                This will set the scale for all measurements on this drawing.
                            </div>
                        </div>

                        <div className="flex gap-2 mt-6">
                            <button onClick={onClose} className="flex-1 px-4 py-2 bg-gray-700 text-gray-300 rounded hover:bg-gray-600">
                                Cancel
                            </button>
                            <button
                                onClick={handleConfirm}
                                disabled={!knownDistance || parseFloat(knownDistance) <= 0}
                                className="flex-1 px-4 py-2 bg-accent text-white rounded hover:bg-accent-hover disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                Calibrate
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================
        // SYMBOL LIBRARY PANEL COMPONENT
        // ============================================

        const SymbolLibraryPanel = ({ selectedSymbolId, onSelectSymbol, symbolCategory, onSetCategory, favorites, onToggleFavorite }) => {
            const categories = [
                { id: 'all', label: 'All' },
                ...Object.entries(HV_SYMBOL_CATEGORIES).map(([id, cat]) => ({ id, label: cat.label }))
            ];

            const filteredSymbols = symbolCategory === 'all'
                ? Object.values(HV_SYMBOLS)
                : Object.values(HV_SYMBOLS).filter(s => s.category === symbolCategory);

            return (
                <div className="flex flex-col h-full">
                    {/* Category Filter */}
                    <div className="p-2 border-b border-panel-border">
                        <div className="flex flex-wrap gap-1">
                            {categories.map(cat => (
                                <button
                                    key={cat.id}
                                    onClick={() => onSetCategory(cat.id)}
                                    className={`px-2 py-1 text-xs rounded ${
                                        symbolCategory === cat.id
                                            ? 'bg-accent text-white'
                                            : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                    }`}
                                >
                                    {cat.label}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Symbol Grid */}
                    <div className="flex-1 overflow-y-auto p-2">
                        <div className="grid grid-cols-2 gap-2">
                            {filteredSymbols.map(symbol => {
                                const catColor = HV_SYMBOL_CATEGORIES[symbol.category]?.color || '#666';
                                const catLabel = HV_SYMBOL_CATEGORIES[symbol.category]?.label || symbol.category;
                                const isFavorite = favorites?.some(f => f.symbolId === symbol.id);
                                return (
                                    <div
                                        key={symbol.id}
                                        onClick={() => onSelectSymbol(symbol.id)}
                                        onContextMenu={(e) => {
                                            e.preventDefault();
                                            if (onToggleFavorite) onToggleFavorite(symbol.id);
                                        }}
                                        className={`
                                            p-2 rounded-lg cursor-pointer border-2 transition-all relative group
                                            ${selectedSymbolId === symbol.id
                                                ? 'border-accent bg-accent/20'
                                                : 'border-transparent bg-gray-800/50 hover:bg-gray-700'}
                                        `}
                                        title={`${symbol.name}\nRight-click to ${isFavorite ? 'remove from' : 'add to'} favorites`}
                                    >
                                        {/* Favorite indicator */}
                                        {isFavorite && (
                                            <div className="absolute top-1 right-1 w-4 h-4 text-yellow-400">
                                                <Icons.Star />
                                            </div>
                                        )}
                                        {/* Add to favorites button on hover */}
                                        {!isFavorite && (
                                            <button
                                                className="absolute top-1 right-1 w-4 h-4 text-gray-500 opacity-0 group-hover:opacity-100 hover:text-yellow-400 transition-all"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (onToggleFavorite) onToggleFavorite(symbol.id);
                                                }}
                                                title="Add to favorites"
                                            >
                                                <Icons.Star />
                                            </button>
                                        )}
                                        <div className="flex items-center justify-center h-14 bg-white/5 rounded mb-2">
                                            <svg
                                                width={Math.min(symbol.width, 55)}
                                                height={Math.min(symbol.height, 45)}
                                                viewBox={`0 0 ${symbol.width} ${symbol.height}`}
                                                dangerouslySetInnerHTML={{ __html: symbol.svg }}
                                            />
                                        </div>
                                        <div className="text-xs text-white truncate font-medium">{symbol.name}</div>
                                        <div className="flex items-center gap-1 mt-1">
                                            <div
                                                className="w-2 h-2 rounded-full"
                                                style={{ backgroundColor: catColor }}
                                            />
                                            <span className="text-[10px] text-gray-500">{catLabel}</span>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* Selected Symbol Info */}
                    {selectedSymbolId && HV_SYMBOLS[selectedSymbolId] && (
                        <div className="p-3 border-t border-panel-border bg-[#1a1a1a]">
                            <div className="text-sm text-white font-medium">{HV_SYMBOLS[selectedSymbolId].name}</div>
                            <div className="text-xs text-gray-500 mt-1">
                                Click on canvas to place • Press ESC to cancel
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // ============================================
        // SNIPPET LIBRARY COMPONENT
        // ============================================

        const SnippetLibrary = ({ library, onSaveSnippet, onInsertSnippet, onDeleteFromLibrary, currentSnippet }) => {
            const [newName, setNewName] = useState('');

            const handleSave = () => {
                if (currentSnippet && newName.trim()) {
                    onSaveSnippet({
                        ...currentSnippet,
                        libraryName: newName.trim(),
                        savedAt: new Date().toISOString()
                    });
                    setNewName('');
                }
            };

            return (
                <div className="p-3 space-y-4">
                    <div className="text-xs text-gray-500 uppercase tracking-wider mb-2">Snippet Library</div>

                    {/* Save current snippet */}
                    {currentSnippet && (
                        <div className="space-y-2 p-3 bg-gray-800 rounded">
                            <div className="text-xs text-gray-400">Save selected snippet to library:</div>
                            <input
                                type="text"
                                value={newName}
                                onChange={(e) => setNewName(e.target.value)}
                                placeholder="Library name..."
                                className="w-full"
                            />
                            <button
                                onClick={handleSave}
                                disabled={!newName.trim()}
                                className="w-full px-3 py-1.5 text-sm bg-accent text-white rounded hover:bg-accent-hover disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                Save to Library
                            </button>
                        </div>
                    )}

                    {/* Library list */}
                    <div className="space-y-2">
                        <div className="text-xs text-gray-400">Saved Snippets ({library.length})</div>
                        {library.length === 0 ? (
                            <div className="text-xs text-gray-500 italic p-2">
                                No saved snippets yet. Select a snippet and save it to the library.
                            </div>
                        ) : (
                            <div className="space-y-2 max-h-80 overflow-y-auto">
                                {library.map((item, index) => (
                                    <div
                                        key={item.id || index}
                                        className="p-2 bg-gray-800 rounded hover:bg-gray-700 group"
                                    >
                                        {/* Thumbnail preview */}
                                        {item.imageData && (
                                            <div className="mb-2 border border-gray-600 rounded overflow-hidden bg-gray-900">
                                                <img
                                                    src={item.imageData}
                                                    alt={item.libraryName}
                                                    style={{
                                                        width: '100%',
                                                        maxHeight: '80px',
                                                        objectFit: 'contain'
                                                    }}
                                                />
                                            </div>
                                        )}
                                        <div className="flex items-center gap-2">
                                            <div className="flex-1 min-w-0">
                                                <div className="text-sm text-white truncate">{item.libraryName}</div>
                                                <div className="text-xs text-gray-500">
                                                    {item.width}x{item.height}px
                                                </div>
                                            </div>
                                            <button
                                                onClick={() => onInsertSnippet(item)}
                                                className="px-2 py-1 text-xs bg-accent text-white rounded opacity-0 group-hover:opacity-100 transition-opacity"
                                                title="Insert into document"
                                            >
                                                Insert
                                            </button>
                                            <button
                                                onClick={() => onDeleteFromLibrary(index)}
                                                className="w-5 h-5 text-gray-400 hover:text-danger opacity-0 group-hover:opacity-100 transition-opacity"
                                                title="Remove from library"
                                            >
                                                <Icons.Trash />
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // ============================================
        // MAIN APPLICATION
        // ============================================
        
        const CableMarkupEditor = () => {
            // PDF State
            const [pdfData, setPdfData] = useState(null);
            const [currentPage, setCurrentPage] = useState(0);
            const [loading, setLoading] = useState(false);
            const [loadingProgress, setLoadingProgress] = useState(0);
            
            // Canvas State
            const [zoom, setZoom] = useState(1);
            const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [panStart, setPanStart] = useState({ x: 0, y: 0 });
            
            // Tool State
            const [currentTool, setCurrentTool] = useState(OPERATIONS.SELECT);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawEnd, setDrawEnd] = useState(null);
            
            // Selection State
            const [selectedId, setSelectedId] = useState(null);
            const [selectedType, setSelectedType] = useState(null);
            const [selectedIds, setSelectedIds] = useState([]); // Multi-select: [{id, type}, ...]
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState(null);
            const [selectionBox, setSelectionBox] = useState(null); // {x1, y1, x2, y2} for box selection

            // Element State
            const [snippets, setSnippets] = useState([]);
            const [masks, setMasks] = useState([]);
            const [elements, setElements] = useState([]);
            const [infoPoints, setInfoPoints] = useState([]);
            const [symbols, setSymbols] = useState([]);
            const [measurements, setMeasurements] = useState([]);
            const [cableAnnotations, setCableAnnotations] = useState([]);
            const [comments, setComments] = useState([]);
            const [bezierCurves, setBezierCurves] = useState([]);
            const [cloudAnnotations, setCloudAnnotations] = useState([]);
            const [leaderLines, setLeaderLines] = useState([]);
            const [selectedComment, setSelectedComment] = useState(null);
            const [showCommentDialog, setShowCommentDialog] = useState(false);
            const [commentDialogPosition, setCommentDialogPosition] = useState({ x: 0, y: 0 });
            const [newCommentText, setNewCommentText] = useState('');
            const [replyText, setReplyText] = useState('');

            // Element Groups State
            const [groups, setGroups] = useState([]); // [{id, name, members: [{id, type}], visible, locked}]

            // Polyline/Freehand Drawing State
            const [polylinePoints, setPolylinePoints] = useState([]);
            const [polygonPoints, setPolygonPoints] = useState([]);
            const [arcPoints, setArcPoints] = useState([]); // [start, control, end]
            const [areaPoints, setAreaPoints] = useState([]);
            const [bezierPoints, setBezierPoints] = useState([]); // [start, control1, control2, end] for cubic bezier
            const [cloudPoints, setCloudPoints] = useState([]); // points for cloud annotation
            const [leaderPoints, setLeaderPoints] = useState([]); // [anchor, elbow, endpoint]
            const [leaderText, setLeaderText] = useState('');
            const [freehandPath, setFreehandPath] = useState([]);
            const [isDrawingFreehand, setIsDrawingFreehand] = useState(false);

            // Image Overlays State
            const [imageOverlays, setImageOverlays] = useState([]);

            // Recent Files State
            const [recentFiles, setRecentFiles] = useState(() => {
                const saved = localStorage.getItem('markupRecentFiles');
                return saved ? JSON.parse(saved) : [];
            });

            // Favorites State
            const [favorites, setFavorites] = useState(() => {
                const saved = localStorage.getItem('markupFavorites');
                return saved ? JSON.parse(saved) : [];
            });

            // Clipboard State for Copy/Paste
            const [clipboard, setClipboard] = useState(null);

            // Scale Calibration State
            const [scaleCalibration, setScaleCalibration] = useState({
                isCalibrated: false,
                pixelsPerMeter: null,
                unit: 'meters',
                calibrationPoints: null
            });
            const [calibrationStep, setCalibrationStep] = useState(0); // 0: not started, 1: first point, 2: second point
            const [calibrationPoints, setCalibrationPoints] = useState([]);

            // Symbol Placement State
            const [selectedSymbolId, setSelectedSymbolId] = useState(null);
            const [symbolCategory, setSymbolCategory] = useState('all');

            // Snippet Library
            const [snippetLibrary, setSnippetLibrary] = useState(() => {
                const saved = localStorage.getItem('snippetLibrary');
                return saved ? JSON.parse(saved) : [];
            });

            // Template Library
            const [templateLibrary, setTemplateLibrary] = useState(() => {
                const saved = localStorage.getItem('markupTemplateLibrary');
                return saved ? JSON.parse(saved) : [];
            });
            const [showTemplateDialog, setShowTemplateDialog] = useState(false);
            const [templateName, setTemplateName] = useState('');
            const [templateDescription, setTemplateDescription] = useState('');

            // UI State
            const [showGrid, setShowGrid] = useState(true);
            const [snapEnabled, setSnapEnabled] = useState(false);
            const [snapGridSize, setSnapGridSize] = useState(20); // Default same as GRID_SIZE
            const [smartGuidesEnabled, setSmartGuidesEnabled] = useState(true);
            const [alignmentGuides, setAlignmentGuides] = useState([]); // Active alignment guides to render
            const [styles, setStyles] = useState({ ...DEFAULT_STYLES });
            const [leftPanelTab, setLeftPanelTab] = useState('tools'); // 'tools' | 'layers' | 'library' | 'pages'
            const [librarySubTab, setLibrarySubTab] = useState('symbols'); // 'symbols' | 'snippets' | 'templates' | 'favorites'
            const [layersSubTab, setLayersSubTab] = useState('layers'); // 'layers' | 'data'
            const [showCalibrationDialog, setShowCalibrationDialog] = useState(false);
            const [showExportMenu, setShowExportMenu] = useState(false);
            const [showShortcutsPanel, setShowShortcutsPanel] = useState(false);
            const [showMinimap, setShowMinimap] = useState(true);
            const [contextMenu, setContextMenu] = useState(null); // { x, y, type: 'canvas'|'element', elementId?, elementType? }
            const [collapsedSections, setCollapsedSections] = useState(() => {
                const saved = localStorage.getItem('markupToolCollapsedSections');
                return saved ? JSON.parse(saved) : { selection: false, drawing: false, annotation: false, measurement: false, view: true, style: true };
            });
            const toggleSection = (section) => {
                setCollapsedSections(prev => {
                    const next = { ...prev, [section]: !prev[section] };
                    localStorage.setItem('markupToolCollapsedSections', JSON.stringify(next));
                    return next;
                });
            };
            const [theme, setTheme] = useState(() => {
                const saved = localStorage.getItem('markupToolTheme');
                return saved || 'dark';
            });

            // Auto-save state
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            const [autoSaveVersions, setAutoSaveVersions] = useState(() => {
                const saved = localStorage.getItem('markupToolAutoSaveVersions');
                return saved ? JSON.parse(saved) : [];
            });
            const [showVersionHistory, setShowVersionHistory] = useState(false);
            const [lastAutoSave, setLastAutoSave] = useState(null);
            const [lastSaveTime, setLastSaveTime] = useState(null);

            // Resizable sidebar state
            const [leftSidebarWidth, setLeftSidebarWidth] = useState(256); // 256px = w-64
            const [rightSidebarWidth, setRightSidebarWidth] = useState(288); // 288px = w-72
            const [isResizingLeft, setIsResizingLeft] = useState(false);
            const [isResizingRight, setIsResizingRight] = useState(false);
            const MIN_SIDEBAR_WIDTH = 200;
            const MAX_SIDEBAR_WIDTH = 400;

            // Close export menu when clicking outside
            useEffect(() => {
                const handleClickOutside = () => {
                    if (showExportMenu) setShowExportMenu(false);
                };
                if (showExportMenu) {
                    document.addEventListener('click', handleClickOutside);
                    return () => document.removeEventListener('click', handleClickOutside);
                }
            }, [showExportMenu]);

            // Theme effect - apply theme class to body
            useEffect(() => {
                document.body.classList.remove('light-theme', 'dark-theme');
                document.body.classList.add(theme === 'light' ? 'light-theme' : 'dark-theme');
                localStorage.setItem('markupToolTheme', theme);
            }, [theme]);

            // Track unsaved changes
            useEffect(() => {
                if (snippets.length > 0 || masks.length > 0 || elements.length > 0 || infoPoints.length > 0 || symbols.length > 0) {
                    setHasUnsavedChanges(true);
                }
            }, [snippets, masks, elements, infoPoints, symbols, measurements]);

            // Auto-save every 2 minutes
            useEffect(() => {
                const autoSaveInterval = setInterval(() => {
                    if (hasUnsavedChanges && (snippets.length > 0 || masks.length > 0 || elements.length > 0 || infoPoints.length > 0 || symbols.length > 0)) {
                        const saveData = {
                            timestamp: Date.now(),
                            date: new Date().toLocaleString(),
                            pdfName: pdfData?.fileName || 'Untitled',
                            data: {
                                snippets,
                                masks,
                                elements,
                                infoPoints,
                                symbols,
                                measurements,
                                cableAnnotations,
                                scaleCalibration,
                                currentPage
                            }
                        };

                        setAutoSaveVersions(prev => {
                            const updated = [saveData, ...prev].slice(0, 10); // Keep last 10 versions
                            localStorage.setItem('markupToolAutoSaveVersions', JSON.stringify(updated));
                            return updated;
                        });
                        setLastAutoSave(new Date().toLocaleTimeString());
                        setLastSaveTime(new Date());
                        setHasUnsavedChanges(false);
                    }
                }, 120000); // 2 minutes

                return () => clearInterval(autoSaveInterval);
            }, [hasUnsavedChanges, snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations, scaleCalibration, currentPage, pdfData]);

            // Warn before leaving with unsaved changes
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (hasUnsavedChanges) {
                        e.preventDefault();
                        e.returnValue = '';
                    }
                };
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [hasUnsavedChanges]);

            // Restore from auto-save version
            const restoreFromVersion = (version) => {
                if (confirm('Restore this version? Current unsaved changes will be lost.')) {
                    setSnippets(version.data.snippets || []);
                    setMasks(version.data.masks || []);
                    setElements(version.data.elements || []);
                    setInfoPoints(version.data.infoPoints || []);
                    setSymbols(version.data.symbols || []);
                    setMeasurements(version.data.measurements || []);
                    setCableAnnotations(version.data.cableAnnotations || []);
                    if (version.data.scaleCalibration) setScaleCalibration(version.data.scaleCalibration);
                    if (version.data.currentPage !== undefined) setCurrentPage(version.data.currentPage);
                    setShowVersionHistory(false);
                    setHasUnsavedChanges(false);
                }
            };

            // Sidebar resize handlers
            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (isResizingLeft) {
                        const newWidth = Math.min(MAX_SIDEBAR_WIDTH, Math.max(MIN_SIDEBAR_WIDTH, e.clientX));
                        setLeftSidebarWidth(newWidth);
                    }
                    if (isResizingRight) {
                        const newWidth = Math.min(MAX_SIDEBAR_WIDTH, Math.max(MIN_SIDEBAR_WIDTH, window.innerWidth - e.clientX));
                        setRightSidebarWidth(newWidth);
                    }
                };
                const handleMouseUp = () => {
                    setIsResizingLeft(false);
                    setIsResizingRight(false);
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                };
                if (isResizingLeft || isResizingRight) {
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [isResizingLeft, isResizingRight]);

            // Helper functions for align/distribute
            const getSelectedItems = () => {
                return selectedIds.map(sel => {
                    let item;
                    if (sel.type === 'element') item = elements.find(e => e.id === sel.id);
                    else if (sel.type === 'snippet') item = snippets.find(s => s.id === sel.id);
                    else if (sel.type === 'mask') item = masks.find(m => m.id === sel.id);
                    else if (sel.type === 'symbol') item = symbols.find(s => s.id === sel.id);
                    else if (sel.type === 'infoPoint') item = infoPoints.find(p => p.id === sel.id);
                    else if (sel.type === 'measurement') item = measurements.find(m => m.id === sel.id);
                    return item ? { ...item, type: sel.type } : null;
                }).filter(Boolean);
            };

            const applyToSelected = (updateFn) => {
                selectedIds.forEach(sel => {
                    const item = getSelectedItems().find(i => i.id === sel.id);
                    if (!item || item.locked) return;
                    const updates = updateFn(item);
                    if (sel.type === 'element') setElements(prev => prev.map(e => e.id === sel.id ? { ...e, ...updates } : e));
                    else if (sel.type === 'snippet') setSnippets(prev => prev.map(s => s.id === sel.id ? { ...s, ...updates } : s));
                    else if (sel.type === 'mask') setMasks(prev => prev.map(m => m.id === sel.id ? { ...m, ...updates } : m));
                    else if (sel.type === 'symbol') setSymbols(prev => prev.map(s => s.id === sel.id ? { ...s, ...updates } : s));
                    else if (sel.type === 'infoPoint') setInfoPoints(prev => prev.map(p => p.id === sel.id ? { ...p, ...updates } : p));
                    else if (sel.type === 'measurement') setMeasurements(prev => prev.map(m => m.id === sel.id ? { ...m, ...updates } : m));
                });
            };

            const applyToSelectedById = (id, type, updates) => {
                if (type === 'element') setElements(prev => prev.map(e => e.id === id ? { ...e, ...updates } : e));
                else if (type === 'snippet') setSnippets(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
                else if (type === 'mask') setMasks(prev => prev.map(m => m.id === id ? { ...m, ...updates } : m));
                else if (type === 'symbol') setSymbols(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
                else if (type === 'infoPoint') setInfoPoints(prev => prev.map(p => p.id === id ? { ...p, ...updates } : p));
                else if (type === 'measurement') setMeasurements(prev => prev.map(m => m.id === id ? { ...m, ...updates } : m));
            };

            const [showInfoSummary, setShowInfoSummary] = useState(false);

            // Refs
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const fileInputRef = useRef(null);
            const exportCanvasRef = useRef(null);
            
            // History
            const history = useHistory({ snippets: [], masks: [], elements: [], infoPoints: [], symbols: [], measurements: [], cableAnnotations: [] });
            
            // ============================================
            // COMPUTED VALUES
            // ============================================
            
            const currentPageData = useMemo(() => {
                if (!pdfData || !pdfData.pages[currentPage]) return null;
                return pdfData.pages[currentPage];
            }, [pdfData, currentPage]);
            
            const selectedItem = useMemo(() => {
                if (!selectedId) return null;
                if (selectedType === 'snippet') return snippets.find(s => s.id === selectedId);
                if (selectedType === 'mask') return masks.find(m => m.id === selectedId);
                if (selectedType === 'element') return elements.find(e => e.id === selectedId);
                if (selectedType === 'infoPoint') return infoPoints.find(p => p.id === selectedId);
                if (selectedType === 'symbol') return symbols.find(s => s.id === selectedId);
                if (selectedType === 'measurement') return measurements.find(m => m.id === selectedId);
                return null;
            }, [selectedId, selectedType, snippets, masks, elements, infoPoints, symbols, measurements]);
            
            // ============================================
            // COORDINATE TRANSFORMATION
            // ============================================
            
            const screenToCanvas = useCallback((screenX, screenY) => {
                const container = containerRef.current;
                if (!container) return { x: 0, y: 0 };
                
                const rect = container.getBoundingClientRect();
                return {
                    x: (screenX - rect.left - panOffset.x) / zoom,
                    y: (screenY - rect.top - panOffset.y) / zoom
                };
            }, [zoom, panOffset]);
            
            // ============================================
            // FILE HANDLING
            // ============================================
            
            const IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp', '.svg'];

            const isImageFile = (fileName) => {
                const lower = fileName.toLowerCase();
                return IMAGE_EXTENSIONS.some(ext => lower.endsWith(ext));
            };

            const isPdfFile = (fileName) => {
                return fileName.toLowerCase().endsWith('.pdf');
            };

            const handleFileLoad = async (file) => {
                if (!file) {
                    alert('Please select a file');
                    return;
                }

                const fileName = file.name;
                const isImage = isImageFile(fileName);
                const isPdf = isPdfFile(fileName);

                if (!isImage && !isPdf) {
                    alert('Please select a valid PDF or image file (PNG, JPG, JPEG, GIF, WEBP, BMP, SVG)');
                    return;
                }

                setLoading(true);
                setLoadingProgress(0);

                try {
                    const data = isImage ? await loadImage(file) : await loadPDF(file);
                    setPdfData(data);
                    setCurrentPage(0);
                    setSnippets([]);
                    setMasks([]);
                    setElements([]);
                    setSelectedId(null);
                    setZoom(1);
                    setPanOffset({ x: 0, y: 0 });

                    // Add to recent files
                    const newRecentFile = {
                        name: file.name,
                        type: isImage ? 'image' : 'pdf',
                        timestamp: new Date().toISOString(),
                        size: file.size
                    };
                    setRecentFiles(prev => {
                        const filtered = prev.filter(f => f.name !== file.name);
                        const updated = [newRecentFile, ...filtered].slice(0, 10);
                        localStorage.setItem('markupRecentFiles', JSON.stringify(updated));
                        return updated;
                    });

                    // Fit to view
                    setTimeout(() => fitToView(), 100);
                } catch (error) {
                    console.error('Failed to load file:', error);
                    alert(`Failed to load ${isImage ? 'image' : 'PDF'}. Please try another file.`);
                } finally {
                    setLoading(false);
                }
            };
            
            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const file = e.dataTransfer.files[0];
                if (file) handleFileLoad(file);
            };
            
            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            // Image Overlay Import
            const imageOverlayInputRef = useRef(null);

            const handleImportImageOverlay = async (file) => {
                if (!file || !pdfData) return;

                const isImage = isImageFile(file.name);
                if (!isImage) {
                    alert('Please select an image file (PNG, JPG, JPEG, GIF, WEBP, BMP, SVG)');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const newOverlay = {
                            id: generateId(),
                            type: 'imageOverlay',
                            name: file.name,
                            imageData: e.target.result,
                            x: 50,
                            y: 50,
                            width: img.width,
                            height: img.height,
                            originalWidth: img.width,
                            originalHeight: img.height,
                            opacity: 1,
                            visible: true,
                            locked: false
                        };
                        setImageOverlays(prev => [...prev, newOverlay]);
                        setSelectedId(newOverlay.id);
                        setSelectedType('imageOverlay');
                        history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            };

            // ============================================
            // VIEWPORT CONTROLS
            // ============================================
            
            const fitToView = useCallback(() => {
                if (!currentPageData || !containerRef.current) return;
                
                const container = containerRef.current;
                const padding = 40;
                const availableWidth = container.clientWidth - padding * 2;
                const availableHeight = container.clientHeight - padding * 2;
                
                const scaleX = availableWidth / currentPageData.width;
                const scaleY = availableHeight / currentPageData.height;
                const newZoom = Math.min(scaleX, scaleY, 1);
                
                setZoom(newZoom);
                setPanOffset({
                    x: (container.clientWidth - currentPageData.width * newZoom) / 2,
                    y: (container.clientHeight - currentPageData.height * newZoom) / 2
                });
            }, [currentPageData]);
            
            const handleWheel = useCallback((e) => {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = clamp(zoom * delta, ZOOM_LIMITS.min, ZOOM_LIMITS.max);
                
                // Zoom towards mouse position
                const container = containerRef.current;
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const scale = newZoom / zoom;
                const newPanX = mouseX - (mouseX - panOffset.x) * scale;
                const newPanY = mouseY - (mouseY - panOffset.y) * scale;
                
                setZoom(newZoom);
                setPanOffset({ x: newPanX, y: newPanY });
            }, [zoom, panOffset]);
            
            // ============================================
            // MOUSE HANDLERS
            // ============================================
            
            const handleMouseDown = useCallback((e) => {
                const coords = screenToCanvas(e.clientX, e.clientY);

                // Middle mouse or space+click for panning
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    setIsPanning(true);
                    setPanStart({ x: e.clientX - panOffset.x, y: e.clientY - panOffset.y });
                    return;
                }

                // Left click
                if (e.button === 0) {
                    switch (currentTool) {
                        case OPERATIONS.SELECT:
                            // Check if clicking on an element
                            const clickedSnippet = snippets.find(s =>
                                s.visible !== false && pointInRect(coords, { x: s.x, y: s.y, width: s.width, height: s.height })
                            );
                            const clickedMask = masks.find(m =>
                                m.visible !== false && pointInRect(coords, { x: m.x, y: m.y, width: m.width, height: m.height })
                            );
                            // Check image overlays
                            const clickedImageOverlay = imageOverlays.find(img =>
                                img.visible !== false && pointInRect(coords, { x: img.x, y: img.y, width: img.width, height: img.height })
                            );
                            // Check info points (click within 15px radius)
                            const clickedInfoPoint = infoPoints.find(p =>
                                p.visible !== false && distance(coords, { x: p.x, y: p.y }) <= 15
                            );

                            // Check symbols
                            const clickedSymbol = symbols.find(s =>
                                s.visible !== false && pointInRect(coords, { x: s.x, y: s.y, width: s.width * (s.scale || 1), height: s.height * (s.scale || 1) })
                            );

                            // Check measurements
                            const clickedMeasurement = measurements.find(m =>
                                m.visible !== false && pointToLineDistance(coords, m.x1, m.y1, m.x2, m.y2) <= 10
                            );

                            // Check bezier curves
                            const clickedBezier = bezierCurves.find(b => {
                                if (b.visible === false || !b.points || b.points.length < 4) return false;
                                // Check if near any of the 4 points or the control lines
                                for (let i = 0; i < b.points.length; i++) {
                                    if (distance(coords, b.points[i]) <= 10) return true;
                                }
                                return false;
                            });

                            // Check cloud annotations
                            const clickedCloud = cloudAnnotations.find(c => {
                                if (c.visible === false || !c.points || c.points.length < 3) return false;
                                // Use polygon hit test
                                let inside = false;
                                for (let i = 0, j = c.points.length - 1; i < c.points.length; j = i++) {
                                    const xi = c.points[i].x, yi = c.points[i].y;
                                    const xj = c.points[j].x, yj = c.points[j].y;
                                    if (((yi > coords.y) !== (yj > coords.y)) && (coords.x < (xj - xi) * (coords.y - yi) / (yj - yi) + xi)) {
                                        inside = !inside;
                                    }
                                }
                                return inside;
                            });

                            // Check leader lines
                            const clickedLeader = leaderLines.find(l => {
                                if (l.visible === false || !l.points || l.points.length < 3) return false;
                                // Check if near any segment of the leader line
                                for (let i = 0; i < l.points.length - 1; i++) {
                                    if (pointToLineDistance(coords, l.points[i].x, l.points[i].y, l.points[i+1].x, l.points[i+1].y) <= 10) {
                                        return true;
                                    }
                                }
                                return false;
                            });

                            // Check elements (rectangles, circles, lines, arrows, text, polylines, freehand)
                            const clickedElement = elements.find(el => {
                                if (el.visible === false) return false;
                                switch (el.type) {
                                    case 'rectangle':
                                        return pointInRect(coords, { x: el.x, y: el.y, width: el.width, height: el.height });
                                    case 'circle':
                                        return pointInCircle(coords, el.x, el.y, el.radius);
                                    case 'line':
                                    case 'arrow':
                                        return pointToLineDistance(coords, el.x1, el.y1, el.x2, el.y2) <= 8;
                                    case 'text':
                                        const textWidth = el.width || 100;
                                        const textHeight = el.height || 20;
                                        return pointInRect(coords, { x: el.x, y: el.y, width: textWidth, height: textHeight });
                                    case 'callout':
                                        return pointInRect(coords, { x: el.x, y: el.y, width: el.width, height: el.height });
                                    case 'dimension':
                                        return pointToLineDistance(coords, el.x1, el.y1, el.x2, el.y2) <= 15;
                                    case 'polygon':
                                        // Check if point is inside polygon using ray casting
                                        if (!el.points || el.points.length < 3) return false;
                                        let inside = false;
                                        for (let i = 0, j = el.points.length - 1; i < el.points.length; j = i++) {
                                            const xi = el.points[i].x, yi = el.points[i].y;
                                            const xj = el.points[j].x, yj = el.points[j].y;
                                            if (((yi > coords.y) !== (yj > coords.y)) && (coords.x < (xj - xi) * (coords.y - yi) / (yj - yi) + xi)) {
                                                inside = !inside;
                                            }
                                        }
                                        return inside;
                                    case 'arc':
                                        // Check if near the arc curve
                                        return pointToLineDistance(coords, el.x1, el.y1, el.x2, el.y2) <= 15;
                                    case 'area':
                                        // Use same polygon hit test
                                        if (!el.points || el.points.length < 3) return false;
                                        let insideArea = false;
                                        for (let i = 0, j = el.points.length - 1; i < el.points.length; j = i++) {
                                            const xi = el.points[i].x, yi = el.points[i].y;
                                            const xj = el.points[j].x, yj = el.points[j].y;
                                            if (((yi > coords.y) !== (yj > coords.y)) && (coords.x < (xj - xi) * (coords.y - yi) / (yj - yi) + xi)) {
                                                insideArea = !insideArea;
                                            }
                                        }
                                        return insideArea;
                                    case 'polyline':
                                    case 'freehand':
                                        if (!el.points || el.points.length < 2) return false;
                                        for (let i = 0; i < el.points.length - 1; i++) {
                                            if (pointToLineDistance(coords, el.points[i].x, el.points[i].y, el.points[i+1].x, el.points[i+1].y) <= 8) {
                                                return true;
                                            }
                                        }
                                        return false;
                                    default:
                                        return false;
                                }
                            });

                            // Determine what was clicked and its type
                            let clickedItem = null;
                            let clickedItemType = null;
                            if (clickedInfoPoint) { clickedItem = clickedInfoPoint; clickedItemType = 'infoPoint'; }
                            else if (clickedSymbol) { clickedItem = clickedSymbol; clickedItemType = 'symbol'; }
                            else if (clickedMeasurement) { clickedItem = clickedMeasurement; clickedItemType = 'measurement'; }
                            else if (clickedBezier) { clickedItem = clickedBezier; clickedItemType = 'bezier'; }
                            else if (clickedCloud) { clickedItem = clickedCloud; clickedItemType = 'cloud'; }
                            else if (clickedLeader) { clickedItem = clickedLeader; clickedItemType = 'leader'; }
                            else if (clickedElement) { clickedItem = clickedElement; clickedItemType = 'element'; }
                            else if (clickedImageOverlay) { clickedItem = clickedImageOverlay; clickedItemType = 'imageOverlay'; }
                            else if (clickedSnippet) { clickedItem = clickedSnippet; clickedItemType = 'snippet'; }
                            else if (clickedMask) { clickedItem = clickedMask; clickedItemType = 'mask'; }

                            if (clickedItem) {
                                // Ctrl+click or Shift+click for multi-select
                                if (e.ctrlKey || e.shiftKey) {
                                    const existingIndex = selectedIds.findIndex(s => s.id === clickedItem.id && s.type === clickedItemType);
                                    if (existingIndex >= 0) {
                                        // Remove from selection
                                        setSelectedIds(prev => prev.filter((_, i) => i !== existingIndex));
                                    } else {
                                        // Add to selection
                                        setSelectedIds(prev => [...prev, { id: clickedItem.id, type: clickedItemType }]);
                                    }
                                    // Also update single selection for properties panel
                                    setSelectedId(clickedItem.id);
                                    setSelectedType(clickedItemType);
                                } else {
                                    // Single click - clear multi-selection and select only this item
                                    setSelectedIds([{ id: clickedItem.id, type: clickedItemType }]);
                                    setSelectedId(clickedItem.id);
                                    setSelectedType(clickedItemType);
                                    // Only allow dragging if item is not locked
                                    if (!clickedItem.locked) {
                                        setIsDragging(true);
                                        // Calculate drag start based on item type
                                        if (clickedItemType === 'measurement' ||
                                            (clickedItemType === 'element' && (clickedItem.type === 'line' || clickedItem.type === 'arrow'))) {
                                            const midX = (clickedItem.x1 + clickedItem.x2) / 2;
                                            const midY = (clickedItem.y1 + clickedItem.y2) / 2;
                                            setDragStart({ x: coords.x - midX, y: coords.y - midY });
                                        } else {
                                            setDragStart({ x: coords.x - clickedItem.x, y: coords.y - clickedItem.y });
                                        }
                                    }
                                }
                            } else {
                                // Clicked on empty space - start box selection
                                if (!e.ctrlKey) {
                                    setSelectedId(null);
                                    setSelectedType(null);
                                    setSelectedIds([]);
                                }
                                // Start box selection
                                setSelectionBox({ x1: coords.x, y1: coords.y, x2: coords.x, y2: coords.y });
                            }
                            break;

                        case OPERATIONS.INFO_POINT:
                            // Single click to place info point
                            // Calculate the next point number (find max existing number + 1)
                            const maxNumber = infoPoints.reduce((max, p) => Math.max(max, p.number || 0), 0);
                            const newInfoPoint = {
                                id: generateId(),
                                type: 'info_point',
                                name: `Info ${maxNumber + 1}`,
                                number: maxNumber + 1,
                                x: coords.x,
                                y: coords.y,
                                label: '',
                                description: '',
                                metadata: {},
                                category: 'general',
                                priority: 'medium',
                                tags: [],
                                color: INFO_CATEGORIES.general.color,
                                radius: 12,
                                markerStyle: 'number',
                                visible: true,
                                locked: false
                            };
                            setInfoPoints(prev => [...prev, newInfoPoint]);
                            setSelectedId(newInfoPoint.id);
                            setSelectedType('infoPoint');
                            history.push({ snippets, masks, elements, infoPoints: [...infoPoints, newInfoPoint], symbols, measurements, cableAnnotations });
                            break;

                        case OPERATIONS.COMMENT:
                            // Open comment dialog at clicked position
                            setCommentDialogPosition({ x: coords.x, y: coords.y });
                            setShowCommentDialog(true);
                            setNewCommentText('');
                            break;

                        case OPERATIONS.POLYLINE:
                            // Add point to polyline
                            setPolylinePoints(prev => [...prev, coords]);
                            break;

                        case OPERATIONS.FREEHAND:
                            // Start freehand drawing
                            setIsDrawingFreehand(true);
                            setFreehandPath([coords]);
                            break;

                        case OPERATIONS.POLYGON:
                            // Add point to polygon
                            setPolygonPoints(prev => [...prev, coords]);
                            break;

                        case OPERATIONS.ARC:
                            // Add point for arc (need 3 points: start, control, end)
                            if (arcPoints.length < 3) {
                                setArcPoints(prev => [...prev, coords]);
                                if (arcPoints.length === 2) {
                                    // Third point completes the arc
                                    const newArc = {
                                        id: generateId(),
                                        type: 'arc',
                                        name: `Arc ${elements.filter(e => e.type === 'arc').length + 1}`,
                                        x1: arcPoints[0].x, y1: arcPoints[0].y,
                                        cx: arcPoints[1].x, cy: arcPoints[1].y,
                                        x2: coords.x, y2: coords.y,
                                        stroke: styles.stroke,
                                        strokeWidth: styles.strokeWidth,
                                        visible: true,
                                        locked: false
                                    };
                                    setElements(prev => [...prev, newArc]);
                                    setSelectedId(newArc.id);
                                    setSelectedType('element');
                                    history.push({ snippets, masks, elements: [...elements, newArc], infoPoints, symbols, measurements, cableAnnotations });
                                    setArcPoints([]);
                                }
                            }
                            break;

                        case OPERATIONS.AREA:
                            // Add point for area measurement
                            setAreaPoints(prev => [...prev, coords]);
                            break;

                        case OPERATIONS.BEZIER:
                            // Bezier curve: need 4 points for cubic (start, control1, control2, end)
                            if (bezierPoints.length < 4) {
                                const newPoints = [...bezierPoints, coords];
                                setBezierPoints(newPoints);
                                if (newPoints.length === 4) {
                                    // Create the bezier curve
                                    const newBezier = {
                                        id: generateId(),
                                        type: 'bezier',
                                        name: `Bezier ${bezierCurves.length + 1}`,
                                        points: newPoints,
                                        stroke: styles.stroke,
                                        strokeWidth: styles.strokeWidth,
                                        fill: 'none',
                                        rotation: 0,
                                        visible: true,
                                        locked: false
                                    };
                                    setBezierCurves(prev => [...prev, newBezier]);
                                    setSelectedId(newBezier.id);
                                    setSelectedType('bezier');
                                    setBezierPoints([]);
                                    addToHistory();
                                }
                            }
                            break;

                        case OPERATIONS.CLOUD:
                            // Cloud annotation: add points for cloud boundary
                            setCloudPoints(prev => [...prev, coords]);
                            break;

                        case OPERATIONS.LEADER:
                            // Leader line: need 3 points (anchor, elbow, endpoint)
                            if (leaderPoints.length < 3) {
                                const newPoints = [...leaderPoints, coords];
                                setLeaderPoints(newPoints);
                                if (newPoints.length === 3) {
                                    // Create the leader line with text input
                                    setLeaderText('Label');
                                    const newLeader = {
                                        id: generateId(),
                                        type: 'leader',
                                        name: `Leader ${leaderLines.length + 1}`,
                                        points: newPoints,
                                        text: 'Label',
                                        stroke: styles.stroke,
                                        strokeWidth: styles.strokeWidth,
                                        fontSize: styles.fontSize || 12,
                                        arrowSize: 8,
                                        rotation: 0,
                                        visible: true,
                                        locked: false
                                    };
                                    setLeaderLines(prev => [...prev, newLeader]);
                                    setSelectedId(newLeader.id);
                                    setSelectedType('leader');
                                    setLeaderPoints([]);
                                    addToHistory();
                                }
                            }
                            break;

                        case OPERATIONS.CALLOUT:
                            // Callout box: create a speech bubble annotation
                            const newCallout = {
                                id: generateId(),
                                type: 'callout',
                                name: `Callout ${elements.filter(e => e.type === 'callout').length + 1}`,
                                x: coords.x,
                                y: coords.y,
                                width: 150,
                                height: 60,
                                content: 'Double-click to edit',
                                fontSize: styles.fontSize || 12,
                                color: styles.stroke || '#000000',
                                backgroundColor: styles.fill === 'none' ? '#fffde7' : styles.fill,
                                borderColor: styles.stroke || '#fbc02d',
                                pointerDirection: 'bottom', // top, bottom, left, right
                                pointerPosition: 50, // percent along edge
                                pointerLength: 20,
                                rotation: 0,
                                visible: true,
                                locked: false
                            };
                            setElements(prev => [...prev, newCallout]);
                            setSelectedId(newCallout.id);
                            setSelectedType('element');
                            history.push({ snippets, masks, elements: [...elements, newCallout], infoPoints, symbols, measurements, cableAnnotations });
                            break;

                        case OPERATIONS.CALIBRATE:
                            // Calibration: click two points, then enter known distance
                            if (calibrationStep === 0) {
                                setCalibrationPoints([coords]);
                                setCalibrationStep(1);
                            } else if (calibrationStep === 1) {
                                setCalibrationPoints(prev => [...prev, coords]);
                                setCalibrationStep(2);
                                // Show dialog to enter known distance
                                setShowCalibrationDialog(true);
                            }
                            break;

                        case OPERATIONS.MEASURE:
                            // Measurement: draw lines between two points
                            setIsDrawing(true);
                            setDrawStart(coords);
                            setDrawEnd(coords);
                            break;

                        case OPERATIONS.DIMENSION:
                            // Dimension line: draw with extension lines and measurement text
                            setIsDrawing(true);
                            setDrawStart(coords);
                            setDrawEnd(coords);
                            break;

                        case OPERATIONS.SYMBOL:
                            // Symbol placement: place selected symbol at click location
                            if (selectedSymbolId && HV_SYMBOLS[selectedSymbolId]) {
                                const symbolDef = HV_SYMBOLS[selectedSymbolId];
                                const newSymbol = {
                                    id: generateId(),
                                    type: 'symbol',
                                    symbolId: selectedSymbolId,
                                    name: symbolDef.name,
                                    x: coords.x - symbolDef.width / 2,
                                    y: coords.y - symbolDef.height / 2,
                                    width: symbolDef.width,
                                    height: symbolDef.height,
                                    rotation: 0,
                                    scale: 1.0,
                                    specs: {},
                                    visible: true,
                                    locked: false
                                };
                                setSymbols(prev => [...prev, newSymbol]);
                                setSelectedId(newSymbol.id);
                                setSelectedType('symbol');
                                history.push({ snippets, masks, elements, infoPoints, symbols: [...symbols, newSymbol], measurements, cableAnnotations });
                            }
                            break;

                        case OPERATIONS.TEXT:
                            // Text annotation: place text at click location
                            const newText = {
                                id: generateId(),
                                type: 'text',
                                name: `Text ${elements.filter(e => e.type === 'text').length + 1}`,
                                x: coords.x,
                                y: coords.y,
                                content: 'Double-click to edit',
                                fontSize: styles.fontSize || 14,
                                fontFamily: styles.fontFamily || 'Arial',
                                color: styles.stroke || '#000000',
                                backgroundColor: 'transparent',
                                padding: 4,
                                width: 150,
                                height: 24,
                                rotation: 0,
                                visible: true,
                                locked: false
                            };
                            setElements(prev => [...prev, newText]);
                            setSelectedId(newText.id);
                            setSelectedType('element');
                            setSelectedIds([{ id: newText.id, type: 'element' }]);
                            history.push({ snippets, masks, elements: [...elements, newText], infoPoints, symbols, measurements, cableAnnotations });
                            break;

                        case OPERATIONS.SNIPPET:
                        case OPERATIONS.MASK:
                        case OPERATIONS.RECTANGLE:
                        case OPERATIONS.LINE:
                        case OPERATIONS.CIRCLE:
                        case OPERATIONS.ARROW:
                            setIsDrawing(true);
                            setDrawStart(coords);
                            setDrawEnd(coords);
                            break;
                    }
                }
            }, [currentTool, screenToCanvas, panOffset, snippets, masks, infoPoints, elements, symbols, measurements, cableAnnotations, styles, history, calibrationStep, selectedSymbolId]);
            
            const handleMouseMove = useCallback((e) => {
                const coords = screenToCanvas(e.clientX, e.clientY);

                if (isPanning) {
                    setPanOffset({
                        x: e.clientX - panStart.x,
                        y: e.clientY - panStart.y
                    });
                    return;
                }

                if (isDragging && selectedId) {
                    // Apply snap to grid if enabled
                    const applySnap = (val) => snapEnabled ? snapToGrid(val, snapGridSize) : val;

                    // Collect all elements for smart guide calculation
                    const allItems = smartGuidesEnabled ? [
                        ...snippets.map(s => ({ ...s, _type: 'snippet' })),
                        ...masks.map(m => ({ ...m, _type: 'mask' })),
                        ...symbols.map(s => ({ ...s, _type: 'symbol' })),
                        ...elements.filter(el => el.type !== 'line' && el.type !== 'arrow' && el.type !== 'polyline' && el.type !== 'freehand').map(el => ({ ...el, _type: 'element' })),
                        ...imageOverlays.map(io => ({ ...io, _type: 'imageOverlay' }))
                    ] : [];

                    const updatePositionWithGuides = (items, setItems, itemType) => {
                        const currentItem = items.find(item => item.id === selectedId);
                        if (!currentItem) return;

                        let newX = applySnap(coords.x - dragStart.x);
                        let newY = applySnap(coords.y - dragStart.y);

                        // Calculate smart guides if enabled
                        if (smartGuidesEnabled && currentItem.width !== undefined) {
                            const draggedBounds = {
                                x: coords.x - dragStart.x,
                                y: coords.y - dragStart.y,
                                width: currentItem.width,
                                height: currentItem.height
                            };
                            const { guides, snapAdjustments } = calculateAlignmentGuides(draggedBounds, allItems, selectedId);
                            setAlignmentGuides(guides);
                            newX += snapAdjustments.x;
                            newY += snapAdjustments.y;
                        }

                        setItems(items.map(item =>
                            item.id === selectedId ? { ...item, x: newX, y: newY } : item
                        ));
                    };

                    if (selectedType === 'snippet') updatePositionWithGuides(snippets, setSnippets, 'snippet');
                    else if (selectedType === 'mask') updatePositionWithGuides(masks, setMasks, 'mask');
                    else if (selectedType === 'infoPoint') updatePositionWithGuides(infoPoints, setInfoPoints, 'infoPoint');
                    else if (selectedType === 'symbol') updatePositionWithGuides(symbols, setSymbols, 'symbol');
                    else if (selectedType === 'imageOverlay') updatePositionWithGuides(imageOverlays, setImageOverlays, 'imageOverlay');
                    else if (selectedType === 'measurement') {
                        setMeasurements(measurements.map(m => {
                            if (m.id !== selectedId) return m;
                            const midX = (m.x1 + m.x2) / 2;
                            const midY = (m.y1 + m.y2) / 2;
                            let newMidX = coords.x - dragStart.x;
                            let newMidY = coords.y - dragStart.y;
                            if (snapEnabled) {
                                newMidX = snapToGrid(newMidX, snapGridSize);
                                newMidY = snapToGrid(newMidY, snapGridSize);
                            }
                            const dx = newMidX - midX;
                            const dy = newMidY - midY;
                            return {
                                ...m,
                                x1: m.x1 + dx,
                                y1: m.y1 + dy,
                                x2: m.x2 + dx,
                                y2: m.y2 + dy
                            };
                        }));
                        setAlignmentGuides([]);
                    } else if (selectedType === 'element') {
                        const currentEl = elements.find(el => el.id === selectedId);
                        if (currentEl) {
                            if (currentEl.type === 'line' || currentEl.type === 'arrow') {
                                // Lines/arrows don't use smart guides
                                const midX = (currentEl.x1 + currentEl.x2) / 2;
                                const midY = (currentEl.y1 + currentEl.y2) / 2;
                                let newMidX = coords.x - dragStart.x;
                                let newMidY = coords.y - dragStart.y;
                                if (snapEnabled) {
                                    newMidX = snapToGrid(newMidX, snapGridSize);
                                    newMidY = snapToGrid(newMidY, snapGridSize);
                                }
                                const dx = newMidX - midX;
                                const dy = newMidY - midY;
                                setElements(elements.map(el =>
                                    el.id !== selectedId ? el : {
                                        ...el,
                                        x1: el.x1 + dx,
                                        y1: el.y1 + dy,
                                        x2: el.x2 + dx,
                                        y2: el.y2 + dy
                                    }
                                ));
                                setAlignmentGuides([]);
                            } else if (currentEl.type === 'rectangle' || currentEl.type === 'circle') {
                                let newX = applySnap(coords.x - dragStart.x);
                                let newY = applySnap(coords.y - dragStart.y);

                                if (smartGuidesEnabled) {
                                    const draggedBounds = {
                                        x: coords.x - dragStart.x,
                                        y: coords.y - dragStart.y,
                                        width: currentEl.width,
                                        height: currentEl.height
                                    };
                                    const { guides, snapAdjustments } = calculateAlignmentGuides(draggedBounds, allItems, selectedId);
                                    setAlignmentGuides(guides);
                                    newX += snapAdjustments.x;
                                    newY += snapAdjustments.y;
                                }

                                setElements(elements.map(el =>
                                    el.id !== selectedId ? el : { ...el, x: newX, y: newY }
                                ));
                            } else {
                                // Polyline, freehand, text - simple position update
                                setElements(elements.map(el =>
                                    el.id !== selectedId ? el : { ...el, x: applySnap(coords.x - dragStart.x), y: applySnap(coords.y - dragStart.y) }
                                ));
                                setAlignmentGuides([]);
                            }
                        }
                    }
                    return;
                }

                if (isDrawing) {
                    setDrawEnd(coords);
                }

                // Freehand drawing - add points as mouse moves
                if (isDrawingFreehand && currentTool === OPERATIONS.FREEHAND) {
                    setFreehandPath(prev => [...prev, coords]);
                }

                // Update box selection
                if (selectionBox) {
                    setSelectionBox(prev => ({ ...prev, x2: coords.x, y2: coords.y }));
                }
            }, [isPanning, panStart, isDragging, selectedId, selectedType, dragStart, isDrawing, screenToCanvas, snippets, masks, infoPoints, elements, symbols, measurements, selectionBox, snapEnabled, snapGridSize, smartGuidesEnabled, imageOverlays]);
            
            const handleMouseUp = useCallback((e) => {
                const coords = screenToCanvas(e.clientX, e.clientY);
                
                if (isPanning) {
                    setIsPanning(false);
                    return;
                }
                
                if (isDragging) {
                    setIsDragging(false);
                    setAlignmentGuides([]); // Clear alignment guides
                    // Save to history
                    history.push({ snippets: [...snippets], masks: [...masks], elements: [...elements], infoPoints: [...infoPoints], symbols: [...symbols], measurements: [...measurements], cableAnnotations: [...cableAnnotations] });
                    return;
                }

                // Complete box selection
                if (selectionBox) {
                    const boxX1 = Math.min(selectionBox.x1, selectionBox.x2);
                    const boxY1 = Math.min(selectionBox.y1, selectionBox.y2);
                    const boxX2 = Math.max(selectionBox.x1, selectionBox.x2);
                    const boxY2 = Math.max(selectionBox.y1, selectionBox.y2);
                    const boxWidth = boxX2 - boxX1;
                    const boxHeight = boxY2 - boxY1;

                    // Only select if box is larger than 5px
                    if (boxWidth > 5 || boxHeight > 5) {
                        const newSelection = [];

                        // Check snippets
                        snippets.filter(s => s.visible !== false).forEach(s => {
                            if (s.x >= boxX1 && s.x + s.width <= boxX2 && s.y >= boxY1 && s.y + s.height <= boxY2) {
                                newSelection.push({ id: s.id, type: 'snippet' });
                            }
                        });

                        // Check masks
                        masks.filter(m => m.visible !== false).forEach(m => {
                            if (m.x >= boxX1 && m.x + m.width <= boxX2 && m.y >= boxY1 && m.y + m.height <= boxY2) {
                                newSelection.push({ id: m.id, type: 'mask' });
                            }
                        });

                        // Check elements
                        elements.filter(el => el.visible !== false).forEach(el => {
                            if (el.type === 'rectangle' || el.type === 'text') {
                                if (el.x >= boxX1 && el.x + (el.width || 100) <= boxX2 && el.y >= boxY1 && el.y + (el.height || 20) <= boxY2) {
                                    newSelection.push({ id: el.id, type: 'element' });
                                }
                            } else if (el.type === 'circle') {
                                if (el.x - el.radius >= boxX1 && el.x + el.radius <= boxX2 && el.y - el.radius >= boxY1 && el.y + el.radius <= boxY2) {
                                    newSelection.push({ id: el.id, type: 'element' });
                                }
                            } else if (el.type === 'line' || el.type === 'arrow') {
                                if (el.x1 >= boxX1 && el.x1 <= boxX2 && el.y1 >= boxY1 && el.y1 <= boxY2 &&
                                    el.x2 >= boxX1 && el.x2 <= boxX2 && el.y2 >= boxY1 && el.y2 <= boxY2) {
                                    newSelection.push({ id: el.id, type: 'element' });
                                }
                            }
                        });

                        // Check info points
                        infoPoints.filter(p => p.visible !== false).forEach(p => {
                            if (p.x >= boxX1 && p.x <= boxX2 && p.y >= boxY1 && p.y <= boxY2) {
                                newSelection.push({ id: p.id, type: 'infoPoint' });
                            }
                        });

                        // Check symbols
                        symbols.filter(s => s.visible !== false).forEach(s => {
                            const w = s.width * (s.scale || 1);
                            const h = s.height * (s.scale || 1);
                            if (s.x >= boxX1 && s.x + w <= boxX2 && s.y >= boxY1 && s.y + h <= boxY2) {
                                newSelection.push({ id: s.id, type: 'symbol' });
                            }
                        });

                        // Check measurements
                        measurements.filter(m => m.visible !== false).forEach(m => {
                            if (m.x1 >= boxX1 && m.x1 <= boxX2 && m.y1 >= boxY1 && m.y1 <= boxY2 &&
                                m.x2 >= boxX1 && m.x2 <= boxX2 && m.y2 >= boxY1 && m.y2 <= boxY2) {
                                newSelection.push({ id: m.id, type: 'measurement' });
                            }
                        });

                        if (newSelection.length > 0) {
                            setSelectedIds(e.ctrlKey ? [...selectedIds, ...newSelection] : newSelection);
                            // Set first item as primary selection for properties panel
                            setSelectedId(newSelection[0].id);
                            setSelectedType(newSelection[0].type);
                        }
                    }
                    setSelectionBox(null);
                    return;
                }

                // Complete freehand drawing
                if (isDrawingFreehand && freehandPath.length > 1) {
                    const newFreehand = {
                        id: generateId(),
                        type: 'freehand',
                        name: `Freehand ${elements.length + 1}`,
                        points: [...freehandPath],
                        stroke: styles.stroke,
                        strokeWidth: styles.strokeWidth,
                        visible: true,
                        locked: false
                    };
                    setElements(prev => [...prev, newFreehand]);
                    setSelectedId(newFreehand.id);
                    setSelectedType('element');
                    history.push({ snippets, masks, elements: [...elements, newFreehand], infoPoints, symbols, measurements, cableAnnotations });
                    setIsDrawingFreehand(false);
                    setFreehandPath([]);
                    return;
                }

                if (isDrawing && drawStart) {
                    const x = Math.min(drawStart.x, coords.x);
                    const y = Math.min(drawStart.y, coords.y);
                    const width = Math.abs(coords.x - drawStart.x);
                    const height = Math.abs(coords.y - drawStart.y);
                    
                    // Minimum size check
                    if (width >= 10 || height >= 10) {
                        switch (currentTool) {
                            case OPERATIONS.SNIPPET:
                                if (currentPageData) {
                                    // Capture the image region from PDF
                                    captureRegion(currentPageData.imageData, x, y, width, height).then(imageData => {
                                        // Create snippet from PDF region with captured image
                                        const newSnippet = {
                                            id: generateId(),
                                            type: 'snippet',
                                            name: `Snippet ${snippets.length + 1}`,
                                            x: x,
                                            y: y,
                                            width: width,
                                            height: height,
                                            sourceX: x,
                                            sourceY: y,
                                            sourceWidth: width,
                                            sourceHeight: height,
                                            imageData: imageData,
                                            visible: true,
                                            locked: false,
                                            hideBorder: false
                                        };
                                        setSnippets(prev => [...prev, newSnippet]);

                                        // Create mask at source location to cover original
                                        const newMask = {
                                            id: generateId(),
                                            type: 'mask',
                                            name: `Auto-mask ${masks.length + 1}`,
                                            x: x,
                                            y: y,
                                            width: width,
                                            height: height,
                                            fill: '#ffffff',
                                            visible: true,
                                            locked: false
                                        };
                                        setMasks(prev => [...prev, newMask]);

                                        history.push({
                                            snippets: [...snippets, newSnippet],
                                            masks: [...masks, newMask],
                                            elements,
                                            infoPoints,
                                            symbols,
                                            measurements,
                                            cableAnnotations
                                        });
                                    });
                                }
                                break;
                                
                            case OPERATIONS.MASK:
                                const newMask = {
                                    id: generateId(),
                                    type: 'mask',
                                    name: `Mask ${masks.length + 1}`,
                                    x: x,
                                    y: y,
                                    width: width,
                                    height: height,
                                    fill: '#ffffff',
                                    visible: true,
                                    locked: false
                                };
                                setMasks(prev => [...prev, newMask]);
                                history.push({ snippets, masks: [...masks, newMask], elements, infoPoints, symbols, measurements, cableAnnotations });
                                break;
                                
                            case OPERATIONS.RECTANGLE:
                                const newRect = {
                                    id: generateId(),
                                    type: 'rectangle',
                                    name: `Rectangle ${elements.length + 1}`,
                                    x: x,
                                    y: y,
                                    width: width,
                                    height: height,
                                    stroke: styles.stroke,
                                    strokeWidth: styles.strokeWidth,
                                    fill: styles.fill,
                                    rotation: 0,
                                    visible: true,
                                    locked: false
                                };
                                setElements(prev => [...prev, newRect]);
                                history.push({ snippets, masks, elements: [...elements, newRect], infoPoints, symbols, measurements, cableAnnotations });
                                break;

                            case OPERATIONS.CIRCLE:
                                const radius = Math.max(width, height) / 2;
                                const newCircle = {
                                    id: generateId(),
                                    type: 'circle',
                                    name: `Circle ${elements.length + 1}`,
                                    x: x + width / 2,
                                    y: y + height / 2,
                                    radius: radius,
                                    stroke: styles.stroke,
                                    strokeWidth: styles.strokeWidth,
                                    fill: styles.fill,
                                    rotation: 0,
                                    visible: true,
                                    locked: false
                                };
                                setElements(prev => [...prev, newCircle]);
                                history.push({ snippets, masks, elements: [...elements, newCircle], infoPoints, symbols, measurements, cableAnnotations });
                                break;
                                
                            case OPERATIONS.LINE:
                                const newLine = {
                                    id: generateId(),
                                    type: 'line',
                                    name: `Line ${elements.length + 1}`,
                                    x1: drawStart.x,
                                    y1: drawStart.y,
                                    x2: coords.x,
                                    y2: coords.y,
                                    stroke: styles.stroke,
                                    strokeWidth: styles.strokeWidth,
                                    visible: true,
                                    locked: false
                                };
                                setElements(prev => [...prev, newLine]);
                                history.push({ snippets, masks, elements: [...elements, newLine], infoPoints, symbols, measurements, cableAnnotations });
                                break;

                            case OPERATIONS.ARROW:
                                const newArrow = {
                                    id: generateId(),
                                    type: 'arrow',
                                    name: `Arrow ${elements.length + 1}`,
                                    x1: drawStart.x,
                                    y1: drawStart.y,
                                    x2: coords.x,
                                    y2: coords.y,
                                    stroke: styles.stroke,
                                    strokeWidth: styles.strokeWidth,
                                    arrowStart: false,  // arrow at start point
                                    arrowEnd: true,     // arrow at end point
                                    visible: true,
                                    locked: false
                                };
                                setElements(prev => [...prev, newArrow]);
                                history.push({ snippets, masks, elements: [...elements, newArrow], infoPoints, symbols, measurements, cableAnnotations });
                                break;

                            case OPERATIONS.MEASURE:
                                // Calculate distance in pixels
                                const pixelDist = distance(drawStart, coords);
                                // Calculate real-world distance if calibrated
                                const realDistance = scaleCalibration.isCalibrated
                                    ? pixelDist / scaleCalibration.pixelsPerMeter
                                    : null;
                                const newMeasurement = {
                                    id: generateId(),
                                    type: 'measurement',
                                    name: `Measurement ${measurements.length + 1}`,
                                    x1: drawStart.x,
                                    y1: drawStart.y,
                                    x2: coords.x,
                                    y2: coords.y,
                                    pixelDistance: pixelDist,
                                    realDistance: realDistance,
                                    unit: scaleCalibration.unit,
                                    visible: true,
                                    locked: false
                                };
                                setMeasurements(prev => [...prev, newMeasurement]);
                                setSelectedId(newMeasurement.id);
                                setSelectedType('measurement');
                                history.push({ snippets, masks, elements, infoPoints, symbols, measurements: [...measurements, newMeasurement], cableAnnotations });
                                break;

                            case OPERATIONS.DIMENSION:
                                // Create dimension line element
                                const dimPixelDist = distance(drawStart, coords);
                                const dimRealDistance = scaleCalibration.isCalibrated
                                    ? dimPixelDist / scaleCalibration.pixelsPerMeter
                                    : null;
                                const newDimension = {
                                    id: generateId(),
                                    type: 'dimension',
                                    name: `Dimension ${elements.filter(e => e.type === 'dimension').length + 1}`,
                                    x1: drawStart.x,
                                    y1: drawStart.y,
                                    x2: coords.x,
                                    y2: coords.y,
                                    pixelDistance: dimPixelDist,
                                    realDistance: dimRealDistance,
                                    unit: scaleCalibration.unit || 'px',
                                    extensionLength: 15,
                                    textOffset: 10,
                                    fontSize: 12,
                                    color: styles.stroke || '#000000',
                                    visible: true,
                                    locked: false
                                };
                                setElements(prev => [...prev, newDimension]);
                                setSelectedId(newDimension.id);
                                setSelectedType('element');
                                history.push({ snippets, masks, elements: [...elements, newDimension], infoPoints, symbols, measurements, cableAnnotations });
                                break;
                        }
                    }
                    
                    setIsDrawing(false);
                    setDrawStart(null);
                    setDrawEnd(null);
                }
            }, [isPanning, isDragging, isDrawing, drawStart, currentTool, currentPageData, snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations, styles, screenToCanvas, history, scaleCalibration]);

            // ============================================
            // CONTEXT MENU
            // ============================================

            const handleContextMenu = useCallback((e) => {
                e.preventDefault();
                const coords = screenToCanvas(e.clientX, e.clientY);

                // Close any existing context menu
                setContextMenu(null);

                // Check if right-clicking on a selected element
                if (selectedId && selectedType) {
                    // Show element context menu
                    setContextMenu({
                        x: e.clientX,
                        y: e.clientY,
                        type: 'element',
                        elementId: selectedId,
                        elementType: selectedType
                    });
                } else {
                    // Check if right-clicking on any element
                    // Try to find element under cursor
                    let foundElement = null;
                    let foundType = null;

                    // Check snippets
                    for (const s of snippets.filter(s => s.page === currentPage && s.visible !== false)) {
                        if (coords.x >= s.x && coords.x <= s.x + s.width && coords.y >= s.y && coords.y <= s.y + s.height) {
                            foundElement = s;
                            foundType = 'snippet';
                            break;
                        }
                    }

                    // Check elements
                    if (!foundElement) {
                        for (const el of elements.filter(el => el.page === currentPage && el.visible !== false)) {
                            if (el.type === 'rectangle' && coords.x >= el.x && coords.x <= el.x + el.width && coords.y >= el.y && coords.y <= el.y + el.height) {
                                foundElement = el;
                                foundType = 'element';
                                break;
                            }
                        }
                    }

                    // Check symbols
                    if (!foundElement) {
                        for (const sym of symbols.filter(s => s.page === currentPage && s.visible !== false)) {
                            const symSize = sym.size || 40;
                            if (coords.x >= sym.x && coords.x <= sym.x + symSize && coords.y >= sym.y && coords.y <= sym.y + symSize) {
                                foundElement = sym;
                                foundType = 'symbol';
                                break;
                            }
                        }
                    }

                    // Check info points
                    if (!foundElement) {
                        for (const ip of infoPoints.filter(p => p.page === currentPage && p.visible !== false)) {
                            const dx = coords.x - ip.x;
                            const dy = coords.y - ip.y;
                            if (Math.sqrt(dx * dx + dy * dy) <= 15) {
                                foundElement = ip;
                                foundType = 'infoPoint';
                                break;
                            }
                        }
                    }

                    if (foundElement) {
                        // Select the element and show context menu
                        setSelectedId(foundElement.id);
                        setSelectedType(foundType);
                        setContextMenu({
                            x: e.clientX,
                            y: e.clientY,
                            type: 'element',
                            elementId: foundElement.id,
                            elementType: foundType
                        });
                    } else {
                        // Show canvas context menu
                        setContextMenu({
                            x: e.clientX,
                            y: e.clientY,
                            type: 'canvas'
                        });
                    }
                }
            }, [screenToCanvas, selectedId, selectedType, snippets, elements, symbols, infoPoints, currentPage]);

            // Close context menu when clicking elsewhere
            useEffect(() => {
                const handleClickOutside = () => {
                    if (contextMenu) {
                        setContextMenu(null);
                    }
                };
                window.addEventListener('click', handleClickOutside);
                return () => window.removeEventListener('click', handleClickOutside);
            }, [contextMenu]);

            // ============================================
            // KEYBOARD SHORTCUTS
            // ============================================
            
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Tool shortcuts
                    if (!e.ctrlKey && !e.metaKey) {
                        switch (e.key.toLowerCase()) {
                            case 'v': setCurrentTool(OPERATIONS.SELECT); break;
                            case 's':
                                if (!e.ctrlKey) setCurrentTool(OPERATIONS.SNIPPET);
                                break;
                            case 'm': setCurrentTool(OPERATIONS.MASK); break;
                            case 'r':
                                // If element is selected, rotate by 90°, otherwise switch to rectangle tool
                                if (selectedId && selectedType) {
                                    const rotateElement = (item) => ({
                                        ...item,
                                        rotation: ((item.rotation || 0) + 90) % 360
                                    });
                                    if (selectedType === 'element') {
                                        setElements(prev => prev.map(el =>
                                            el.id === selectedId ? rotateElement(el) : el
                                        ));
                                    } else if (selectedType === 'symbol') {
                                        setSymbols(prev => prev.map(s =>
                                            s.id === selectedId ? rotateElement(s) : s
                                        ));
                                    } else if (selectedType === 'snippet') {
                                        setSnippets(prev => prev.map(s =>
                                            s.id === selectedId ? rotateElement(s) : s
                                        ));
                                    } else if (selectedType === 'mask') {
                                        setMasks(prev => prev.map(m =>
                                            m.id === selectedId ? rotateElement(m) : m
                                        ));
                                    }
                                } else {
                                    setCurrentTool(OPERATIONS.RECTANGLE);
                                }
                                break;
                            case 'l': setCurrentTool(OPERATIONS.LINE); break;
                            case 'a':
                                if (e.shiftKey && !e.ctrlKey) {
                                    setCurrentTool(OPERATIONS.AREA);
                                } else if (!e.ctrlKey) {
                                    setCurrentTool(OPERATIONS.ARROW);
                                }
                                break;
                            case 'c':
                                if (!e.ctrlKey) setCurrentTool(OPERATIONS.CIRCLE);
                                break;
                            case 'i': setCurrentTool(OPERATIONS.INFO_POINT); break;
                            case 't': setCurrentTool(OPERATIONS.TEXT); break;
                            case 'b': setCurrentTool(OPERATIONS.CALLOUT); break;
                            case 'j': setCurrentTool(OPERATIONS.DIMENSION); break;
                            case 'o': setCurrentTool(OPERATIONS.POLYGON); break;
                            case 'u': setCurrentTool(OPERATIONS.ARC); break;
                            case 'h':
                                // Flip selected element(s)
                                if (selectedId && selectedType) {
                                    const flipDirection = e.shiftKey ? 'vertical' : 'horizontal';
                                    const flipElement = (el) => {
                                        if (el.type === 'line' || el.type === 'arrow' || el.type === 'dimension') {
                                            // For line-based elements, flip around center
                                            const midX = (el.x1 + el.x2) / 2;
                                            const midY = (el.y1 + el.y2) / 2;
                                            if (flipDirection === 'horizontal') {
                                                return { ...el, x1: 2 * midX - el.x1, x2: 2 * midX - el.x2 };
                                            } else {
                                                return { ...el, y1: 2 * midY - el.y1, y2: 2 * midY - el.y2 };
                                            }
                                        } else if (el.type === 'polygon' || el.type === 'polyline' || el.type === 'freehand') {
                                            // For point-based elements, flip all points
                                            const minX = Math.min(...el.points.map(p => p.x));
                                            const maxX = Math.max(...el.points.map(p => p.x));
                                            const minY = Math.min(...el.points.map(p => p.y));
                                            const maxY = Math.max(...el.points.map(p => p.y));
                                            const midX = (minX + maxX) / 2;
                                            const midY = (minY + maxY) / 2;
                                            return {
                                                ...el,
                                                points: el.points.map(p => flipDirection === 'horizontal'
                                                    ? { x: 2 * midX - p.x, y: p.y }
                                                    : { x: p.x, y: 2 * midY - p.y }
                                                )
                                            };
                                        } else if (el.type === 'arc') {
                                            const midX = (el.x1 + el.x2) / 2;
                                            const midY = (el.y1 + el.y2) / 2;
                                            if (flipDirection === 'horizontal') {
                                                return { ...el, x1: 2 * midX - el.x1, x2: 2 * midX - el.x2, cx: 2 * midX - el.cx };
                                            } else {
                                                return { ...el, y1: 2 * midY - el.y1, y2: 2 * midY - el.y2, cy: 2 * midY - el.cy };
                                            }
                                        } else {
                                            // For rectangle-based elements, just flip via scaleX/scaleY
                                            return {
                                                ...el,
                                                flipH: flipDirection === 'horizontal' ? !(el.flipH || false) : (el.flipH || false),
                                                flipV: flipDirection === 'vertical' ? !(el.flipV || false) : (el.flipV || false)
                                            };
                                        }
                                    };
                                    if (selectedType === 'element') {
                                        setElements(prev => prev.map(el => el.id === selectedId ? flipElement(el) : el));
                                    } else if (selectedType === 'snippet') {
                                        setSnippets(prev => prev.map(s => s.id === selectedId ? { ...s, flipH: flipDirection === 'horizontal' ? !(s.flipH || false) : (s.flipH || false), flipV: flipDirection === 'vertical' ? !(s.flipV || false) : (s.flipV || false) } : s));
                                    } else if (selectedType === 'symbol') {
                                        setSymbols(prev => prev.map(s => s.id === selectedId ? { ...s, flipH: flipDirection === 'horizontal' ? !(s.flipH || false) : (s.flipH || false), flipV: flipDirection === 'vertical' ? !(s.flipV || false) : (s.flipV || false) } : s));
                                    }
                                    history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
                                }
                                break;
                            case 'd': setCurrentTool(OPERATIONS.MEASURE); break;
                            case 'p': setCurrentTool(OPERATIONS.SYMBOL); break;
                            case 'k': setCurrentTool(OPERATIONS.COMMENT); break;
                            case 'y': setCurrentTool(OPERATIONS.POLYLINE); break;
                            case 'f': setCurrentTool(OPERATIONS.FREEHAND); break;
                            case 'b': setCurrentTool(OPERATIONS.BEZIER); break;
                            case 'g': setShowGrid(prev => !prev); break;
                            case ';': setSnapEnabled(prev => !prev); break;
                            case "'": setSmartGuidesEnabled(prev => !prev); break;
                            case '?': setShowShortcutsPanel(prev => !prev); break;
                            case 'n': setShowMinimap(prev => !prev); break;
                            case 'enter':
                                // Finish polyline if drawing
                                if (currentTool === OPERATIONS.POLYLINE && polylinePoints.length >= 2) {
                                    const newPolyline = {
                                        id: generateId(),
                                        type: 'polyline',
                                        name: `Polyline ${elements.length + 1}`,
                                        points: [...polylinePoints],
                                        stroke: styles.stroke,
                                        strokeWidth: styles.strokeWidth,
                                        visible: true,
                                        locked: false
                                    };
                                    setElements(prev => [...prev, newPolyline]);
                                    setSelectedId(newPolyline.id);
                                    setSelectedType('element');
                                    history.push({ snippets, masks, elements: [...elements, newPolyline], infoPoints, symbols, measurements, cableAnnotations });
                                    setPolylinePoints([]);
                                }
                                // Finish polygon if drawing (needs at least 3 points)
                                if (currentTool === OPERATIONS.POLYGON && polygonPoints.length >= 3) {
                                    const newPolygon = {
                                        id: generateId(),
                                        type: 'polygon',
                                        name: `Polygon ${elements.filter(e => e.type === 'polygon').length + 1}`,
                                        points: [...polygonPoints],
                                        stroke: styles.stroke,
                                        strokeWidth: styles.strokeWidth,
                                        fill: styles.fill,
                                        fillOpacity: 0.3,
                                        visible: true,
                                        locked: false
                                    };
                                    setElements(prev => [...prev, newPolygon]);
                                    setSelectedId(newPolygon.id);
                                    setSelectedType('element');
                                    history.push({ snippets, masks, elements: [...elements, newPolygon], infoPoints, symbols, measurements, cableAnnotations });
                                    setPolygonPoints([]);
                                }
                                // Finish area measurement (needs at least 3 points)
                                if (currentTool === OPERATIONS.AREA && areaPoints.length >= 3) {
                                    const pixelArea = calculatePolygonArea(areaPoints);
                                    const realArea = scaleCalibration.isCalibrated
                                        ? pixelArea / (scaleCalibration.pixelsPerMeter * scaleCalibration.pixelsPerMeter)
                                        : null;
                                    const newArea = {
                                        id: generateId(),
                                        type: 'area',
                                        name: `Area ${elements.filter(e => e.type === 'area').length + 1}`,
                                        points: [...areaPoints],
                                        pixelArea: pixelArea,
                                        realArea: realArea,
                                        unit: scaleCalibration.unit || 'px',
                                        stroke: styles.stroke || '#22c55e',
                                        strokeWidth: 2,
                                        fill: '#22c55e',
                                        fillOpacity: 0.15,
                                        fontSize: 14,
                                        visible: true,
                                        locked: false
                                    };
                                    setElements(prev => [...prev, newArea]);
                                    setSelectedId(newArea.id);
                                    setSelectedType('element');
                                    history.push({ snippets, masks, elements: [...elements, newArea], infoPoints, symbols, measurements, cableAnnotations });
                                    setAreaPoints([]);
                                }
                                // Finish cloud annotation (needs at least 3 points)
                                if (currentTool === OPERATIONS.CLOUD && cloudPoints.length >= 3) {
                                    const newCloud = {
                                        id: generateId(),
                                        type: 'cloud',
                                        name: `Cloud ${cloudAnnotations.length + 1}`,
                                        points: [...cloudPoints],
                                        stroke: styles.stroke || '#ef4444',
                                        strokeWidth: styles.strokeWidth || 2,
                                        fill: 'rgba(255, 200, 200, 0.2)',
                                        rotation: 0,
                                        visible: true,
                                        locked: false
                                    };
                                    setCloudAnnotations(prev => [...prev, newCloud]);
                                    setSelectedId(newCloud.id);
                                    setSelectedType('cloud');
                                    setCloudPoints([]);
                                    addToHistory();
                                }
                                break;
                            case 'escape':
                                setSelectedId(null);
                                setSelectedType(null);
                                setIsDrawing(false);
                                setCalibrationStep(0);
                                setCalibrationPoints([]);
                                // Cancel polyline/freehand/polygon/arc/bezier/cloud/leader drawing
                                setPolylinePoints([]);
                                setPolygonPoints([]);
                                setArcPoints([]);
                                setAreaPoints([]);
                                setBezierPoints([]);
                                setCloudPoints([]);
                                setLeaderPoints([]);
                                setFreehandPath([]);
                                setIsDrawingFreehand(false);
                                break;
                            case 'delete':
                            case 'backspace':
                                // Multi-select delete (skip locked items)
                                if (selectedIds.length > 0) {
                                    // Filter out locked items
                                    const snippetIds = selectedIds.filter(s => s.type === 'snippet').map(s => s.id).filter(id => !snippets.find(s => s.id === id)?.locked);
                                    const maskIds = selectedIds.filter(s => s.type === 'mask').map(s => s.id).filter(id => !masks.find(m => m.id === id)?.locked);
                                    const elementIds = selectedIds.filter(s => s.type === 'element').map(s => s.id).filter(id => !elements.find(e => e.id === id)?.locked);
                                    const infoPointIds = selectedIds.filter(s => s.type === 'infoPoint').map(s => s.id).filter(id => !infoPoints.find(p => p.id === id)?.locked);
                                    const symbolIds = selectedIds.filter(s => s.type === 'symbol').map(s => s.id).filter(id => !symbols.find(s => s.id === id)?.locked);
                                    const measurementIds = selectedIds.filter(s => s.type === 'measurement').map(s => s.id).filter(id => !measurements.find(m => m.id === id)?.locked);
                                    const bezierIds = selectedIds.filter(s => s.type === 'bezier').map(s => s.id).filter(id => !bezierCurves.find(b => b.id === id)?.locked);
                                    const cloudIds = selectedIds.filter(s => s.type === 'cloud').map(s => s.id).filter(id => !cloudAnnotations.find(c => c.id === id)?.locked);
                                    const leaderIds = selectedIds.filter(s => s.type === 'leader').map(s => s.id).filter(id => !leaderLines.find(l => l.id === id)?.locked);

                                    if (snippetIds.length) setSnippets(prev => prev.filter(s => !snippetIds.includes(s.id)));
                                    if (maskIds.length) setMasks(prev => prev.filter(m => !maskIds.includes(m.id)));
                                    if (elementIds.length) setElements(prev => prev.filter(e => !elementIds.includes(e.id)));
                                    if (infoPointIds.length) setInfoPoints(prev => prev.filter(p => !infoPointIds.includes(p.id)));
                                    if (symbolIds.length) setSymbols(prev => prev.filter(s => !symbolIds.includes(s.id)));
                                    if (measurementIds.length) setMeasurements(prev => prev.filter(m => !measurementIds.includes(m.id)));
                                    if (bezierIds.length) setBezierCurves(prev => prev.filter(b => !bezierIds.includes(b.id)));
                                    if (cloudIds.length) setCloudAnnotations(prev => prev.filter(c => !cloudIds.includes(c.id)));
                                    if (leaderIds.length) setLeaderLines(prev => prev.filter(l => !leaderIds.includes(l.id)));

                                    setSelectedIds([]);
                                    setSelectedId(null);
                                    setSelectedType(null);
                                } else if (selectedId) {
                                    // Single selection delete (check if locked)
                                    let isLocked = false;
                                    if (selectedType === 'snippet') isLocked = snippets.find(s => s.id === selectedId)?.locked;
                                    else if (selectedType === 'mask') isLocked = masks.find(m => m.id === selectedId)?.locked;
                                    else if (selectedType === 'element') isLocked = elements.find(e => e.id === selectedId)?.locked;
                                    else if (selectedType === 'infoPoint') isLocked = infoPoints.find(p => p.id === selectedId)?.locked;
                                    else if (selectedType === 'symbol') isLocked = symbols.find(s => s.id === selectedId)?.locked;
                                    else if (selectedType === 'measurement') isLocked = measurements.find(m => m.id === selectedId)?.locked;
                                    else if (selectedType === 'bezier') isLocked = bezierCurves.find(b => b.id === selectedId)?.locked;
                                    else if (selectedType === 'cloud') isLocked = cloudAnnotations.find(c => c.id === selectedId)?.locked;
                                    else if (selectedType === 'leader') isLocked = leaderLines.find(l => l.id === selectedId)?.locked;

                                    if (!isLocked) {
                                        if (selectedType === 'snippet') {
                                            setSnippets(prev => prev.filter(s => s.id !== selectedId));
                                        } else if (selectedType === 'mask') {
                                            setMasks(prev => prev.filter(m => m.id !== selectedId));
                                        } else if (selectedType === 'element') {
                                            setElements(prev => prev.filter(e => e.id !== selectedId));
                                        } else if (selectedType === 'infoPoint') {
                                            setInfoPoints(prev => prev.filter(p => p.id !== selectedId));
                                        } else if (selectedType === 'symbol') {
                                            setSymbols(prev => prev.filter(s => s.id !== selectedId));
                                        } else if (selectedType === 'measurement') {
                                            setMeasurements(prev => prev.filter(m => m.id !== selectedId));
                                        } else if (selectedType === 'bezier') {
                                            setBezierCurves(prev => prev.filter(b => b.id !== selectedId));
                                        } else if (selectedType === 'cloud') {
                                            setCloudAnnotations(prev => prev.filter(c => c.id !== selectedId));
                                        } else if (selectedType === 'leader') {
                                            setLeaderLines(prev => prev.filter(l => l.id !== selectedId));
                                        }
                                        setSelectedId(null);
                                        setSelectedType(null);
                                    }
                                }
                                break;
                            case '0':
                                fitToView();
                                break;
                            case '1':
                                setZoom(1);
                                break;
                        }
                    }

                    // Arrow keys for fine-tuning position
                    if (selectedId && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                        const step = e.shiftKey ? 10 : 1; // Shift = 10px, normal = 1px
                        const dx = e.key === 'ArrowLeft' ? -step : e.key === 'ArrowRight' ? step : 0;
                        const dy = e.key === 'ArrowUp' ? -step : e.key === 'ArrowDown' ? step : 0;

                        if (selectedType === 'snippet') {
                            setSnippets(prev => prev.map(s =>
                                s.id === selectedId ? { ...s, x: s.x + dx, y: s.y + dy } : s
                            ));
                        } else if (selectedType === 'mask') {
                            setMasks(prev => prev.map(m =>
                                m.id === selectedId ? { ...m, x: m.x + dx, y: m.y + dy } : m
                            ));
                        } else if (selectedType === 'element') {
                            setElements(prev => prev.map(el => {
                                if (el.id !== selectedId) return el;
                                if (el.type === 'line' || el.type === 'arrow') {
                                    return { ...el, x1: el.x1 + dx, y1: el.y1 + dy, x2: el.x2 + dx, y2: el.y2 + dy };
                                }
                                return { ...el, x: el.x + dx, y: el.y + dy };
                            }));
                        } else if (selectedType === 'infoPoint') {
                            setInfoPoints(prev => prev.map(p =>
                                p.id === selectedId ? { ...p, x: p.x + dx, y: p.y + dy } : p
                            ));
                        } else if (selectedType === 'symbol') {
                            setSymbols(prev => prev.map(s =>
                                s.id === selectedId ? { ...s, x: s.x + dx, y: s.y + dy } : s
                            ));
                        } else if (selectedType === 'measurement') {
                            setMeasurements(prev => prev.map(m =>
                                m.id === selectedId ? { ...m, x1: m.x1 + dx, y1: m.y1 + dy, x2: m.x2 + dx, y2: m.y2 + dy } : m
                            ));
                        } else if (selectedType === 'bezier') {
                            setBezierCurves(prev => prev.map(b =>
                                b.id === selectedId ? { ...b, points: b.points.map(p => ({ x: p.x + dx, y: p.y + dy })) } : b
                            ));
                        } else if (selectedType === 'cloud') {
                            setCloudAnnotations(prev => prev.map(c =>
                                c.id === selectedId ? { ...c, points: c.points.map(p => ({ x: p.x + dx, y: p.y + dy })) } : c
                            ));
                        } else if (selectedType === 'leader') {
                            setLeaderLines(prev => prev.map(l =>
                                l.id === selectedId ? { ...l, points: l.points.map(p => ({ x: p.x + dx, y: p.y + dy })) } : l
                            ));
                        }
                    }

                    // Ctrl shortcuts
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key.toLowerCase()) {
                            case 'z':
                                if (e.shiftKey) {
                                    if (history.canRedo) {
                                        history.redo();
                                        const state = history.current;
                                        setSnippets(state.snippets);
                                        setMasks(state.masks);
                                        setElements(state.elements);
                                        setInfoPoints(state.infoPoints || []);
                                        setSymbols(state.symbols || []);
                                        setMeasurements(state.measurements || []);
                                        setCableAnnotations(state.cableAnnotations || []);
                                    }
                                } else {
                                    if (history.canUndo) {
                                        history.undo();
                                        const state = history.current;
                                        setSnippets(state.snippets);
                                        setMasks(state.masks);
                                        setElements(state.elements);
                                        setInfoPoints(state.infoPoints || []);
                                        setSymbols(state.symbols || []);
                                        setMeasurements(state.measurements || []);
                                        setCableAnnotations(state.cableAnnotations || []);
                                    }
                                }
                                e.preventDefault();
                                break;
                            case 'y':
                                if (history.canRedo) {
                                    history.redo();
                                    const state = history.current;
                                    setSnippets(state.snippets);
                                    setMasks(state.masks);
                                    setElements(state.elements);
                                    setInfoPoints(state.infoPoints || []);
                                    setSymbols(state.symbols || []);
                                    setMeasurements(state.measurements || []);
                                    setCableAnnotations(state.cableAnnotations || []);
                                }
                                e.preventDefault();
                                break;
                            case 's':
                                e.preventDefault();
                                handleSaveProject();
                                break;
                            case 'g':
                                e.preventDefault();
                                if (e.shiftKey) {
                                    // Ctrl+Shift+G: Ungroup
                                    handleUngroupElements();
                                } else {
                                    // Ctrl+G: Group selected elements
                                    handleGroupElements();
                                }
                                break;
                            case 'o':
                                e.preventDefault();
                                fileInputRef.current?.click();
                                break;
                            case 'e':
                                e.preventDefault();
                                handleExportPDF();
                                break;
                            case 'c':
                                // Copy selected element
                                if (selectedId && selectedType) {
                                    e.preventDefault();
                                    let elementToCopy = null;
                                    if (selectedType === 'snippet') {
                                        elementToCopy = snippets.find(s => s.id === selectedId);
                                    } else if (selectedType === 'mask') {
                                        elementToCopy = masks.find(m => m.id === selectedId);
                                    } else if (selectedType === 'element') {
                                        elementToCopy = elements.find(el => el.id === selectedId);
                                    } else if (selectedType === 'infoPoint') {
                                        elementToCopy = infoPoints.find(p => p.id === selectedId);
                                    } else if (selectedType === 'symbol') {
                                        elementToCopy = symbols.find(s => s.id === selectedId);
                                    } else if (selectedType === 'measurement') {
                                        elementToCopy = measurements.find(m => m.id === selectedId);
                                    }
                                    if (elementToCopy) {
                                        setClipboard({ type: selectedType, data: JSON.parse(JSON.stringify(elementToCopy)) });
                                    }
                                }
                                break;
                            case 'v':
                                // Paste from clipboard
                                if (clipboard) {
                                    e.preventDefault();
                                    const pastedElement = {
                                        ...clipboard.data,
                                        id: generateId(),
                                        name: `${clipboard.data.name} (copy)`
                                    };
                                    // Offset position by 20px to avoid overlap
                                    if (pastedElement.x !== undefined) pastedElement.x += 20;
                                    if (pastedElement.y !== undefined) pastedElement.y += 20;
                                    if (pastedElement.x1 !== undefined) { pastedElement.x1 += 20; pastedElement.y1 += 20; }
                                    if (pastedElement.x2 !== undefined) { pastedElement.x2 += 20; pastedElement.y2 += 20; }

                                    if (clipboard.type === 'snippet') {
                                        setSnippets(prev => [...prev, pastedElement]);
                                        setSelectedId(pastedElement.id);
                                        setSelectedType('snippet');
                                    } else if (clipboard.type === 'mask') {
                                        setMasks(prev => [...prev, pastedElement]);
                                        setSelectedId(pastedElement.id);
                                        setSelectedType('mask');
                                    } else if (clipboard.type === 'element') {
                                        setElements(prev => [...prev, pastedElement]);
                                        setSelectedId(pastedElement.id);
                                        setSelectedType('element');
                                    } else if (clipboard.type === 'infoPoint') {
                                        // Update number for info points
                                        const maxNumber = infoPoints.reduce((max, p) => Math.max(max, p.number || 0), 0);
                                        pastedElement.number = maxNumber + 1;
                                        setInfoPoints(prev => [...prev, pastedElement]);
                                        setSelectedId(pastedElement.id);
                                        setSelectedType('infoPoint');
                                    } else if (clipboard.type === 'symbol') {
                                        setSymbols(prev => [...prev, pastedElement]);
                                        setSelectedId(pastedElement.id);
                                        setSelectedType('symbol');
                                    } else if (clipboard.type === 'measurement') {
                                        setMeasurements(prev => [...prev, pastedElement]);
                                        setSelectedId(pastedElement.id);
                                        setSelectedType('measurement');
                                    }
                                }
                                break;
                            case 'd':
                                // Duplicate in place (offset 10px)
                                if (selectedId && selectedType) {
                                    e.preventDefault();
                                    let elementToDupe = null;
                                    if (selectedType === 'snippet') {
                                        elementToDupe = snippets.find(s => s.id === selectedId);
                                    } else if (selectedType === 'mask') {
                                        elementToDupe = masks.find(m => m.id === selectedId);
                                    } else if (selectedType === 'element') {
                                        elementToDupe = elements.find(el => el.id === selectedId);
                                    } else if (selectedType === 'infoPoint') {
                                        elementToDupe = infoPoints.find(p => p.id === selectedId);
                                    } else if (selectedType === 'symbol') {
                                        elementToDupe = symbols.find(s => s.id === selectedId);
                                    } else if (selectedType === 'measurement') {
                                        elementToDupe = measurements.find(m => m.id === selectedId);
                                    }
                                    if (elementToDupe) {
                                        const duped = {
                                            ...JSON.parse(JSON.stringify(elementToDupe)),
                                            id: generateId(),
                                            name: `${elementToDupe.name} (copy)`
                                        };
                                        // Offset by 10px
                                        if (duped.x !== undefined) duped.x += 10;
                                        if (duped.y !== undefined) duped.y += 10;
                                        if (duped.x1 !== undefined) { duped.x1 += 10; duped.y1 += 10; }
                                        if (duped.x2 !== undefined) { duped.x2 += 10; duped.y2 += 10; }

                                        if (selectedType === 'snippet') {
                                            setSnippets(prev => [...prev, duped]);
                                        } else if (selectedType === 'mask') {
                                            setMasks(prev => [...prev, duped]);
                                        } else if (selectedType === 'element') {
                                            setElements(prev => [...prev, duped]);
                                        } else if (selectedType === 'infoPoint') {
                                            const maxNumber = infoPoints.reduce((max, p) => Math.max(max, p.number || 0), 0);
                                            duped.number = maxNumber + 1;
                                            setInfoPoints(prev => [...prev, duped]);
                                        } else if (selectedType === 'symbol') {
                                            setSymbols(prev => [...prev, duped]);
                                        } else if (selectedType === 'measurement') {
                                            setMeasurements(prev => [...prev, duped]);
                                        }
                                        setSelectedId(duped.id);
                                    }
                                }
                                break;
                        }
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedId, selectedType, history, fitToView, clipboard, snippets, masks, elements, infoPoints, symbols, measurements]);
            
            // ============================================
            // EXPORT & SAVE
            // ============================================
            
            const handleExportPDF = async () => {
                if (!currentPageData) return;
                
                // Create offscreen canvas with all layers
                const canvas = document.createElement('canvas');
                canvas.width = currentPageData.width;
                canvas.height = currentPageData.height;
                const ctx = canvas.getContext('2d');
                
                // Draw PDF base
                const img = new Image();
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.src = currentPageData.imageData;
                });
                ctx.drawImage(img, 0, 0);
                
                // Draw masks
                masks.filter(m => m.visible !== false).forEach(mask => {
                    ctx.fillStyle = mask.fill || '#ffffff';
                    ctx.fillRect(mask.x, mask.y, mask.width, mask.height);
                });
                
                // Draw snippets with their captured image data
                for (const snippet of snippets.filter(s => s.visible !== false)) {
                    if (snippet.imageData) {
                        const snippetImg = new Image();
                        await new Promise(resolve => {
                            snippetImg.onload = resolve;
                            snippetImg.onerror = resolve;
                            snippetImg.src = snippet.imageData;
                        });
                        ctx.drawImage(snippetImg, snippet.x, snippet.y, snippet.width, snippet.height);
                    }
                }

                // Draw elements
                elements.filter(e => e.visible !== false).forEach(element => {
                    ctx.save();
                    ctx.strokeStyle = element.stroke || '#000000';
                    ctx.lineWidth = element.strokeWidth || 2;
                    ctx.fillStyle = element.fill || 'transparent';
                    const rotation = element.rotation || 0;

                    switch (element.type) {
                        case 'rectangle':
                            if (rotation) {
                                const cx = element.x + element.width / 2;
                                const cy = element.y + element.height / 2;
                                ctx.translate(cx, cy);
                                ctx.rotate(rotation * Math.PI / 180);
                                ctx.translate(-cx, -cy);
                            }
                            if (element.fill && element.fill !== 'none') {
                                ctx.fillRect(element.x, element.y, element.width, element.height);
                            }
                            ctx.strokeRect(element.x, element.y, element.width, element.height);
                            break;
                        case 'circle':
                            ctx.beginPath();
                            ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                            if (element.fill && element.fill !== 'none') {
                                ctx.fill();
                            }
                            ctx.stroke();
                            break;
                        case 'line':
                            ctx.beginPath();
                            ctx.moveTo(element.x1, element.y1);
                            ctx.lineTo(element.x2, element.y2);
                            ctx.stroke();
                            break;
                        case 'arrow':
                            // Draw arrow line
                            ctx.beginPath();
                            ctx.moveTo(element.x1, element.y1);
                            ctx.lineTo(element.x2, element.y2);
                            ctx.stroke();
                            // Draw arrowhead at end
                            if (element.arrowEnd !== false) {
                                const angle = Math.atan2(element.y2 - element.y1, element.x2 - element.x1);
                                const headLen = 10 * (element.strokeWidth || 2);
                                ctx.beginPath();
                                ctx.moveTo(element.x2, element.y2);
                                ctx.lineTo(element.x2 - headLen * Math.cos(angle - Math.PI / 6), element.y2 - headLen * Math.sin(angle - Math.PI / 6));
                                ctx.lineTo(element.x2 - headLen * Math.cos(angle + Math.PI / 6), element.y2 - headLen * Math.sin(angle + Math.PI / 6));
                                ctx.closePath();
                                ctx.fillStyle = element.stroke || '#000000';
                                ctx.fill();
                            }
                            // Draw arrowhead at start
                            if (element.arrowStart) {
                                const angle = Math.atan2(element.y1 - element.y2, element.x1 - element.x2);
                                const headLen = 10 * (element.strokeWidth || 2);
                                ctx.beginPath();
                                ctx.moveTo(element.x1, element.y1);
                                ctx.lineTo(element.x1 - headLen * Math.cos(angle - Math.PI / 6), element.y1 - headLen * Math.sin(angle - Math.PI / 6));
                                ctx.lineTo(element.x1 - headLen * Math.cos(angle + Math.PI / 6), element.y1 - headLen * Math.sin(angle + Math.PI / 6));
                                ctx.closePath();
                                ctx.fillStyle = element.stroke || '#000000';
                                ctx.fill();
                            }
                            break;
                    }
                    ctx.restore();
                });
                
                exportCanvasRef.current = canvas;
                await exportToPDF({ current: canvas }, `${pdfData?.fileName || 'markup'}-export.pdf`);
            };
            
            // Export functions for HV cable data
            const handleExportJointRegister = () => {
                // Find all joint symbols
                const joints = symbols.filter(s => HV_SYMBOLS[s.symbolId]?.category === 'joints');
                const headers = ['Joint ID', 'Type', 'Circuit', 'Phase', 'Chainage', 'Cable In', 'Cable Out', 'Manufacturer', 'Status', 'X', 'Y'];
                const rows = joints.map((joint, idx) => {
                    const symbolDef = HV_SYMBOLS[joint.symbolId];
                    return [
                        joint.specs?.jointId || `J${idx + 1}`,
                        symbolDef?.name || joint.symbolId,
                        joint.specs?.circuit || '',
                        joint.specs?.phase || '',
                        joint.specs?.chainage || '',
                        joint.specs?.cableIn || '',
                        joint.specs?.cableOut || '',
                        joint.specs?.manufacturer || '',
                        joint.specs?.status || 'Installed',
                        Math.round(joint.x),
                        Math.round(joint.y)
                    ];
                });
                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
                ].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'joint-register.csv';
                link.click();
                URL.revokeObjectURL(url);
            };

            const handleExportCableSchedule = () => {
                // Export cable annotations
                const headers = ['Cable ID', 'Circuit', 'From', 'To', 'Voltage', 'Conductor Size', 'Material', 'Insulation', 'Length', 'Installation'];
                const rows = cableAnnotations.map((cable, idx) => [
                    cable.specs?.cableId || `C${idx + 1}`,
                    cable.specs?.circuit || '',
                    cable.specs?.from || '',
                    cable.specs?.to || '',
                    cable.specs?.voltageClass || '',
                    cable.specs?.conductorSize || '',
                    cable.specs?.conductorMaterial || '',
                    cable.specs?.insulationType || '',
                    cable.specs?.length || '',
                    cable.specs?.installationType || ''
                ]);
                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
                ].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'cable-schedule.csv';
                link.click();
                URL.revokeObjectURL(url);
            };

            const handleExportTestPoints = () => {
                // Find test point symbols and info points tagged as test points
                const testPointSymbols = symbols.filter(s => s.symbolId === 'test-point');
                const testPointInfos = infoPoints.filter(p => p.tags?.includes('test-point') || p.category === 'test');
                const headers = ['TP ID', 'Location', 'Type', 'Circuit', 'Phase', 'X', 'Y', 'Last Test', 'Status'];
                const rows = [
                    ...testPointSymbols.map((tp, idx) => [
                        tp.specs?.tpId || `TP${idx + 1}`,
                        tp.specs?.location || '',
                        'Symbol',
                        tp.specs?.circuit || '',
                        tp.specs?.phase || '',
                        Math.round(tp.x),
                        Math.round(tp.y),
                        tp.specs?.lastTest || '',
                        tp.specs?.status || 'Active'
                    ]),
                    ...testPointInfos.map((tp, idx) => [
                        tp.metadata?.tpId || `TP-I${idx + 1}`,
                        tp.label || tp.name || '',
                        'Info Point',
                        tp.metadata?.circuit || '',
                        tp.metadata?.phase || '',
                        Math.round(tp.x),
                        Math.round(tp.y),
                        tp.metadata?.lastTest || '',
                        tp.metadata?.status || 'Active'
                    ])
                ];
                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
                ].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'test-points.csv';
                link.click();
                URL.revokeObjectURL(url);
            };

            const handleExportMeasurements = () => {
                const headers = ['Measurement ID', 'Name', 'Distance (px)', 'Distance (Real)', 'Unit', 'X1', 'Y1', 'X2', 'Y2'];
                const rows = measurements.map((m, idx) => [
                    m.id.slice(-6),
                    m.name || `M${idx + 1}`,
                    m.pixelDistance.toFixed(1),
                    m.realDistance !== null ? m.realDistance.toFixed(2) : 'N/A',
                    m.unit || 'px',
                    Math.round(m.x1),
                    Math.round(m.y1),
                    Math.round(m.x2),
                    Math.round(m.y2)
                ]);
                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
                ].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'measurements.csv';
                link.click();
                URL.revokeObjectURL(url);
            };

            // BOM (Bill of Materials) Export
            const handleExportBOM = () => {
                // Count all symbols by type
                const symbolCounts = {};
                symbols.forEach(s => {
                    const symbolDef = HV_SYMBOLS[s.symbolId];
                    if (symbolDef) {
                        const key = `${symbolDef.category}|${symbolDef.name}`;
                        if (!symbolCounts[key]) {
                            symbolCounts[key] = {
                                category: symbolDef.category,
                                name: symbolDef.name,
                                symbolId: s.symbolId,
                                count: 0,
                                items: []
                            };
                        }
                        symbolCounts[key].count++;
                        symbolCounts[key].items.push({
                            id: s.id,
                            name: s.name,
                            x: Math.round(s.x),
                            y: Math.round(s.y),
                            specs: s.specs || {}
                        });
                    }
                });

                // Count elements by type
                const elementCounts = {};
                elements.forEach(el => {
                    const key = el.type;
                    if (!elementCounts[key]) {
                        elementCounts[key] = { type: el.type, count: 0 };
                    }
                    elementCounts[key].count++;
                });

                // Generate CSV
                const headers = ['Category', 'Item', 'Symbol ID', 'Quantity', 'Locations'];
                const rows = [];

                // Add symbols to BOM
                Object.values(symbolCounts).forEach(item => {
                    rows.push([
                        item.category,
                        item.name,
                        item.symbolId,
                        item.count,
                        item.items.map(i => `(${i.x},${i.y})`).join('; ')
                    ]);
                });

                // Add elements summary
                if (Object.keys(elementCounts).length > 0) {
                    rows.push(['', '', '', '', '']); // Empty row separator
                    rows.push(['ELEMENTS', '', '', '', '']);
                    Object.values(elementCounts).forEach(item => {
                        rows.push(['Drawing', item.type.charAt(0).toUpperCase() + item.type.slice(1), '', item.count, '']);
                    });
                }

                // Add info points count
                if (infoPoints.length > 0) {
                    rows.push(['', '', '', '', '']);
                    rows.push(['ANNOTATIONS', '', '', '', '']);
                    rows.push(['Annotation', 'Info Points', '', infoPoints.length, '']);
                }

                // Add measurements count
                if (measurements.length > 0) {
                    rows.push(['Annotation', 'Measurements', '', measurements.length, '']);
                }

                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
                ].join('\n');

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'bill-of-materials.csv';
                link.click();
                URL.revokeObjectURL(url);
            };

            const handleSaveProject = () => {
                const project = {
                    meta: {
                        version: '2.0',
                        created: new Date().toISOString(),
                        name: pdfData?.fileName || 'Untitled Project'
                    },
                    settings: {
                        styles: styles,
                        scaleCalibration: scaleCalibration
                    },
                    pages: pdfData ? [{
                        pageNumber: currentPage,
                        pdfDataUrl: currentPageData?.imageData,
                        width: currentPageData?.width,
                        height: currentPageData?.height,
                        snippets: snippets,
                        masks: masks,
                        elements: elements,
                        infoPoints: infoPoints,
                        symbols: symbols,
                        measurements: measurements,
                        cableAnnotations: cableAnnotations,
                        bezierCurves: bezierCurves,
                        cloudAnnotations: cloudAnnotations,
                        leaderLines: leaderLines
                    }] : []
                };

                const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${pdfData?.fileName || 'project'}.cme`;
                link.click();
                URL.revokeObjectURL(url);
            };

            const handleLoadProject = async (file) => {
                try {
                    const text = await file.text();
                    const project = JSON.parse(text);

                    if (project.pages && project.pages[0]) {
                        const page = project.pages[0];
                        setPdfData({
                            fileName: project.meta?.name || 'Loaded Project',
                            pageCount: 1,
                            pages: [{
                                pageNumber: 0,
                                width: page.width,
                                height: page.height,
                                imageData: page.pdfDataUrl,
                                elements: [],
                                masks: [],
                                snippets: [],
                                infoPoints: []
                            }]
                        });
                        setSnippets(page.snippets || []);
                        setMasks(page.masks || []);
                        setElements(page.elements || []);
                        setInfoPoints(page.infoPoints || []);
                        setSymbols(page.symbols || []);
                        setMeasurements(page.measurements || []);
                        setCableAnnotations(page.cableAnnotations || []);
                        setBezierCurves(page.bezierCurves || []);
                        setCloudAnnotations(page.cloudAnnotations || []);
                        setLeaderLines(page.leaderLines || []);
                        setStyles(project.settings?.styles || DEFAULT_STYLES);
                        // Load scale calibration if available
                        if (project.settings?.scaleCalibration) {
                            setScaleCalibration(project.settings.scaleCalibration);
                        }
                        setCurrentPage(0);
                        setTimeout(() => fitToView(), 100);
                    }
                } catch (error) {
                    console.error('Failed to load project:', error);
                    alert('Failed to load project file');
                }
            };
            
            // ============================================
            // ITEM MANAGEMENT
            // ============================================
            
            const handleSelectItem = (item, type) => {
                setSelectedId(item.id);
                setSelectedType(type);
            };
            
            const handleDeleteItem = (id, type) => {
                if (type === 'snippet') setSnippets(prev => prev.filter(s => s.id !== id));
                if (type === 'mask') setMasks(prev => prev.filter(m => m.id !== id));
                if (type === 'element') setElements(prev => prev.filter(e => e.id !== id));
                if (type === 'infoPoint') setInfoPoints(prev => prev.filter(p => p.id !== id));
                if (type === 'symbol') setSymbols(prev => prev.filter(s => s.id !== id));
                if (type === 'measurement') setMeasurements(prev => prev.filter(m => m.id !== id));

                if (selectedId === id) {
                    setSelectedId(null);
                    setSelectedType(null);
                }
            };

            const handleToggleVisibility = (id, type) => {
                const updateVisibility = (items, setItems) => {
                    setItems(items.map(item =>
                        item.id === id ? { ...item, visible: item.visible === false ? true : false } : item
                    ));
                };

                if (type === 'snippet') updateVisibility(snippets, setSnippets);
                if (type === 'mask') updateVisibility(masks, setMasks);
                if (type === 'element') updateVisibility(elements, setElements);
                if (type === 'infoPoint') updateVisibility(infoPoints, setInfoPoints);
                if (type === 'symbol') updateVisibility(symbols, setSymbols);
                if (type === 'measurement') updateVisibility(measurements, setMeasurements);
            };

            const handleUpdateSelected = (updates) => {
                if (!selectedId) return;

                if (selectedType === 'snippet') {
                    setSnippets(prev => prev.map(s => s.id === selectedId ? { ...s, ...updates } : s));
                } else if (selectedType === 'mask') {
                    setMasks(prev => prev.map(m => m.id === selectedId ? { ...m, ...updates } : m));
                } else if (selectedType === 'element') {
                    setElements(prev => prev.map(e => e.id === selectedId ? { ...e, ...updates } : e));
                } else if (selectedType === 'infoPoint') {
                    setInfoPoints(prev => prev.map(p => p.id === selectedId ? { ...p, ...updates } : p));
                } else if (selectedType === 'symbol') {
                    setSymbols(prev => prev.map(s => s.id === selectedId ? { ...s, ...updates } : s));
                } else if (selectedType === 'measurement') {
                    setMeasurements(prev => prev.map(m => m.id === selectedId ? { ...m, ...updates } : m));
                }
            };

            // Calibration handler
            const handleCalibrationComplete = (knownDistance, unit) => {
                if (calibrationPoints.length === 2) {
                    const pixelDist = distance(calibrationPoints[0], calibrationPoints[1]);
                    const pixelsPerMeter = unit === 'meters' ? pixelDist / knownDistance : pixelDist / (knownDistance * 0.3048);
                    setScaleCalibration({
                        isCalibrated: true,
                        pixelsPerMeter: pixelsPerMeter,
                        unit: unit,
                        calibrationPoints: calibrationPoints
                    });
                    // Recalculate all existing measurements
                    setMeasurements(prev => prev.map(m => ({
                        ...m,
                        realDistance: m.pixelDistance / pixelsPerMeter,
                        unit: unit
                    })));
                }
                setShowCalibrationDialog(false);
                setCalibrationStep(0);
                setCalibrationPoints([]);
                setCurrentTool(OPERATIONS.SELECT);
            };

            // ============================================
            // SNIPPET LIBRARY HANDLERS
            // ============================================

            const handleSaveToLibrary = (snippet) => {
                const newLibrary = [...snippetLibrary, { ...snippet, id: generateId() }];
                setSnippetLibrary(newLibrary);
                localStorage.setItem('snippetLibrary', JSON.stringify(newLibrary));
            };

            const handleInsertFromLibrary = (librarySnippet) => {
                const newSnippet = {
                    ...librarySnippet,
                    id: generateId(),
                    name: `${librarySnippet.libraryName} (copy)`,
                    x: 50,
                    y: 50,
                };
                delete newSnippet.libraryName;
                delete newSnippet.savedAt;
                setSnippets(prev => [...prev, newSnippet]);
                history.push({ snippets: [...snippets, newSnippet], masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            const handleDeleteFromLibrary = (index) => {
                const newLibrary = snippetLibrary.filter((_, i) => i !== index);
                setSnippetLibrary(newLibrary);
                localStorage.setItem('snippetLibrary', JSON.stringify(newLibrary));
            };

            // Get selected snippet for library
            const selectedSnippet = selectedType === 'snippet' ? snippets.find(s => s.id === selectedId) : null;

            // ============================================
            // TEMPLATE FUNCTIONS
            // ============================================

            const handleSaveTemplate = () => {
                if (!templateName.trim()) {
                    alert('Please enter a template name');
                    return;
                }

                const template = {
                    id: generateId(),
                    name: templateName.trim(),
                    description: templateDescription.trim(),
                    createdAt: new Date().toISOString(),
                    data: {
                        elements: elements.map(el => ({ ...el, id: undefined })),
                        symbols: symbols.map(s => ({ ...s, id: undefined })),
                        infoPoints: infoPoints.map(ip => ({ ...ip, id: undefined })),
                        measurements: measurements.map(m => ({ ...m, id: undefined })),
                    }
                };

                const newLibrary = [...templateLibrary, template];
                setTemplateLibrary(newLibrary);
                localStorage.setItem('markupTemplateLibrary', JSON.stringify(newLibrary));

                setShowTemplateDialog(false);
                setTemplateName('');
                setTemplateDescription('');
            };

            const handleApplyTemplate = (template) => {
                if (!pdfData) {
                    alert('Please load a document first');
                    return;
                }

                // Generate new IDs for all elements
                const newElements = template.data.elements.map(el => ({ ...el, id: generateId() }));
                const newSymbols = template.data.symbols.map(s => ({ ...s, id: generateId() }));
                const newInfoPoints = template.data.infoPoints.map(ip => ({ ...ip, id: generateId() }));
                const newMeasurements = template.data.measurements.map(m => ({ ...m, id: generateId() }));

                // Add to existing elements
                setElements(prev => [...prev, ...newElements]);
                setSymbols(prev => [...prev, ...newSymbols]);
                setInfoPoints(prev => [...prev, ...newInfoPoints]);
                setMeasurements(prev => [...prev, ...newMeasurements]);

                // Save to history
                history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            const handleDeleteTemplate = (templateId) => {
                const newLibrary = templateLibrary.filter(t => t.id !== templateId);
                setTemplateLibrary(newLibrary);
                localStorage.setItem('markupTemplateLibrary', JSON.stringify(newLibrary));
            };

            // ============================================
            // FAVORITES FUNCTIONS
            // ============================================

            const handleToggleFavorite = (symbolId) => {
                const existingIndex = favorites.findIndex(f => f.symbolId === symbolId);
                let newFavorites;
                if (existingIndex >= 0) {
                    // Remove from favorites
                    newFavorites = favorites.filter((_, i) => i !== existingIndex);
                } else {
                    // Add to favorites
                    newFavorites = [...favorites, { symbolId, addedAt: new Date().toISOString() }];
                }
                setFavorites(newFavorites);
                localStorage.setItem('markupFavorites', JSON.stringify(newFavorites));
            };

            // ============================================
            // GROUPING FUNCTIONS
            // ============================================

            const handleGroupElements = () => {
                if (selectedIds.length < 2) return;

                const newGroup = {
                    id: generateId(),
                    name: `Group ${groups.length + 1}`,
                    members: [...selectedIds],
                    visible: true,
                    locked: false
                };

                setGroups(prev => [...prev, newGroup]);
                // Select the group instead of individual items
                setSelectedIds([]);
                setSelectedId(newGroup.id);
                setSelectedType('group');
                history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            const handleUngroupElements = () => {
                // Find if current selection is a group
                const group = groups.find(g => g.id === selectedId);
                if (!group) return;

                // Remove the group and select its members
                setGroups(prev => prev.filter(g => g.id !== group.id));
                setSelectedIds(group.members);
                setSelectedId(group.members[0]?.id || null);
                setSelectedType(group.members[0]?.type || null);
                history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            // Get all members of a group recursively
            const getGroupMembers = (groupId) => {
                const group = groups.find(g => g.id === groupId);
                if (!group) return [];
                return group.members;
            };

            // Check if an item belongs to a group
            const getItemGroup = (itemId, itemType) => {
                return groups.find(g => g.members.some(m => m.id === itemId && m.type === itemType));
            };

            // ============================================
            // COMMENT FUNCTIONS
            // ============================================

            const handleAddComment = () => {
                if (!newCommentText.trim()) return;

                const newComment = {
                    id: generateId(),
                    x: commentDialogPosition.x,
                    y: commentDialogPosition.y,
                    text: newCommentText.trim(),
                    author: 'User',
                    createdAt: new Date().toISOString(),
                    status: 'pending',
                    replies: [],
                    page: currentPage
                };

                setComments(prev => [...prev, newComment]);
                setShowCommentDialog(false);
                setNewCommentText('');
                history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            const handleUpdateCommentStatus = (commentId, newStatus) => {
                setComments(prev => prev.map(c =>
                    c.id === commentId ? { ...c, status: newStatus } : c
                ));
                history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            const handleAddReply = (commentId) => {
                if (!replyText.trim()) return;

                const reply = {
                    id: generateId(),
                    text: replyText.trim(),
                    author: 'User',
                    createdAt: new Date().toISOString()
                };

                setComments(prev => prev.map(c =>
                    c.id === commentId ? { ...c, replies: [...c.replies, reply] } : c
                ));
                setReplyText('');
                history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            const handleDeleteComment = (commentId) => {
                setComments(prev => prev.filter(c => c.id !== commentId));
                setSelectedComment(null);
                history.push({ snippets, masks, elements, infoPoints, symbols, measurements, cableAnnotations });
            };

            // ============================================
            // RENDER
            // ============================================
            
            return (
                <div className="h-screen flex flex-col bg-editor-bg">
                    {/* Header / Menu Bar */}
                    <header className="h-12 bg-panel-bg border-b border-panel-border flex items-center px-4 gap-4">
                        <div className="flex items-center gap-2">
                            <div className="w-8 h-8 bg-accent rounded flex items-center justify-center">
                                <span className="text-white font-bold text-sm">CM</span>
                            </div>
                            <span className="text-white font-semibold">Cable Markup Editor</span>
                            {hasUnsavedChanges && (
                                <span className="px-2 py-0.5 text-[10px] bg-yellow-500/20 text-yellow-400 rounded-full">
                                    Unsaved
                                </span>
                            )}
                            {lastAutoSave && (
                                <span className="text-[10px] text-gray-500">
                                    Auto-saved {lastAutoSave}
                                </span>
                            )}
                        </div>

                        {/* Version History Button */}
                        {autoSaveVersions.length > 0 && (
                            <button
                                className="px-2 py-1 text-xs text-gray-400 hover:text-white hover:bg-gray-700 rounded flex items-center gap-1"
                                onClick={() => setShowVersionHistory(true)}
                                title="View auto-save history"
                            >
                                <Icons.Clock /> History ({autoSaveVersions.length})
                            </button>
                        )}

                        <div className="h-6 w-px bg-panel-border" />
                        
                        {/* File Menu */}
                        <div className="flex items-center gap-1">
                            <button
                                className="px-3 py-1.5 text-sm text-gray-300 hover:bg-gray-700 rounded flex items-center gap-2"
                                onClick={() => fileInputRef.current?.click()}
                            >
                                <div className="w-4 h-4"><Icons.Folder /></div>
                                Open File
                            </button>
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept=".pdf,.cme,.png,.jpg,.jpeg,.gif,.webp,.bmp,.svg"
                                className="hidden"
                                onChange={(e) => {
                                    const file = e.target.files[0];
                                    if (file) {
                                        if (file.name.endsWith('.cme')) {
                                            handleLoadProject(file);
                                        } else {
                                            handleFileLoad(file);
                                        }
                                    }
                                    e.target.value = '';
                                }}
                            />
                            <button
                                className="px-3 py-1.5 text-sm text-gray-300 hover:bg-gray-700 rounded flex items-center gap-2"
                                onClick={handleSaveProject}
                                disabled={!pdfData}
                            >
                                <div className="w-4 h-4"><Icons.Save /></div>
                                Save
                            </button>
                            <button
                                className="px-3 py-1.5 text-sm text-gray-300 hover:bg-gray-700 rounded flex items-center gap-2"
                                onClick={() => imageOverlayInputRef.current?.click()}
                                disabled={!pdfData}
                                title="Import image as overlay"
                            >
                                <div className="w-4 h-4"><Icons.Image /></div>
                                Import Image
                            </button>
                            <input
                                ref={imageOverlayInputRef}
                                type="file"
                                accept=".png,.jpg,.jpeg,.gif,.webp,.bmp,.svg"
                                className="hidden"
                                onChange={(e) => {
                                    const file = e.target.files[0];
                                    if (file) handleImportImageOverlay(file);
                                    e.target.value = '';
                                }}
                            />
                            {/* Recent Files Dropdown */}
                            {recentFiles.length > 0 && (
                                <div className="relative group">
                                    <button
                                        className="px-3 py-1.5 text-sm text-gray-300 hover:bg-gray-700 rounded flex items-center gap-2"
                                    >
                                        <div className="w-4 h-4"><Icons.Clock /></div>
                                        Recent
                                        <div className="w-3 h-3"><Icons.ChevronDown /></div>
                                    </button>
                                    <div className="absolute top-full left-0 mt-1 bg-panel-bg border border-panel-border rounded-lg shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50 min-w-[200px]">
                                        <div className="py-1 max-h-60 overflow-y-auto">
                                            {recentFiles.map((file, idx) => (
                                                <div
                                                    key={idx}
                                                    className="px-3 py-2 hover:bg-gray-700 cursor-default flex items-center gap-2"
                                                    title={`${file.name} - ${new Date(file.timestamp).toLocaleString()}`}
                                                >
                                                    <div className="w-4 h-4 text-gray-500">
                                                        {file.type === 'pdf' ? <Icons.File /> : <Icons.Image />}
                                                    </div>
                                                    <div className="flex-1 min-w-0">
                                                        <div className="text-sm text-gray-300 truncate">{file.name}</div>
                                                        <div className="text-xs text-gray-500">{new Date(file.timestamp).toLocaleDateString()}</div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        <div className="border-t border-panel-border px-3 py-2">
                                            <button
                                                className="text-xs text-gray-500 hover:text-gray-300"
                                                onClick={() => {
                                                    setRecentFiles([]);
                                                    localStorage.removeItem('markupRecentFiles');
                                                }}
                                            >
                                                Clear Recent
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="h-6 w-px bg-panel-border" />

                        {/* Undo/Redo */}
                        <div className="flex items-center gap-1">
                            <button
                                className={`p-2 rounded ${history.canUndo ? 'text-gray-300 hover:bg-gray-700' : 'text-gray-600'}`}
                                onClick={() => {
                                    if (history.canUndo) {
                                        history.undo();
                                        const state = history.current;
                                        setSnippets(state.snippets);
                                        setMasks(state.masks);
                                        setElements(state.elements);
                                        setInfoPoints(state.infoPoints || []);
                                        setSymbols(state.symbols || []);
                                        setMeasurements(state.measurements || []);
                                        setCableAnnotations(state.cableAnnotations || []);
                                    }
                                }}
                                disabled={!history.canUndo}
                            >
                                <div className="w-4 h-4"><Icons.Undo /></div>
                            </button>
                            <button
                                className={`p-2 rounded ${history.canRedo ? 'text-gray-300 hover:bg-gray-700' : 'text-gray-600'}`}
                                onClick={() => {
                                    if (history.canRedo) {
                                        history.redo();
                                        const state = history.current;
                                        setSnippets(state.snippets);
                                        setMasks(state.masks);
                                        setElements(state.elements);
                                        setInfoPoints(state.infoPoints || []);
                                        setSymbols(state.symbols || []);
                                        setMeasurements(state.measurements || []);
                                        setCableAnnotations(state.cableAnnotations || []);
                                    }
                                }}
                                disabled={!history.canRedo}
                            >
                                <div className="w-4 h-4"><Icons.Redo /></div>
                            </button>
                        </div>
                        
                        <div className="flex-1" />

                        {/* Theme Toggle */}
                        <button
                            className="p-2 rounded text-gray-300 hover:bg-gray-700"
                            onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
                            title={theme === 'dark' ? 'Switch to Light Theme' : 'Switch to Dark Theme'}
                        >
                            <div className="w-4 h-4">
                                {theme === 'dark' ? <Icons.Sun /> : <Icons.Moon />}
                            </div>
                        </button>

                        <div className="h-6 w-px bg-panel-border" />

                        {/* Export Dropdown */}
                        <div className="relative">
                            <button
                                className="px-3 py-1.5 text-sm bg-accent text-white hover:bg-accent-hover rounded flex items-center gap-2"
                                onClick={() => setShowExportMenu(!showExportMenu)}
                                disabled={!pdfData}
                            >
                                <div className="w-4 h-4"><Icons.Download /></div>
                                Export
                                <div className="w-3 h-3"><Icons.ChevronDown /></div>
                            </button>
                            {showExportMenu && (
                                <div className="absolute right-0 top-full mt-1 bg-panel-bg rounded-lg shadow-xl border border-panel-border py-1 z-50 min-w-[180px]" onClick={(e) => e.stopPropagation()}>
                                    <button
                                        className="w-full px-4 py-2 text-left text-sm text-gray-300 hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { handleExportPDF(); setShowExportMenu(false); }}
                                    >
                                        <span className="text-accent">PDF</span>
                                        Export as PDF
                                    </button>
                                    <div className="border-t border-panel-border my-1" />
                                    <div className="px-4 py-1 text-xs text-gray-500 uppercase">HV Cable Data</div>
                                    <button
                                        className="w-full px-4 py-2 text-left text-sm text-gray-300 hover:bg-gray-700"
                                        onClick={() => { handleExportJointRegister(); setShowExportMenu(false); }}
                                    >
                                        Joint Register (CSV)
                                    </button>
                                    <button
                                        className="w-full px-4 py-2 text-left text-sm text-gray-300 hover:bg-gray-700"
                                        onClick={() => { handleExportCableSchedule(); setShowExportMenu(false); }}
                                    >
                                        Cable Schedule (CSV)
                                    </button>
                                    <button
                                        className="w-full px-4 py-2 text-left text-sm text-gray-300 hover:bg-gray-700"
                                        onClick={() => { handleExportTestPoints(); setShowExportMenu(false); }}
                                    >
                                        Test Point List (CSV)
                                    </button>
                                    <button
                                        className="w-full px-4 py-2 text-left text-sm text-gray-300 hover:bg-gray-700"
                                        onClick={() => { handleExportMeasurements(); setShowExportMenu(false); }}
                                    >
                                        Measurements (CSV)
                                    </button>
                                    <div className="border-t border-panel-border my-1" />
                                    <button
                                        className="w-full px-4 py-2 text-left text-sm text-gray-300 hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { handleExportBOM(); setShowExportMenu(false); }}
                                    >
                                        <span className="text-green-400">📋</span>
                                        Bill of Materials (CSV)
                                    </button>
                                </div>
                            )}
                        </div>
                    </header>
                    
                    {/* Main Content */}
                    <div className="flex-1 flex overflow-hidden">
                        {/* Left Panel - Tools */}
                        <aside
                            className="bg-panel-bg border-r border-panel-border flex flex-col flex-shrink-0"
                            style={{ width: leftSidebarWidth }}
                        >
                            {/* Panel Tabs - Consolidated to 4 main tabs */}
                            <div className="flex items-center border-b border-panel-border bg-[#1a1a1a]">
                                <button
                                    className={`flex-1 py-2.5 flex flex-col items-center gap-0.5 transition-colors ${leftPanelTab === 'tools' ? 'text-accent bg-panel-bg' : 'text-gray-500 hover:text-gray-300'}`}
                                    onClick={() => setLeftPanelTab('tools')}
                                    title="Drawing Tools"
                                >
                                    <div className="w-5 h-5"><Icons.Settings /></div>
                                    <span className="text-[10px]">Tools</span>
                                </button>
                                <button
                                    className={`flex-1 py-2.5 flex flex-col items-center gap-0.5 transition-colors ${leftPanelTab === 'library' ? 'text-accent bg-panel-bg' : 'text-gray-500 hover:text-gray-300'}`}
                                    onClick={() => setLeftPanelTab('library')}
                                    title="Symbols, Templates & Favorites"
                                >
                                    <div className="w-5 h-5"><Icons.Component /></div>
                                    <span className="text-[10px]">Library</span>
                                </button>
                                <button
                                    className={`flex-1 py-2.5 flex flex-col items-center gap-0.5 transition-colors ${leftPanelTab === 'layers' ? 'text-accent bg-panel-bg' : 'text-gray-500 hover:text-gray-300'}`}
                                    onClick={() => setLeftPanelTab('layers')}
                                    title="Layers & Data"
                                >
                                    <div className="w-5 h-5"><Icons.Layers /></div>
                                    <span className="text-[10px]">Layers</span>
                                </button>
                                <button
                                    className={`flex-1 py-2.5 flex flex-col items-center gap-0.5 transition-colors ${leftPanelTab === 'pages' ? 'text-accent bg-panel-bg' : 'text-gray-500 hover:text-gray-300'}`}
                                    onClick={() => setLeftPanelTab('pages')}
                                    title="Page Navigation"
                                >
                                    <div className="w-5 h-5"><Icons.Pages /></div>
                                    <span className="text-[10px]">Pages</span>
                                </button>
                            </div>
                            
                            {leftPanelTab === 'tools' ? (
                                <div className="flex-1 overflow-y-auto">
                                    {/* Selection & Navigation */}
                                    <CollapsibleSection title="Selection" collapsed={collapsedSections.selection} onToggle={() => toggleSection('selection')}>
                                        <div className="grid grid-cols-5 gap-1">
                                            <ToolButton
                                                icon={Icons.Cursor}
                                                label="Select"
                                                shortcut="V"
                                                active={currentTool === OPERATIONS.SELECT}
                                                onClick={() => setCurrentTool(OPERATIONS.SELECT)}
                                            />
                                            <ToolButton
                                                icon={Icons.Move}
                                                label="Pan"
                                                active={currentTool === OPERATIONS.PAN}
                                                onClick={() => setCurrentTool(OPERATIONS.PAN)}
                                            />
                                        </div>
                                    </CollapsibleSection>

                                    {/* Drawing Tools */}
                                    <CollapsibleSection title="Drawing" collapsed={collapsedSections.drawing} onToggle={() => toggleSection('drawing')}>
                                        <div className="grid grid-cols-5 gap-1">
                                            <ToolButton
                                                icon={Icons.Line}
                                                label="Line"
                                                shortcut="L"
                                                active={currentTool === OPERATIONS.LINE}
                                                onClick={() => setCurrentTool(OPERATIONS.LINE)}
                                            />
                                            <ToolButton
                                                icon={Icons.Square}
                                                label="Rectangle"
                                                shortcut="R"
                                                active={currentTool === OPERATIONS.RECTANGLE}
                                                onClick={() => setCurrentTool(OPERATIONS.RECTANGLE)}
                                            />
                                            <ToolButton
                                                icon={Icons.Circle}
                                                label="Circle"
                                                shortcut="C"
                                                active={currentTool === OPERATIONS.CIRCLE}
                                                onClick={() => setCurrentTool(OPERATIONS.CIRCLE)}
                                            />
                                            <ToolButton
                                                icon={Icons.Arrow}
                                                label="Arrow"
                                                shortcut="A"
                                                active={currentTool === OPERATIONS.ARROW}
                                                onClick={() => setCurrentTool(OPERATIONS.ARROW)}
                                            />
                                            <ToolButton
                                                icon={Icons.Scissors}
                                                label="Snippet"
                                                shortcut="S"
                                                active={currentTool === OPERATIONS.SNIPPET}
                                                onClick={() => setCurrentTool(OPERATIONS.SNIPPET)}
                                            />
                                            <ToolButton
                                                icon={Icons.Mask}
                                                label="Mask"
                                                shortcut="M"
                                                active={currentTool === OPERATIONS.MASK}
                                                onClick={() => setCurrentTool(OPERATIONS.MASK)}
                                            />
                                            <ToolButton
                                                icon={Icons.Polyline}
                                                label="Polyline"
                                                shortcut="Y"
                                                active={currentTool === OPERATIONS.POLYLINE}
                                                onClick={() => setCurrentTool(OPERATIONS.POLYLINE)}
                                            />
                                            <ToolButton
                                                icon={Icons.Pencil}
                                                label="Freehand"
                                                shortcut="F"
                                                active={currentTool === OPERATIONS.FREEHAND}
                                                onClick={() => setCurrentTool(OPERATIONS.FREEHAND)}
                                            />
                                            <ToolButton
                                                icon={Icons.Bezier}
                                                label="Bezier"
                                                shortcut="B"
                                                active={currentTool === OPERATIONS.BEZIER}
                                                onClick={() => setCurrentTool(OPERATIONS.BEZIER)}
                                            />
                                            <ToolButton
                                                icon={Icons.Cloud}
                                                label="Cloud"
                                                shortcut=""
                                                active={currentTool === OPERATIONS.CLOUD}
                                                onClick={() => setCurrentTool(OPERATIONS.CLOUD)}
                                            />
                                            <ToolButton
                                                icon={Icons.Leader}
                                                label="Leader"
                                                shortcut=""
                                                active={currentTool === OPERATIONS.LEADER}
                                                onClick={() => setCurrentTool(OPERATIONS.LEADER)}
                                            />
                                        </div>
                                    </CollapsibleSection>

                                    {/* Annotation Tools */}
                                    <CollapsibleSection title="Annotation" collapsed={collapsedSections.annotation} onToggle={() => toggleSection('annotation')}>
                                        <div className="grid grid-cols-5 gap-1">
                                            <ToolButton
                                                icon={Icons.InfoPoint}
                                                label="Info Point"
                                                shortcut="I"
                                                active={currentTool === OPERATIONS.INFO_POINT}
                                                onClick={() => setCurrentTool(OPERATIONS.INFO_POINT)}
                                            />
                                            <ToolButton
                                                icon={Icons.Component}
                                                label="Symbol"
                                                shortcut="P"
                                                active={currentTool === OPERATIONS.SYMBOL}
                                                onClick={() => {
                                                    setCurrentTool(OPERATIONS.SYMBOL);
                                                    setLeftPanelTab('symbols');
                                                }}
                                            />
                                            <ToolButton
                                                icon={Icons.Type}
                                                label="Text"
                                                shortcut="T"
                                                active={currentTool === OPERATIONS.TEXT}
                                                onClick={() => setCurrentTool(OPERATIONS.TEXT)}
                                            />
                                            <ToolButton
                                                icon={Icons.Callout}
                                                label="Callout"
                                                shortcut="B"
                                                active={currentTool === OPERATIONS.CALLOUT}
                                                onClick={() => setCurrentTool(OPERATIONS.CALLOUT)}
                                            />
                                            <ToolButton
                                                icon={Icons.Ruler}
                                                label="Dimension"
                                                shortcut="J"
                                                active={currentTool === OPERATIONS.DIMENSION}
                                                onClick={() => setCurrentTool(OPERATIONS.DIMENSION)}
                                            />
                                            <ToolButton
                                                icon={Icons.Polygon}
                                                label="Polygon"
                                                shortcut="O"
                                                active={currentTool === OPERATIONS.POLYGON}
                                                onClick={() => setCurrentTool(OPERATIONS.POLYGON)}
                                            />
                                            <ToolButton
                                                icon={Icons.Arc}
                                                label="Arc"
                                                shortcut="U"
                                                active={currentTool === OPERATIONS.ARC}
                                                onClick={() => setCurrentTool(OPERATIONS.ARC)}
                                            />
                                            <ToolButton
                                                icon={Icons.List}
                                                label="Summary"
                                                onClick={() => setShowInfoSummary(true)}
                                            />
                                            <ToolButton
                                                icon={Icons.Comment}
                                                label="Comment"
                                                shortcut="K"
                                                active={currentTool === OPERATIONS.COMMENT}
                                                onClick={() => setCurrentTool(OPERATIONS.COMMENT)}
                                            />
                                        </div>
                                    </CollapsibleSection>

                                    {/* Measurement Tools */}
                                    <CollapsibleSection title="Measurement" collapsed={collapsedSections.measurement} onToggle={() => toggleSection('measurement')}>
                                        <div className="grid grid-cols-5 gap-1">
                                            <ToolButton
                                                icon={Icons.Calibrate}
                                                label="Calibrate"
                                                active={currentTool === OPERATIONS.CALIBRATE}
                                                onClick={() => {
                                                    setCurrentTool(OPERATIONS.CALIBRATE);
                                                    setCalibrationStep(0);
                                                    setCalibrationPoints([]);
                                                }}
                                            />
                                            <ToolButton
                                                icon={Icons.Measure}
                                                label="Measure"
                                                shortcut="D"
                                                active={currentTool === OPERATIONS.MEASURE}
                                                onClick={() => setCurrentTool(OPERATIONS.MEASURE)}
                                            />
                                            <ToolButton
                                                icon={Icons.Area}
                                                label="Area"
                                                shortcut="Shift+A"
                                                active={currentTool === OPERATIONS.AREA}
                                                onClick={() => setCurrentTool(OPERATIONS.AREA)}
                                            />
                                        </div>
                                        {/* Calibration Status */}
                                        {scaleCalibration.isCalibrated ? (
                                            <div className="mt-2 p-2 bg-green-500/10 border border-green-500/30 rounded text-xs text-green-400 flex items-center gap-2">
                                                <span className="w-2 h-2 bg-green-400 rounded-full"></span>
                                                Scale: {scaleCalibration.pixelsPerMeter.toFixed(1)} px/{scaleCalibration.unit === 'meters' ? 'm' : 'ft'}
                                            </div>
                                        ) : (
                                            <div className="mt-2 p-2 bg-yellow-500/10 border border-yellow-500/30 rounded text-xs text-yellow-500">
                                                Not calibrated - click Calibrate to set scale
                                            </div>
                                        )}
                                        {currentTool === OPERATIONS.CALIBRATE && (
                                            <div className="mt-2 p-2 bg-accent/10 border border-accent/30 rounded text-xs text-accent">
                                                {calibrationStep === 0 && "Click first point on a known distance..."}
                                                {calibrationStep === 1 && "Click second point..."}
                                            </div>
                                        )}
                                    </CollapsibleSection>

                                    {/* View Controls */}
                                    <CollapsibleSection title="View" collapsed={collapsedSections.view} onToggle={() => toggleSection('view')}>
                                        <div className="grid grid-cols-5 gap-1">
                                            <ToolButton
                                                icon={Icons.ZoomIn}
                                                label="Zoom In"
                                                onClick={() => setZoom(prev => clamp(prev * 1.2, ZOOM_LIMITS.min, ZOOM_LIMITS.max))}
                                            />
                                            <ToolButton
                                                icon={Icons.ZoomOut}
                                                label="Zoom Out"
                                                onClick={() => setZoom(prev => clamp(prev / 1.2, ZOOM_LIMITS.min, ZOOM_LIMITS.max))}
                                            />
                                            <ToolButton
                                                icon={Icons.Fit}
                                                label="Fit to View"
                                                shortcut="0"
                                                onClick={fitToView}
                                            />
                                            <ToolButton
                                                icon={Icons.Grid}
                                                label="Toggle Grid"
                                                active={showGrid}
                                                onClick={() => setShowGrid(prev => !prev)}
                                            />
                                            <ToolButton
                                                icon={Icons.Magnet}
                                                label="Snap to Grid"
                                                active={snapEnabled}
                                                onClick={() => setSnapEnabled(prev => !prev)}
                                            />
                                            <ToolButton
                                                icon={Icons.AlignGuide}
                                                label="Smart Guides"
                                                active={smartGuidesEnabled}
                                                onClick={() => setSmartGuidesEnabled(prev => !prev)}
                                            />
                                        </div>
                                        {/* Snap Grid Size */}
                                        {snapEnabled && (
                                            <div className="flex items-center gap-2 mt-2">
                                                <span className="text-xs text-gray-400">Grid:</span>
                                                {[10, 20, 50].map(size => (
                                                    <button
                                                        key={size}
                                                        className={`px-2 py-0.5 text-xs rounded ${snapGridSize === size ? 'bg-accent text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                                        onClick={() => setSnapGridSize(size)}
                                                    >
                                                        {size}px
                                                    </button>
                                                ))}
                                            </div>
                                        )}
                                        {/* Quick Zoom Presets */}
                                        <div className="flex gap-1 mt-2">
                                            {[50, 100, 150, 200].map(pct => (
                                                <button
                                                    key={pct}
                                                    className={`flex-1 px-1 py-1 text-xs rounded ${Math.round(zoom * 100) === pct ? 'bg-accent text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                                                    onClick={() => setZoom(pct / 100)}
                                                >
                                                    {pct}%
                                                </button>
                                            ))}
                                        </div>
                                        {/* Zoom to Selection */}
                                        {selectedIds.length > 0 && (
                                            <button
                                                className="w-full mt-2 px-2 py-1 text-xs bg-gray-700 text-gray-300 hover:bg-gray-600 rounded"
                                                onClick={() => {
                                                    // Calculate bounds of selected items
                                                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                                    selectedIds.forEach(sel => {
                                                        let item;
                                                        if (sel.type === 'element') item = elements.find(e => e.id === sel.id);
                                                        else if (sel.type === 'snippet') item = snippets.find(s => s.id === sel.id);
                                                        else if (sel.type === 'mask') item = masks.find(m => m.id === sel.id);
                                                        else if (sel.type === 'symbol') item = symbols.find(s => s.id === sel.id);
                                                        else if (sel.type === 'infoPoint') item = infoPoints.find(p => p.id === sel.id);
                                                        if (item) {
                                                            if (item.x1 !== undefined) {
                                                                minX = Math.min(minX, item.x1, item.x2);
                                                                minY = Math.min(minY, item.y1, item.y2);
                                                                maxX = Math.max(maxX, item.x1, item.x2);
                                                                maxY = Math.max(maxY, item.y1, item.y2);
                                                            } else if (item.radius !== undefined) {
                                                                minX = Math.min(minX, item.x - item.radius);
                                                                minY = Math.min(minY, item.y - item.radius);
                                                                maxX = Math.max(maxX, item.x + item.radius);
                                                                maxY = Math.max(maxY, item.y + item.radius);
                                                            } else {
                                                                minX = Math.min(minX, item.x);
                                                                minY = Math.min(minY, item.y);
                                                                maxX = Math.max(maxX, item.x + (item.width || 20));
                                                                maxY = Math.max(maxY, item.y + (item.height || 20));
                                                            }
                                                        }
                                                    });
                                                    if (minX !== Infinity) {
                                                        const container = containerRef.current;
                                                        const padding = 50;
                                                        const boundsWidth = maxX - minX + padding * 2;
                                                        const boundsHeight = maxY - minY + padding * 2;
                                                        const scaleX = container.clientWidth / boundsWidth;
                                                        const scaleY = container.clientHeight / boundsHeight;
                                                        const newZoom = clamp(Math.min(scaleX, scaleY), ZOOM_LIMITS.min, ZOOM_LIMITS.max);
                                                        setZoom(newZoom);
                                                        setPanOffset({
                                                            x: (container.clientWidth - boundsWidth * newZoom) / 2 - (minX - padding) * newZoom,
                                                            y: (container.clientHeight - boundsHeight * newZoom) / 2 - (minY - padding) * newZoom
                                                        });
                                                    }
                                                }}
                                            >
                                                Zoom to Selection
                                            </button>
                                        )}
                                    </CollapsibleSection>

                                    {/* Align & Distribute - only show when multiple items selected */}
                                    {selectedIds.length >= 2 && (
                                        <div className="p-3 border-b border-panel-border">
                                            <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-2">Align ({selectedIds.length} items)</div>
                                            <div className="grid grid-cols-6 gap-1 mb-2">
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Align Left"
                                                    onClick={() => {
                                                        const items = getSelectedItems();
                                                        const minX = Math.min(...items.map(i => i.x ?? i.x1 ?? 0));
                                                        applyToSelected(item => ({
                                                            ...(item.x !== undefined ? { x: minX } : {}),
                                                            ...(item.x1 !== undefined ? { x1: minX, x2: minX + (item.x2 - item.x1) } : {})
                                                        }));
                                                    }}
                                                >⬅</button>
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Align Center Horizontal"
                                                    onClick={() => {
                                                        const items = getSelectedItems();
                                                        const centers = items.map(i => (i.x ?? i.x1 ?? 0) + ((i.width ?? (i.x2 - i.x1) ?? 0) / 2));
                                                        const avgCenter = centers.reduce((a, b) => a + b, 0) / centers.length;
                                                        applyToSelected((item, idx) => {
                                                            const w = item.width ?? (item.x2 - item.x1) ?? 0;
                                                            return {
                                                                ...(item.x !== undefined ? { x: avgCenter - w / 2 } : {}),
                                                                ...(item.x1 !== undefined ? { x1: avgCenter - w / 2, x2: avgCenter + w / 2 } : {})
                                                            };
                                                        });
                                                    }}
                                                >⬌</button>
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Align Right"
                                                    onClick={() => {
                                                        const items = getSelectedItems();
                                                        const maxX = Math.max(...items.map(i => (i.x ?? i.x1 ?? 0) + (i.width ?? (i.x2 - i.x1) ?? 0)));
                                                        applyToSelected(item => {
                                                            const w = item.width ?? (item.x2 - item.x1) ?? 0;
                                                            return {
                                                                ...(item.x !== undefined ? { x: maxX - w } : {}),
                                                                ...(item.x1 !== undefined ? { x1: maxX - w, x2: maxX } : {})
                                                            };
                                                        });
                                                    }}
                                                >➡</button>
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Align Top"
                                                    onClick={() => {
                                                        const items = getSelectedItems();
                                                        const minY = Math.min(...items.map(i => i.y ?? i.y1 ?? 0));
                                                        applyToSelected(item => ({
                                                            ...(item.y !== undefined ? { y: minY } : {}),
                                                            ...(item.y1 !== undefined ? { y1: minY, y2: minY + (item.y2 - item.y1) } : {})
                                                        }));
                                                    }}
                                                >⬆</button>
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Align Center Vertical"
                                                    onClick={() => {
                                                        const items = getSelectedItems();
                                                        const centers = items.map(i => (i.y ?? i.y1 ?? 0) + ((i.height ?? (i.y2 - i.y1) ?? 0) / 2));
                                                        const avgCenter = centers.reduce((a, b) => a + b, 0) / centers.length;
                                                        applyToSelected(item => {
                                                            const h = item.height ?? (item.y2 - item.y1) ?? 0;
                                                            return {
                                                                ...(item.y !== undefined ? { y: avgCenter - h / 2 } : {}),
                                                                ...(item.y1 !== undefined ? { y1: avgCenter - h / 2, y2: avgCenter + h / 2 } : {})
                                                            };
                                                        });
                                                    }}
                                                >⬍</button>
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Align Bottom"
                                                    onClick={() => {
                                                        const items = getSelectedItems();
                                                        const maxY = Math.max(...items.map(i => (i.y ?? i.y1 ?? 0) + (i.height ?? (i.y2 - i.y1) ?? 0)));
                                                        applyToSelected(item => {
                                                            const h = item.height ?? (item.y2 - item.y1) ?? 0;
                                                            return {
                                                                ...(item.y !== undefined ? { y: maxY - h } : {}),
                                                                ...(item.y1 !== undefined ? { y1: maxY - h, y2: maxY } : {})
                                                            };
                                                        });
                                                    }}
                                                >⬇</button>
                                            </div>
                                            <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-1">Distribute</div>
                                            <div className="grid grid-cols-2 gap-1">
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Distribute Horizontally"
                                                    onClick={() => {
                                                        if (selectedIds.length < 3) return;
                                                        const items = getSelectedItems().sort((a, b) => (a.x ?? a.x1 ?? 0) - (b.x ?? b.x1 ?? 0));
                                                        const minX = items[0].x ?? items[0].x1 ?? 0;
                                                        const lastItem = items[items.length - 1];
                                                        const maxX = (lastItem.x ?? lastItem.x1 ?? 0) + (lastItem.width ?? (lastItem.x2 - lastItem.x1) ?? 0);
                                                        const totalWidth = items.reduce((sum, i) => sum + (i.width ?? (i.x2 - i.x1) ?? 20), 0);
                                                        const gap = (maxX - minX - totalWidth) / (items.length - 1);
                                                        let currentX = minX;
                                                        items.forEach((item, idx) => {
                                                            const w = item.width ?? (item.x2 - item.x1) ?? 20;
                                                            applyToSelectedById(item.id, item.type, {
                                                                ...(item.x !== undefined ? { x: currentX } : {}),
                                                                ...(item.x1 !== undefined ? { x1: currentX, x2: currentX + w } : {})
                                                            });
                                                            currentX += w + gap;
                                                        });
                                                    }}
                                                >↔ Horizontal</button>
                                                <button
                                                    className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded text-xs"
                                                    title="Distribute Vertically"
                                                    onClick={() => {
                                                        if (selectedIds.length < 3) return;
                                                        const items = getSelectedItems().sort((a, b) => (a.y ?? a.y1 ?? 0) - (b.y ?? b.y1 ?? 0));
                                                        const minY = items[0].y ?? items[0].y1 ?? 0;
                                                        const lastItem = items[items.length - 1];
                                                        const maxY = (lastItem.y ?? lastItem.y1 ?? 0) + (lastItem.height ?? (lastItem.y2 - lastItem.y1) ?? 0);
                                                        const totalHeight = items.reduce((sum, i) => sum + (i.height ?? (i.y2 - i.y1) ?? 20), 0);
                                                        const gap = (maxY - minY - totalHeight) / (items.length - 1);
                                                        let currentY = minY;
                                                        items.forEach((item, idx) => {
                                                            const h = item.height ?? (item.y2 - item.y1) ?? 20;
                                                            applyToSelectedById(item.id, item.type, {
                                                                ...(item.y !== undefined ? { y: currentY } : {}),
                                                                ...(item.y1 !== undefined ? { y1: currentY, y2: currentY + h } : {})
                                                            });
                                                            currentY += h + gap;
                                                        });
                                                    }}
                                                >↕ Vertical</button>
                                            </div>
                                        </div>
                                    )}

                                    {/* Style Settings */}
                                    <CollapsibleSection title="Style" collapsed={collapsedSections.style} onToggle={() => toggleSection('style')}>
                                        <div className="space-y-2">
                                            <div className="flex items-center gap-2">
                                                <label className="text-xs text-gray-400 w-14">Stroke</label>
                                                <input
                                                    type="color"
                                                    value={styles.stroke}
                                                    onChange={(e) => setStyles(prev => ({ ...prev, stroke: e.target.value }))}
                                                />
                                                <input
                                                    type="number"
                                                    value={styles.strokeWidth}
                                                    onChange={(e) => setStyles(prev => ({ ...prev, strokeWidth: parseFloat(e.target.value) }))}
                                                    className="w-14"
                                                    min="1"
                                                    max="20"
                                                />
                                            </div>
                                            <div className="flex items-center gap-2">
                                                <label className="text-xs text-gray-400 w-14">Fill</label>
                                                <input
                                                    type="color"
                                                    value={styles.fill === 'none' ? '#ffffff' : styles.fill}
                                                    onChange={(e) => setStyles(prev => ({ ...prev, fill: e.target.value }))}
                                                    disabled={styles.fill === 'none'}
                                                />
                                                <button
                                                    className={`px-2 py-0.5 text-xs rounded ${styles.fill === 'none' ? 'bg-accent text-white' : 'bg-gray-700 text-gray-300'}`}
                                                    onClick={() => setStyles(prev => ({ ...prev, fill: prev.fill === 'none' ? '#ffffff' : 'none' }))}
                                                >
                                                    None
                                                </button>
                                            </div>
                                        </div>
                                    </CollapsibleSection>
                                </div>
                            ) : leftPanelTab === 'library' ? (
                                <div className="flex-1 flex flex-col overflow-hidden">
                                    {/* Library Sub-tabs */}
                                    <div className="flex border-b border-panel-border bg-[#1a1a1a] text-xs">
                                        <button
                                            className={`flex-1 py-2 px-1 transition-colors ${librarySubTab === 'symbols' ? 'text-accent border-b-2 border-accent' : 'text-gray-500 hover:text-gray-300'}`}
                                            onClick={() => setLibrarySubTab('symbols')}
                                        >Symbols</button>
                                        <button
                                            className={`flex-1 py-2 px-1 transition-colors ${librarySubTab === 'snippets' ? 'text-accent border-b-2 border-accent' : 'text-gray-500 hover:text-gray-300'}`}
                                            onClick={() => setLibrarySubTab('snippets')}
                                        >Snippets</button>
                                        <button
                                            className={`flex-1 py-2 px-1 transition-colors ${librarySubTab === 'templates' ? 'text-accent border-b-2 border-accent' : 'text-gray-500 hover:text-gray-300'}`}
                                            onClick={() => setLibrarySubTab('templates')}
                                        >Templates</button>
                                        <button
                                            className={`flex-1 py-2 px-1 transition-colors ${librarySubTab === 'favorites' ? 'text-accent border-b-2 border-accent' : 'text-gray-500 hover:text-gray-300'}`}
                                            onClick={() => setLibrarySubTab('favorites')}
                                        >
                                            <span className="flex items-center justify-center gap-1">
                                                <Icons.Star /> {favorites.length}
                                            </span>
                                        </button>
                                    </div>
                                    {/* Library Sub-tab Content */}
                                    <div className="flex-1 overflow-y-auto">
                                        {librarySubTab === 'symbols' ? (
                                            <SymbolLibraryPanel
                                                selectedSymbolId={selectedSymbolId}
                                                onSelectSymbol={(id) => {
                                                    setSelectedSymbolId(id);
                                                    setCurrentTool(OPERATIONS.SYMBOL);
                                                }}
                                                symbolCategory={symbolCategory}
                                                onSetCategory={setSymbolCategory}
                                                favorites={favorites}
                                                onToggleFavorite={handleToggleFavorite}
                                            />
                                        ) : librarySubTab === 'snippets' ? (
                                            <SnippetLibrary
                                                library={snippetLibrary}
                                                onSaveSnippet={handleSaveToLibrary}
                                                onInsertSnippet={handleInsertFromLibrary}
                                                onDeleteFromLibrary={handleDeleteFromLibrary}
                                                currentSnippet={selectedSnippet}
                                            />
                                        ) : librarySubTab === 'templates' ? (
                                            <div className="p-3">
                                                <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-3">Element Templates</div>
                                                {templates.length > 0 ? (
                                                    <div className="space-y-2">
                                                        {templates.map(template => (
                                                            <div
                                                                key={template.id}
                                                                className="p-3 bg-gray-800 rounded-lg hover:bg-gray-700 cursor-pointer"
                                                                onClick={() => handleApplyTemplate(template)}
                                                            >
                                                                <div className="font-medium text-sm">{template.name}</div>
                                                                <div className="text-xs text-gray-400 mt-1">{template.description || `${template.elements?.length || 0} elements`}</div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <div className="text-center text-gray-500 py-8">
                                                        <p className="text-sm">No templates saved</p>
                                                        <p className="text-xs mt-1">Select elements and save as template</p>
                                                    </div>
                                                )}
                                                {selectedIds.length > 0 && (
                                                    <button
                                                        className="w-full mt-4 px-3 py-2 bg-accent/20 text-accent rounded hover:bg-accent/30 text-sm"
                                                        onClick={() => setShowTemplateDialog(true)}
                                                    >
                                                        Save Selection as Template
                                                    </button>
                                                )}
                                            </div>
                                        ) : librarySubTab === 'favorites' ? (
                                            <div className="p-3">
                                                <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-3">Favorite Symbols ({favorites.length})</div>
                                                {favorites.length > 0 ? (
                                                    <div className="grid grid-cols-3 gap-2">
                                                        {favorites.map(symbolId => {
                                                            const symbolDef = HV_SYMBOLS[symbolId];
                                                            if (!symbolDef) return null;
                                                            return (
                                                                <div
                                                                    key={symbolId}
                                                                    className={`p-2 rounded-lg cursor-pointer text-center transition-all ${selectedSymbolId === symbolId ? 'bg-accent/20 ring-2 ring-accent' : 'bg-gray-800 hover:bg-gray-700'}`}
                                                                    onClick={() => {
                                                                        setSelectedSymbolId(symbolId);
                                                                        setCurrentTool(OPERATIONS.SYMBOL);
                                                                    }}
                                                                >
                                                                    <div className="w-10 h-10 mx-auto text-accent" dangerouslySetInnerHTML={{ __html: symbolDef.svg }} />
                                                                    <div className="text-[10px] text-gray-400 mt-1 truncate">{symbolDef.name}</div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                ) : (
                                                    <div className="text-center text-gray-500 py-8">
                                                        <p className="text-sm">No favorites yet</p>
                                                        <p className="text-xs mt-1">Right-click symbols to add to favorites</p>
                                                    </div>
                                                )}
                                            </div>
                                        ) : null}
                                    </div>
                                </div>
                            ) : leftPanelTab === 'layers' ? (
                                <div className="flex-1 flex flex-col overflow-hidden">
                                    {/* Layers Sub-tabs */}
                                    <div className="flex border-b border-panel-border bg-[#1a1a1a] text-xs">
                                        <button
                                            className={`flex-1 py-2 px-2 transition-colors ${layersSubTab === 'layers' ? 'text-accent border-b-2 border-accent' : 'text-gray-500 hover:text-gray-300'}`}
                                            onClick={() => setLayersSubTab('layers')}
                                        >Layers</button>
                                        <button
                                            className={`flex-1 py-2 px-2 transition-colors ${layersSubTab === 'data' ? 'text-accent border-b-2 border-accent' : 'text-gray-500 hover:text-gray-300'}`}
                                            onClick={() => setLayersSubTab('data')}
                                        >Data View</button>
                                    </div>
                                    {/* Layers Sub-tab Content */}
                                    <div className="flex-1 overflow-y-auto">
                                        {layersSubTab === 'layers' ? (
                                            <LayerPanel
                                                snippets={snippets}
                                                masks={masks}
                                                elements={elements}
                                                infoPoints={infoPoints}
                                                symbols={symbols}
                                                measurements={measurements}
                                                bezierCurves={bezierCurves}
                                                cloudAnnotations={cloudAnnotations}
                                                leaderLines={leaderLines}
                                                selectedId={selectedId}
                                                onSelectItem={handleSelectItem}
                                                onDeleteItem={handleDeleteItem}
                                                onToggleVisibility={handleToggleVisibility}
                                            />
                                        ) : layersSubTab === 'data' ? (
                                            <InfoPointDataView
                                                infoPoints={infoPoints}
                                                onUpdateInfoPoint={handleUpdateInfoPoint}
                                                onSelectInfoPoint={(point) => {
                                                    setSelectedId(point.id);
                                                    setSelectedType('infoPoint');
                                                }}
                                            />
                                        ) : null}
                                    </div>
                                </div>
                            ) : leftPanelTab === 'pages' ? (
                                <div className="flex-1 overflow-y-auto p-3">
                                    <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-3">Page Thumbnails</div>
                                    {pdfData ? (
                                        <div className="space-y-2">
                                            {pdfData.pages.map((page, index) => (
                                                <div
                                                    key={index}
                                                    className={`cursor-pointer rounded-lg border-2 transition-all ${currentPage === index ? 'border-accent' : 'border-transparent hover:border-gray-600'}`}
                                                    onClick={() => setCurrentPage(index)}
                                                >
                                                    <div className="relative">
                                                        <img
                                                            src={page.imageData}
                                                            alt={`Page ${index + 1}`}
                                                            className="w-full rounded-md"
                                                            style={{ maxHeight: '150px', objectFit: 'contain', backgroundColor: '#fff' }}
                                                        />
                                                        <div className={`absolute bottom-0 left-0 right-0 text-center py-1 text-xs rounded-b-md ${currentPage === index ? 'bg-accent text-white' : 'bg-gray-800 text-gray-300'}`}>
                                                            Page {index + 1} of {pdfData.pages.length}
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    ) : (
                                        <div className="text-center text-gray-500 py-8">
                                            <div className="w-12 h-12 mx-auto mb-2 text-gray-600">
                                                <Icons.Pages />
                                            </div>
                                            <p className="text-sm">No document loaded</p>
                                            <p className="text-xs mt-1">Load a PDF to see page thumbnails</p>
                                        </div>
                                    )}
                                </div>
                            ) : null}
                        </aside>

                        {/* Left Resize Handle */}
                        <div
                            className={`w-1.5 cursor-col-resize flex-shrink-0 transition-colors ${isResizingLeft ? 'bg-accent' : 'bg-panel-border hover:bg-accent/70'}`}
                            onMouseDown={() => setIsResizingLeft(true)}
                            title="Drag to resize"
                        />

                        {/* Canvas Area */}
                        <main className="flex-1 flex flex-col overflow-hidden">
                            {/* Canvas Container */}
                            <div
                                ref={containerRef}
                                className={`flex-1 canvas-container overflow-hidden cursor-${isPanning ? 'grabbing' : currentTool === OPERATIONS.SELECT ? 'default' : 'crosshair'} drop-zone`}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                                onContextMenu={handleContextMenu}
                                onDoubleClick={(e) => {
                                    // Double-click to finish polyline
                                    if (currentTool === OPERATIONS.POLYLINE && polylinePoints.length >= 2) {
                                        const newPolyline = {
                                            id: generateId(),
                                            type: 'polyline',
                                            name: `Polyline ${elements.length + 1}`,
                                            points: [...polylinePoints],
                                            stroke: styles.stroke,
                                            strokeWidth: styles.strokeWidth,
                                            visible: true,
                                            locked: false
                                        };
                                        setElements(prev => [...prev, newPolyline]);
                                        setSelectedId(newPolyline.id);
                                        setSelectedType('element');
                                        history.push({ snippets, masks, elements: [...elements, newPolyline], infoPoints, symbols, measurements, cableAnnotations });
                                        setPolylinePoints([]);
                                    }
                                }}
                                onWheel={handleWheel}
                                onDrop={handleDrop}
                                onDragOver={handleDragOver}
                            >
                                {loading ? (
                                    <div className="absolute inset-0 flex items-center justify-center">
                                        <div className="text-center">
                                            <div className="w-12 h-12 border-4 border-accent border-t-transparent rounded-full spinner mx-auto mb-4" />
                                            <div className="text-gray-400">Loading file...</div>
                                        </div>
                                    </div>
                                ) : !pdfData ? (
                                    <div className="absolute inset-0 flex items-center justify-center">
                                        <div 
                                            className="text-center p-8 border-2 border-dashed border-gray-600 rounded-xl hover:border-accent transition-colors cursor-pointer"
                                            onClick={() => fileInputRef.current?.click()}
                                        >
                                            <div className="w-16 h-16 mx-auto mb-4 text-gray-500">
                                                <Icons.Upload />
                                            </div>
                                            <div className="text-xl text-gray-300 mb-2">Drop PDF or image here</div>
                                            <div className="text-sm text-gray-500">or click to browse</div>
                                        </div>
                                    </div>
                                ) : (
                                    <div
                                        style={{
                                            transform: `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoom})`,
                                            transformOrigin: '0 0',
                                            position: 'relative',
                                            width: currentPageData?.width || 0,
                                            height: currentPageData?.height || 0
                                        }}
                                    >
                                        {/* PDF Base Layer */}
                                        {currentPageData && (
                                            <img
                                                src={currentPageData.imageData}
                                                alt="PDF Page"
                                                style={{
                                                    position: 'absolute',
                                                    top: 0,
                                                    left: 0,
                                                    width: currentPageData.width,
                                                    height: currentPageData.height,
                                                    zIndex: LAYERS.PDF_BASE
                                                }}
                                                draggable={false}
                                            />
                                        )}
                                        
                                        {/* SVG Overlay for all drawn elements */}
                                        <svg
                                            style={{
                                                position: 'absolute',
                                                top: 0,
                                                left: 0,
                                                width: currentPageData?.width || 0,
                                                height: currentPageData?.height || 0,
                                                zIndex: LAYERS.ELEMENTS,
                                                pointerEvents: 'none'
                                            }}
                                        >
                                            {/* Pattern Definitions for Fill Patterns */}
                                            <defs>
                                                {/* Arrow Markers for Arrow Tool */}
                                                <marker
                                                    id="arrowhead-end"
                                                    markerWidth="10"
                                                    markerHeight="7"
                                                    refX="9"
                                                    refY="3.5"
                                                    orient="auto"
                                                    markerUnits="strokeWidth"
                                                >
                                                    <polygon points="0 0, 10 3.5, 0 7" fill="currentColor" />
                                                </marker>
                                                <marker
                                                    id="arrowhead-start"
                                                    markerWidth="10"
                                                    markerHeight="7"
                                                    refX="1"
                                                    refY="3.5"
                                                    orient="auto"
                                                    markerUnits="strokeWidth"
                                                >
                                                    <polygon points="10 0, 0 3.5, 10 7" fill="currentColor" />
                                                </marker>

                                                {/* Hatch Pattern - diagonal lines (sand/granular) */}
                                                <pattern id="pattern-hatch" patternUnits="userSpaceOnUse" width="8" height="8" patternTransform="rotate(45)">
                                                    <line x1="0" y1="0" x2="0" y2="8" stroke="#000" strokeWidth="1.5" opacity="0.4"/>
                                                </pattern>

                                                {/* Crosshatch Pattern - grid (concrete/CBS) */}
                                                <pattern id="pattern-crosshatch" patternUnits="userSpaceOnUse" width="10" height="10">
                                                    <line x1="0" y1="0" x2="10" y2="10" stroke="#000" strokeWidth="1" opacity="0.35"/>
                                                    <line x1="10" y1="0" x2="0" y2="10" stroke="#000" strokeWidth="1" opacity="0.35"/>
                                                </pattern>

                                                {/* Dots Pattern (gravel/aggregate) */}
                                                <pattern id="pattern-dots" patternUnits="userSpaceOnUse" width="8" height="8">
                                                    <circle cx="4" cy="4" r="2" fill="#000" opacity="0.35"/>
                                                </pattern>

                                                {/* Horizontal Lines (clay/soil layers) */}
                                                <pattern id="pattern-horizontal" patternUnits="userSpaceOnUse" width="10" height="6">
                                                    <line x1="0" y1="3" x2="10" y2="3" stroke="#000" strokeWidth="1.5" opacity="0.35"/>
                                                </pattern>

                                                {/* Vertical Lines (backfill) */}
                                                <pattern id="pattern-vertical" patternUnits="userSpaceOnUse" width="6" height="10">
                                                    <line x1="3" y1="0" x2="3" y2="10" stroke="#000" strokeWidth="1.5" opacity="0.35"/>
                                                </pattern>

                                                {/* Brick Pattern (masonry/tiles) */}
                                                <pattern id="pattern-brick" patternUnits="userSpaceOnUse" width="16" height="10">
                                                    <rect x="0" y="0" width="16" height="10" fill="none" stroke="#000" strokeWidth="1" opacity="0.4"/>
                                                    <line x1="8" y1="0" x2="8" y2="5" stroke="#000" strokeWidth="1" opacity="0.4"/>
                                                    <line x1="0" y1="5" x2="16" y2="5" stroke="#000" strokeWidth="1" opacity="0.4"/>
                                                </pattern>

                                                {/* Wave Pattern (water/fluid) */}
                                                <pattern id="pattern-wave" patternUnits="userSpaceOnUse" width="20" height="10">
                                                    <path d="M0,5 Q5,0 10,5 T20,5" fill="none" stroke="#0066aa" strokeWidth="1.5" opacity="0.5"/>
                                                </pattern>

                                                {/* Cable Core Pattern - concentric circles */}
                                                <pattern id="pattern-cable" patternUnits="userSpaceOnUse" width="20" height="20">
                                                    <circle cx="10" cy="10" r="8" fill="#333" opacity="0.3"/>
                                                    <circle cx="10" cy="10" r="5" fill="#666" opacity="0.5"/>
                                                    <circle cx="10" cy="10" r="2" fill="#c00" opacity="0.9"/>
                                                </pattern>

                                                {/* Duct Pattern - empty circles */}
                                                <pattern id="pattern-duct" patternUnits="userSpaceOnUse" width="20" height="20">
                                                    <circle cx="10" cy="10" r="7" fill="none" stroke="#333" strokeWidth="2" opacity="0.5"/>
                                                </pattern>
                                            </defs>

                                            {/* Grid */}
                                            {showGrid && currentPageData && (
                                                <g opacity="0.3">
                                                    {Array.from({ length: Math.ceil(currentPageData.width / GRID_SIZE) + 1 }).map((_, i) => (
                                                        <line
                                                            key={`v-${i}`}
                                                            x1={i * GRID_SIZE}
                                                            y1={0}
                                                            x2={i * GRID_SIZE}
                                                            y2={currentPageData.height}
                                                            stroke="#404040"
                                                            strokeWidth={0.5 / zoom}
                                                        />
                                                    ))}
                                                    {Array.from({ length: Math.ceil(currentPageData.height / GRID_SIZE) + 1 }).map((_, i) => (
                                                        <line
                                                            key={`h-${i}`}
                                                            x1={0}
                                                            y1={i * GRID_SIZE}
                                                            x2={currentPageData.width}
                                                            y2={i * GRID_SIZE}
                                                            stroke="#404040"
                                                            strokeWidth={0.5 / zoom}
                                                        />
                                                    ))}
                                                </g>
                                            )}
                                            
                                            {/* Masks */}
                                            {masks.filter(m => m.visible !== false).map(mask => {
                                                const maskRotation = mask.rotation || 0;
                                                const maskCenterX = mask.x + mask.width / 2;
                                                const maskCenterY = mask.y + mask.height / 2;
                                                return (
                                                    <rect
                                                        key={mask.id}
                                                        x={mask.x}
                                                        y={mask.y}
                                                        width={mask.width}
                                                        height={mask.height}
                                                        fill={mask.fill || '#ffffff'}
                                                        stroke={selectedId === mask.id ? '#0ea5e9' : 'none'}
                                                        strokeWidth={selectedId === mask.id ? 2 / zoom : 0}
                                                        strokeDasharray={selectedId === mask.id ? `${4 / zoom}` : 'none'}
                                                        style={{ zIndex: LAYERS.MASKS }}
                                                        transform={maskRotation ? `rotate(${maskRotation} ${maskCenterX} ${maskCenterY})` : undefined}
                                                    />
                                                );
                                            })}

                                            {/* Image Overlays */}
                                            {imageOverlays.filter(img => img.visible !== false).map(overlay => {
                                                const isSelected = selectedId === overlay.id;
                                                return (
                                                    <g key={overlay.id} style={{ cursor: currentTool === OPERATIONS.SELECT ? 'pointer' : 'default' }}>
                                                        <image
                                                            href={overlay.imageData}
                                                            x={overlay.x}
                                                            y={overlay.y}
                                                            width={overlay.width}
                                                            height={overlay.height}
                                                            opacity={overlay.opacity || 1}
                                                            preserveAspectRatio="none"
                                                        />
                                                        {isSelected && (
                                                            <rect
                                                                x={overlay.x - 2}
                                                                y={overlay.y - 2}
                                                                width={overlay.width + 4}
                                                                height={overlay.height + 4}
                                                                fill="none"
                                                                stroke="#0ea5e9"
                                                                strokeWidth={2 / zoom}
                                                                strokeDasharray={`${4 / zoom}`}
                                                            />
                                                        )}
                                                    </g>
                                                );
                                            })}

                                            {/* Elements */}
                                            {elements.filter(e => e.visible !== false).map(element => {
                                                const isSelected = selectedId === element.id || selectedIds.some(s => s.id === element.id && s.type === 'element');
                                                const hasPattern = element.fillPattern && element.fillPattern !== 'solid';
                                                const fillOpacity = element.fillOpacity || 1;
                                                const rotation = element.rotation || 0;

                                                switch (element.type) {
                                                    case 'rectangle':
                                                        const rectCenterX = element.x + element.width / 2;
                                                        const rectCenterY = element.y + element.height / 2;
                                                        return (
                                                            <g key={element.id} transform={rotation ? `rotate(${rotation} ${rectCenterX} ${rectCenterY})` : undefined}>
                                                                {/* Base fill */}
                                                                <rect
                                                                    x={element.x}
                                                                    y={element.y}
                                                                    width={element.width}
                                                                    height={element.height}
                                                                    fill={element.fill === 'none' ? 'transparent' : element.fill}
                                                                    fillOpacity={fillOpacity}
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                />
                                                                {/* Pattern overlay */}
                                                                {hasPattern && (
                                                                    <rect
                                                                        x={element.x}
                                                                        y={element.y}
                                                                        width={element.width}
                                                                        height={element.height}
                                                                        fill={`url(#pattern-${element.fillPattern})`}
                                                                        stroke="none"
                                                                    />
                                                                )}
                                                                {isSelected && (
                                                                    <>
                                                                        <rect
                                                                            x={element.x - 2}
                                                                            y={element.y - 2}
                                                                            width={element.width + 4}
                                                                            height={element.height + 4}
                                                                            fill="none"
                                                                            stroke="#0ea5e9"
                                                                            strokeWidth={2 / zoom}
                                                                            strokeDasharray={`${4 / zoom}`}
                                                                        />
                                                                        {/* Rotation handle */}
                                                                        <line
                                                                            x1={rectCenterX}
                                                                            y1={element.y - 2}
                                                                            x2={rectCenterX}
                                                                            y2={element.y - 20}
                                                                            stroke="#0ea5e9"
                                                                            strokeWidth={2 / zoom}
                                                                        />
                                                                        <circle
                                                                            cx={rectCenterX}
                                                                            cy={element.y - 20}
                                                                            r={6 / zoom}
                                                                            fill="#0ea5e9"
                                                                            stroke="#fff"
                                                                            strokeWidth={1 / zoom}
                                                                            style={{ cursor: 'grab' }}
                                                                        />
                                                                    </>
                                                                )}
                                                                {/* Lock indicator */}
                                                                {element.locked && (
                                                                    <g transform={`translate(${element.x + element.width - 12}, ${element.y + 4})`}>
                                                                        <circle r={8} fill="rgba(234, 179, 8, 0.9)" />
                                                                        <text x={0} y={4} textAnchor="middle" fontSize={10} fill="#000">🔒</text>
                                                                    </g>
                                                                )}
                                                            </g>
                                                        );
                                                    case 'circle':
                                                        return (
                                                            <g key={element.id} transform={rotation ? `rotate(${rotation} ${element.x} ${element.y})` : undefined}>
                                                                {/* Base fill */}
                                                                <circle
                                                                    cx={element.x}
                                                                    cy={element.y}
                                                                    r={element.radius}
                                                                    fill={element.fill === 'none' ? 'transparent' : element.fill}
                                                                    fillOpacity={fillOpacity}
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                />
                                                                {/* Pattern overlay */}
                                                                {hasPattern && (
                                                                    <circle
                                                                        cx={element.x}
                                                                        cy={element.y}
                                                                        r={element.radius}
                                                                        fill={`url(#pattern-${element.fillPattern})`}
                                                                        stroke="none"
                                                                    />
                                                                )}
                                                                {isSelected && (
                                                                    <circle
                                                                        cx={element.x}
                                                                        cy={element.y}
                                                                        r={element.radius + 3}
                                                                        fill="none"
                                                                        stroke="#0ea5e9"
                                                                        strokeWidth={2 / zoom}
                                                                        strokeDasharray={`${4 / zoom}`}
                                                                    />
                                                                )}
                                                            </g>
                                                        );
                                                    case 'line':
                                                        return (
                                                            <g key={element.id}>
                                                                <line
                                                                    x1={element.x1}
                                                                    y1={element.y1}
                                                                    x2={element.x2}
                                                                    y2={element.y2}
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                />
                                                                {isSelected && (
                                                                    <>
                                                                        <circle cx={element.x1} cy={element.y1} r={4 / zoom} fill="#0ea5e9" />
                                                                        <circle cx={element.x2} cy={element.y2} r={4 / zoom} fill="#0ea5e9" />
                                                                    </>
                                                                )}
                                                            </g>
                                                        );
                                                    case 'arrow':
                                                        return (
                                                            <g key={element.id} style={{ color: element.stroke }}>
                                                                <line
                                                                    x1={element.x1}
                                                                    y1={element.y1}
                                                                    x2={element.x2}
                                                                    y2={element.y2}
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                    markerEnd={element.arrowEnd !== false ? "url(#arrowhead-end)" : undefined}
                                                                    markerStart={element.arrowStart ? "url(#arrowhead-start)" : undefined}
                                                                />
                                                                {isSelected && (
                                                                    <>
                                                                        <circle cx={element.x1} cy={element.y1} r={4 / zoom} fill="#0ea5e9" />
                                                                        <circle cx={element.x2} cy={element.y2} r={4 / zoom} fill="#0ea5e9" />
                                                                    </>
                                                                )}
                                                            </g>
                                                        );
                                                    case 'text':
                                                        const textRotation = element.rotation || 0;
                                                        const textCenterX = element.x + (element.width || 100) / 2;
                                                        const textCenterY = element.y + (element.height || 20) / 2;
                                                        return (
                                                            <g key={element.id} transform={textRotation ? `rotate(${textRotation} ${textCenterX} ${textCenterY})` : undefined}>
                                                                {/* Background */}
                                                                {element.backgroundColor && element.backgroundColor !== 'transparent' && (
                                                                    <rect
                                                                        x={element.x - (element.padding || 4)}
                                                                        y={element.y - (element.padding || 4)}
                                                                        width={(element.width || 100) + (element.padding || 4) * 2}
                                                                        height={(element.height || 20) + (element.padding || 4) * 2}
                                                                        fill={element.backgroundColor}
                                                                        rx={2}
                                                                    />
                                                                )}
                                                                {/* Text */}
                                                                <text
                                                                    x={element.x}
                                                                    y={element.y + (element.fontSize || 14)}
                                                                    fill={element.color || '#000000'}
                                                                    fontSize={element.fontSize || 14}
                                                                    fontFamily={element.fontFamily || 'Arial'}
                                                                    style={{ userSelect: 'none' }}
                                                                >
                                                                    {element.content || ''}
                                                                </text>
                                                                {/* Selection border */}
                                                                {isSelected && (
                                                                    <rect
                                                                        x={element.x - 2}
                                                                        y={element.y - 2}
                                                                        width={(element.width || 100) + 4}
                                                                        height={(element.height || 20) + 4}
                                                                        fill="none"
                                                                        stroke="#0ea5e9"
                                                                        strokeWidth={2 / zoom}
                                                                        strokeDasharray={`${4 / zoom}`}
                                                                    />
                                                                )}
                                                            </g>
                                                        );
                                                    case 'polyline':
                                                        if (!element.points || element.points.length < 2) return null;
                                                        const polylinePathData = element.points.map((p, i) =>
                                                            (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y
                                                        ).join(' ');
                                                        return (
                                                            <g key={element.id}>
                                                                <path
                                                                    d={polylinePathData}
                                                                    fill="none"
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                    strokeLinecap="round"
                                                                    strokeLinejoin="round"
                                                                />
                                                                {isSelected && element.points.map((p, i) => (
                                                                    <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill="#0ea5e9" />
                                                                ))}
                                                            </g>
                                                        );
                                                    case 'freehand':
                                                        if (!element.points || element.points.length < 2) return null;
                                                        const freehandPathData = element.points.map((p, i) =>
                                                            (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y
                                                        ).join(' ');
                                                        return (
                                                            <g key={element.id}>
                                                                <path
                                                                    d={freehandPathData}
                                                                    fill="none"
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                    strokeLinecap="round"
                                                                    strokeLinejoin="round"
                                                                />
                                                                {isSelected && (
                                                                    <>
                                                                        <circle cx={element.points[0].x} cy={element.points[0].y} r={4 / zoom} fill="#0ea5e9" />
                                                                        <circle cx={element.points[element.points.length - 1].x} cy={element.points[element.points.length - 1].y} r={4 / zoom} fill="#0ea5e9" />
                                                                    </>
                                                                )}
                                                            </g>
                                                        );
                                                    case 'callout':
                                                        const calloutRotation = element.rotation || 0;
                                                        const calloutCenterX = element.x + element.width / 2;
                                                        const calloutCenterY = element.y + element.height / 2;
                                                        const pDir = element.pointerDirection || 'bottom';
                                                        const pPos = element.pointerPosition || 50;
                                                        const pLen = element.pointerLength || 20;

                                                        // Calculate pointer path based on direction
                                                        let pointerPath = '';
                                                        const px = element.x + (element.width * pPos / 100);
                                                        const py = element.y + (element.height * pPos / 100);
                                                        if (pDir === 'bottom') {
                                                            pointerPath = `M${px - 10},${element.y + element.height} L${px},${element.y + element.height + pLen} L${px + 10},${element.y + element.height}`;
                                                        } else if (pDir === 'top') {
                                                            pointerPath = `M${px - 10},${element.y} L${px},${element.y - pLen} L${px + 10},${element.y}`;
                                                        } else if (pDir === 'left') {
                                                            const leftPy = element.y + (element.height * pPos / 100);
                                                            pointerPath = `M${element.x},${leftPy - 10} L${element.x - pLen},${leftPy} L${element.x},${leftPy + 10}`;
                                                        } else if (pDir === 'right') {
                                                            const rightPy = element.y + (element.height * pPos / 100);
                                                            pointerPath = `M${element.x + element.width},${rightPy - 10} L${element.x + element.width + pLen},${rightPy} L${element.x + element.width},${rightPy + 10}`;
                                                        }

                                                        return (
                                                            <g key={element.id} transform={calloutRotation ? `rotate(${calloutRotation} ${calloutCenterX} ${calloutCenterY})` : undefined}>
                                                                {/* Callout box */}
                                                                <rect
                                                                    x={element.x}
                                                                    y={element.y}
                                                                    width={element.width}
                                                                    height={element.height}
                                                                    fill={element.backgroundColor || '#fffde7'}
                                                                    stroke={element.borderColor || '#fbc02d'}
                                                                    strokeWidth={2}
                                                                    rx={6}
                                                                />
                                                                {/* Pointer */}
                                                                <path
                                                                    d={pointerPath}
                                                                    fill={element.backgroundColor || '#fffde7'}
                                                                    stroke={element.borderColor || '#fbc02d'}
                                                                    strokeWidth={2}
                                                                    strokeLinejoin="round"
                                                                />
                                                                {/* Text content */}
                                                                <text
                                                                    x={element.x + element.width / 2}
                                                                    y={element.y + element.height / 2 + (element.fontSize || 12) / 3}
                                                                    fill={element.color || '#000000'}
                                                                    fontSize={element.fontSize || 12}
                                                                    fontFamily="Arial"
                                                                    textAnchor="middle"
                                                                    style={{ userSelect: 'none' }}
                                                                >
                                                                    {element.content || ''}
                                                                </text>
                                                                {/* Selection border */}
                                                                {isSelected && (
                                                                    <rect
                                                                        x={element.x - 2}
                                                                        y={element.y - 2}
                                                                        width={element.width + 4}
                                                                        height={element.height + 4}
                                                                        fill="none"
                                                                        stroke="#0ea5e9"
                                                                        strokeWidth={2 / zoom}
                                                                        strokeDasharray={`${4 / zoom}`}
                                                                    />
                                                                )}
                                                            </g>
                                                        );
                                                    case 'dimension':
                                                        // Calculate dimension line geometry
                                                        const dimAngle = Math.atan2(element.y2 - element.y1, element.x2 - element.x1);
                                                        const perpAngle = dimAngle + Math.PI / 2;
                                                        const extLen = element.extensionLength || 15;
                                                        const textOff = element.textOffset || 10;

                                                        // Extension lines (perpendicular to main line)
                                                        const ext1X1 = element.x1;
                                                        const ext1Y1 = element.y1;
                                                        const ext1X2 = element.x1 + Math.cos(perpAngle) * extLen;
                                                        const ext1Y2 = element.y1 + Math.sin(perpAngle) * extLen;
                                                        const ext2X1 = element.x2;
                                                        const ext2Y1 = element.y2;
                                                        const ext2X2 = element.x2 + Math.cos(perpAngle) * extLen;
                                                        const ext2Y2 = element.y2 + Math.sin(perpAngle) * extLen;

                                                        // Dimension line (offset from main line)
                                                        const dimLineOffset = extLen - 3;
                                                        const dimX1 = element.x1 + Math.cos(perpAngle) * dimLineOffset;
                                                        const dimY1 = element.y1 + Math.sin(perpAngle) * dimLineOffset;
                                                        const dimX2 = element.x2 + Math.cos(perpAngle) * dimLineOffset;
                                                        const dimY2 = element.y2 + Math.sin(perpAngle) * dimLineOffset;

                                                        // Text position (center of dimension line)
                                                        const textX = (dimX1 + dimX2) / 2;
                                                        const textY = (dimY1 + dimY2) / 2;

                                                        // Display value
                                                        const displayValue = element.realDistance
                                                            ? `${element.realDistance.toFixed(2)} ${element.unit}`
                                                            : `${element.pixelDistance?.toFixed(0) || 0} px`;

                                                        // Text rotation for readability
                                                        let dimTextRotation = (dimAngle * 180 / Math.PI);
                                                        if (dimTextRotation > 90 || dimTextRotation < -90) dimTextRotation += 180;

                                                        return (
                                                            <g key={element.id} style={{ color: element.color }}>
                                                                {/* Extension lines */}
                                                                <line
                                                                    x1={ext1X1} y1={ext1Y1} x2={ext1X2} y2={ext1Y2}
                                                                    stroke={element.color || '#000'}
                                                                    strokeWidth={1}
                                                                />
                                                                <line
                                                                    x1={ext2X1} y1={ext2Y1} x2={ext2X2} y2={ext2Y2}
                                                                    stroke={element.color || '#000'}
                                                                    strokeWidth={1}
                                                                />
                                                                {/* Dimension line with arrowheads */}
                                                                <line
                                                                    x1={dimX1} y1={dimY1} x2={dimX2} y2={dimY2}
                                                                    stroke={element.color || '#000'}
                                                                    strokeWidth={1}
                                                                    markerStart="url(#arrowhead-start)"
                                                                    markerEnd="url(#arrowhead-end)"
                                                                />
                                                                {/* Text background */}
                                                                <rect
                                                                    x={textX - 25}
                                                                    y={textY - 8}
                                                                    width={50}
                                                                    height={16}
                                                                    fill="white"
                                                                    transform={`rotate(${dimTextRotation} ${textX} ${textY})`}
                                                                />
                                                                {/* Dimension text */}
                                                                <text
                                                                    x={textX}
                                                                    y={textY + 4}
                                                                    fill={element.color || '#000'}
                                                                    fontSize={element.fontSize || 12}
                                                                    textAnchor="middle"
                                                                    transform={`rotate(${dimTextRotation} ${textX} ${textY})`}
                                                                    style={{ userSelect: 'none' }}
                                                                >
                                                                    {displayValue}
                                                                </text>
                                                                {/* Selection indicators */}
                                                                {isSelected && (
                                                                    <>
                                                                        <circle cx={element.x1} cy={element.y1} r={4 / zoom} fill="#0ea5e9" />
                                                                        <circle cx={element.x2} cy={element.y2} r={4 / zoom} fill="#0ea5e9" />
                                                                    </>
                                                                )}
                                                            </g>
                                                        );
                                                    case 'polygon':
                                                        if (!element.points || element.points.length < 3) return null;
                                                        const polygonPathData = element.points.map((p, i) =>
                                                            (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y
                                                        ).join(' ') + ' Z';
                                                        return (
                                                            <g key={element.id}>
                                                                <path
                                                                    d={polygonPathData}
                                                                    fill={element.fill === 'none' ? 'transparent' : element.fill}
                                                                    fillOpacity={element.fillOpacity || 0.3}
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                    strokeLinejoin="round"
                                                                />
                                                                {isSelected && element.points.map((p, i) => (
                                                                    <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill="#0ea5e9" />
                                                                ))}
                                                            </g>
                                                        );
                                                    case 'arc':
                                                        const arcPath = `M ${element.x1} ${element.y1} Q ${element.cx} ${element.cy} ${element.x2} ${element.y2}`;
                                                        return (
                                                            <g key={element.id}>
                                                                <path
                                                                    d={arcPath}
                                                                    fill="none"
                                                                    stroke={element.stroke}
                                                                    strokeWidth={element.strokeWidth}
                                                                    strokeLinecap="round"
                                                                />
                                                                {isSelected && (
                                                                    <>
                                                                        <circle cx={element.x1} cy={element.y1} r={4 / zoom} fill="#0ea5e9" />
                                                                        <circle cx={element.cx} cy={element.cy} r={4 / zoom} fill="#22c55e" />
                                                                        <circle cx={element.x2} cy={element.y2} r={4 / zoom} fill="#0ea5e9" />
                                                                    </>
                                                                )}
                                                            </g>
                                                        );
                                                    case 'area':
                                                        if (!element.points || element.points.length < 3) return null;
                                                        const areaPathData = element.points.map((p, i) =>
                                                            (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y
                                                        ).join(' ') + ' Z';
                                                        // Calculate centroid for label placement
                                                        const areaCentroidX = element.points.reduce((sum, p) => sum + p.x, 0) / element.points.length;
                                                        const areaCentroidY = element.points.reduce((sum, p) => sum + p.y, 0) / element.points.length;
                                                        // Display value
                                                        const areaDisplayValue = element.realArea
                                                            ? `${element.realArea.toFixed(2)} ${element.unit}²`
                                                            : `${element.pixelArea?.toFixed(0) || 0} px²`;
                                                        return (
                                                            <g key={element.id}>
                                                                <path
                                                                    d={areaPathData}
                                                                    fill={element.fill || '#22c55e'}
                                                                    fillOpacity={element.fillOpacity || 0.15}
                                                                    stroke={element.stroke || '#22c55e'}
                                                                    strokeWidth={element.strokeWidth || 2}
                                                                    strokeLinejoin="round"
                                                                />
                                                                {/* Area label */}
                                                                <rect
                                                                    x={areaCentroidX - 40}
                                                                    y={areaCentroidY - 10}
                                                                    width={80}
                                                                    height={20}
                                                                    fill="white"
                                                                    fillOpacity={0.9}
                                                                    rx={4}
                                                                />
                                                                <text
                                                                    x={areaCentroidX}
                                                                    y={areaCentroidY + 5}
                                                                    fill={element.stroke || '#22c55e'}
                                                                    fontSize={element.fontSize || 12}
                                                                    fontWeight="bold"
                                                                    textAnchor="middle"
                                                                    style={{ userSelect: 'none' }}
                                                                >
                                                                    {areaDisplayValue}
                                                                </text>
                                                                {/* Selection indicators */}
                                                                {isSelected && element.points.map((p, i) => (
                                                                    <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill="#22c55e" />
                                                                ))}
                                                            </g>
                                                        );
                                                    default:
                                                        return null;
                                                }
                                            })}

                                            {/* Bezier Curves */}
                                            {bezierCurves.filter(b => b.visible !== false).map(bezier => {
                                                const isSelected = selectedId === bezier.id || selectedIds.some(s => s.id === bezier.id && s.type === 'bezier');
                                                const [p0, p1, p2, p3] = bezier.points;
                                                const pathD = `M ${p0.x} ${p0.y} C ${p1.x} ${p1.y}, ${p2.x} ${p2.y}, ${p3.x} ${p3.y}`;
                                                return (
                                                    <g key={bezier.id} style={{ cursor: currentTool === OPERATIONS.SELECT ? 'pointer' : 'default' }}>
                                                        <path
                                                            d={pathD}
                                                            fill={bezier.fill || 'none'}
                                                            stroke={bezier.stroke}
                                                            strokeWidth={bezier.strokeWidth}
                                                            strokeLinecap="round"
                                                        />
                                                        {isSelected && (
                                                            <>
                                                                {/* Control point handles */}
                                                                <line x1={p0.x} y1={p0.y} x2={p1.x} y2={p1.y} stroke="#0ea5e9" strokeWidth={1 / zoom} strokeDasharray={`${3 / zoom}`} />
                                                                <line x1={p3.x} y1={p3.y} x2={p2.x} y2={p2.y} stroke="#0ea5e9" strokeWidth={1 / zoom} strokeDasharray={`${3 / zoom}`} />
                                                                <circle cx={p0.x} cy={p0.y} r={5 / zoom} fill="#0ea5e9" stroke="#fff" strokeWidth={1 / zoom} />
                                                                <circle cx={p1.x} cy={p1.y} r={4 / zoom} fill="#fff" stroke="#0ea5e9" strokeWidth={1 / zoom} />
                                                                <circle cx={p2.x} cy={p2.y} r={4 / zoom} fill="#fff" stroke="#0ea5e9" strokeWidth={1 / zoom} />
                                                                <circle cx={p3.x} cy={p3.y} r={5 / zoom} fill="#0ea5e9" stroke="#fff" strokeWidth={1 / zoom} />
                                                            </>
                                                        )}
                                                    </g>
                                                );
                                            })}

                                            {/* Cloud Annotations */}
                                            {cloudAnnotations.filter(c => c.visible !== false).map(cloud => {
                                                const isSelected = selectedId === cloud.id || selectedIds.some(s => s.id === cloud.id && s.type === 'cloud');
                                                // Generate cloud path with bumpy edges
                                                const points = cloud.points;
                                                if (points.length < 3) return null;

                                                // Create cloud bumps along the polygon edges
                                                let pathParts = [];
                                                for (let i = 0; i < points.length; i++) {
                                                    const curr = points[i];
                                                    const next = points[(i + 1) % points.length];
                                                    const dx = next.x - curr.x;
                                                    const dy = next.y - curr.y;
                                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                                    const numBumps = Math.max(2, Math.floor(dist / 20));

                                                    for (let j = 0; j < numBumps; j++) {
                                                        const t1 = j / numBumps;
                                                        const t2 = (j + 1) / numBumps;
                                                        const x1 = curr.x + dx * t1;
                                                        const y1 = curr.y + dy * t1;
                                                        const x2 = curr.x + dx * t2;
                                                        const y2 = curr.y + dy * t2;
                                                        const mx = (x1 + x2) / 2;
                                                        const my = (y1 + y2) / 2;
                                                        // Outward bump
                                                        const nx = -dy / dist * 8;
                                                        const ny = dx / dist * 8;
                                                        if (i === 0 && j === 0) {
                                                            pathParts.push(`M ${x1} ${y1}`);
                                                        }
                                                        pathParts.push(`Q ${mx + nx} ${my + ny}, ${x2} ${y2}`);
                                                    }
                                                }
                                                const pathD = pathParts.join(' ') + ' Z';

                                                return (
                                                    <g key={cloud.id} style={{ cursor: currentTool === OPERATIONS.SELECT ? 'pointer' : 'default' }}>
                                                        <path
                                                            d={pathD}
                                                            fill={cloud.fill || 'rgba(255, 200, 200, 0.2)'}
                                                            stroke={cloud.stroke || '#ef4444'}
                                                            strokeWidth={cloud.strokeWidth || 2}
                                                        />
                                                        {isSelected && points.map((p, i) => (
                                                            <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill="#0ea5e9" />
                                                        ))}
                                                    </g>
                                                );
                                            })}

                                            {/* Leader Lines */}
                                            {leaderLines.filter(l => l.visible !== false).map(leader => {
                                                const isSelected = selectedId === leader.id || selectedIds.some(s => s.id === leader.id && s.type === 'leader');
                                                const [anchor, elbow, endpoint] = leader.points;
                                                const arrowSize = leader.arrowSize || 8;
                                                // Calculate arrow angle
                                                const angle = Math.atan2(elbow.y - anchor.y, elbow.x - anchor.x);
                                                const arrowPath = `M ${anchor.x} ${anchor.y} L ${anchor.x + arrowSize * Math.cos(angle - Math.PI / 6)} ${anchor.y + arrowSize * Math.sin(angle - Math.PI / 6)} M ${anchor.x} ${anchor.y} L ${anchor.x + arrowSize * Math.cos(angle + Math.PI / 6)} ${anchor.y + arrowSize * Math.sin(angle + Math.PI / 6)}`;

                                                return (
                                                    <g key={leader.id} style={{ cursor: currentTool === OPERATIONS.SELECT ? 'pointer' : 'default' }}>
                                                        {/* Leader line path */}
                                                        <path
                                                            d={`M ${anchor.x} ${anchor.y} L ${elbow.x} ${elbow.y} L ${endpoint.x} ${endpoint.y}`}
                                                            fill="none"
                                                            stroke={leader.stroke}
                                                            strokeWidth={leader.strokeWidth}
                                                        />
                                                        {/* Arrow head */}
                                                        <path
                                                            d={arrowPath}
                                                            fill="none"
                                                            stroke={leader.stroke}
                                                            strokeWidth={leader.strokeWidth}
                                                            strokeLinecap="round"
                                                        />
                                                        {/* Text label */}
                                                        <text
                                                            x={endpoint.x + 5}
                                                            y={endpoint.y + 4}
                                                            fontSize={leader.fontSize || 12}
                                                            fill={leader.stroke}
                                                            style={{ userSelect: 'none' }}
                                                        >
                                                            {leader.text}
                                                        </text>
                                                        {isSelected && (
                                                            <>
                                                                <circle cx={anchor.x} cy={anchor.y} r={4 / zoom} fill="#0ea5e9" />
                                                                <circle cx={elbow.x} cy={elbow.y} r={4 / zoom} fill="#0ea5e9" />
                                                                <circle cx={endpoint.x} cy={endpoint.y} r={4 / zoom} fill="#0ea5e9" />
                                                            </>
                                                        )}
                                                    </g>
                                                );
                                            })}

                                            {/* Symbols */}
                                            {symbols.filter(s => s.visible !== false).map(symbol => {
                                                const isSelected = selectedId === symbol.id || selectedIds.some(s => s.id === symbol.id && s.type === 'symbol');
                                                const symbolDef = HV_SYMBOLS[symbol.symbolId];
                                                if (!symbolDef) return null;
                                                const scale = symbol.scale || 1;
                                                const rotation = symbol.rotation || 0;
                                                return (
                                                    <g key={symbol.id} style={{ cursor: currentTool === OPERATIONS.SELECT ? 'pointer' : 'default' }}>
                                                        {isSelected && (
                                                            <rect
                                                                x={symbol.x - 2}
                                                                y={symbol.y - 2}
                                                                width={symbol.width * scale + 4}
                                                                height={symbol.height * scale + 4}
                                                                fill="none"
                                                                stroke="#0ea5e9"
                                                                strokeWidth={2 / zoom}
                                                                strokeDasharray={`${4 / zoom}`}
                                                            />
                                                        )}
                                                        <g transform={`translate(${symbol.x + symbol.width * scale / 2}, ${symbol.y + symbol.height * scale / 2}) rotate(${rotation}) scale(${symbol.flipH ? -scale : scale}, ${symbol.flipV ? -scale : scale}) translate(${-symbolDef.width / 2}, ${-symbolDef.height / 2})`}>
                                                            <svg
                                                                width={symbolDef.width}
                                                                height={symbolDef.height}
                                                                viewBox={`0 0 ${symbolDef.width} ${symbolDef.height}`}
                                                                dangerouslySetInnerHTML={{ __html: symbolDef.svg }}
                                                            />
                                                        </g>
                                                    </g>
                                                );
                                            })}

                                            {/* Measurements */}
                                            {measurements.filter(m => m.visible !== false).map(measurement => {
                                                const isSelected = selectedId === measurement.id;
                                                const midX = (measurement.x1 + measurement.x2) / 2;
                                                const midY = (measurement.y1 + measurement.y2) / 2;
                                                const angle = Math.atan2(measurement.y2 - measurement.y1, measurement.x2 - measurement.x1) * 180 / Math.PI;
                                                const displayDist = measurement.realDistance !== null
                                                    ? `${measurement.realDistance.toFixed(2)} ${measurement.unit === 'meters' ? 'm' : 'ft'}`
                                                    : `${measurement.pixelDistance.toFixed(0)} px`;
                                                return (
                                                    <g key={measurement.id} style={{ cursor: currentTool === OPERATIONS.SELECT ? 'pointer' : 'default' }}>
                                                        {/* Measurement line */}
                                                        <line
                                                            x1={measurement.x1}
                                                            y1={measurement.y1}
                                                            x2={measurement.x2}
                                                            y2={measurement.y2}
                                                            stroke="#22c55e"
                                                            strokeWidth={2}
                                                            strokeDasharray="6,3"
                                                        />
                                                        {/* End markers */}
                                                        <circle cx={measurement.x1} cy={measurement.y1} r={4} fill="#22c55e" stroke="#fff" strokeWidth={1} />
                                                        <circle cx={measurement.x2} cy={measurement.y2} r={4} fill="#22c55e" stroke="#fff" strokeWidth={1} />
                                                        {/* Distance label */}
                                                        <g transform={`translate(${midX}, ${midY})`}>
                                                            <rect
                                                                x={-35}
                                                                y={-12}
                                                                width={70}
                                                                height={20}
                                                                rx={4}
                                                                fill="#1a1a1a"
                                                                stroke="#22c55e"
                                                                strokeWidth={1}
                                                            />
                                                            <text
                                                                x={0}
                                                                y={4}
                                                                textAnchor="middle"
                                                                fill="#22c55e"
                                                                fontSize={11}
                                                                fontWeight="bold"
                                                                fontFamily="monospace"
                                                            >
                                                                {displayDist}
                                                            </text>
                                                        </g>
                                                        {/* Selection indicator */}
                                                        {isSelected && (
                                                            <>
                                                                <circle cx={measurement.x1} cy={measurement.y1} r={8} fill="none" stroke="#0ea5e9" strokeWidth={2 / zoom} strokeDasharray={`${4 / zoom}`} />
                                                                <circle cx={measurement.x2} cy={measurement.y2} r={8} fill="none" stroke="#0ea5e9" strokeWidth={2 / zoom} strokeDasharray={`${4 / zoom}`} />
                                                            </>
                                                        )}
                                                    </g>
                                                );
                                            })}

                                            {/* Calibration preview */}
                                            {currentTool === OPERATIONS.CALIBRATE && calibrationPoints.length > 0 && (
                                                <g>
                                                    <circle cx={calibrationPoints[0].x} cy={calibrationPoints[0].y} r={6} fill="#f59e0b" stroke="#fff" strokeWidth={2} />
                                                    {calibrationPoints.length > 1 && (
                                                        <>
                                                            <circle cx={calibrationPoints[1].x} cy={calibrationPoints[1].y} r={6} fill="#f59e0b" stroke="#fff" strokeWidth={2} />
                                                            <line
                                                                x1={calibrationPoints[0].x}
                                                                y1={calibrationPoints[0].y}
                                                                x2={calibrationPoints[1].x}
                                                                y2={calibrationPoints[1].y}
                                                                stroke="#f59e0b"
                                                                strokeWidth={2}
                                                                strokeDasharray="8,4"
                                                            />
                                                        </>
                                                    )}
                                                </g>
                                            )}

                                            {/* Info Points */}
                                            {infoPoints.filter(p => p.visible !== false).map(point => {
                                                const isSelected = selectedId === point.id;
                                                const radius = point.radius || 12;
                                                const categoryColor = (INFO_CATEGORIES[point.category] || INFO_CATEGORIES.general).color;
                                                const priorityColor = (INFO_PRIORITIES[point.priority] || INFO_PRIORITIES.medium).color;
                                                const displayNumber = point.number || 1;
                                                const fontSize = radius < 10 ? 9 : radius < 14 ? 11 : 13;

                                                // Compute marker text based on markerStyle
                                                const markerStyle = point.markerStyle || 'number';
                                                let markerText = '';
                                                if (markerStyle === 'number') {
                                                    markerText = String(displayNumber);
                                                } else if (markerStyle === 'letter') {
                                                    // Convert number to letter: 1=A, 2=B, ... 26=Z, 27=AA, etc.
                                                    let n = displayNumber;
                                                    let letter = '';
                                                    while (n > 0) {
                                                        n--;
                                                        letter = String.fromCharCode(65 + (n % 26)) + letter;
                                                        n = Math.floor(n / 26);
                                                    }
                                                    markerText = letter;
                                                } else if (markerStyle === 'icon') {
                                                    markerText = 'i';
                                                }
                                                // 'none' keeps markerText empty

                                                return (
                                                    <g key={point.id} style={{ cursor: currentTool === OPERATIONS.SELECT ? 'pointer' : 'default' }}>
                                                        {/* Drop shadow */}
                                                        <defs>
                                                            <filter id={`shadow-${point.id}`} x="-50%" y="-50%" width="200%" height="200%">
                                                                <feDropShadow dx="0" dy="2" stdDeviation="3" floodOpacity="0.4"/>
                                                            </filter>
                                                            <radialGradient id={`highlight-${point.id}`} cx="30%" cy="30%" r="50%">
                                                                <stop offset="0%" stopColor="rgba(255,255,255,0.4)"/>
                                                                <stop offset="100%" stopColor="rgba(255,255,255,0)"/>
                                                            </radialGradient>
                                                        </defs>

                                                        {/* Selection ring */}
                                                        {isSelected && (
                                                            <circle
                                                                cx={point.x}
                                                                cy={point.y}
                                                                r={radius + 6}
                                                                fill="none"
                                                                stroke="#0ea5e9"
                                                                strokeWidth={2 / zoom}
                                                                strokeDasharray={`${4 / zoom}`}
                                                            />
                                                        )}

                                                        {/* Main circle with shadow */}
                                                        <circle
                                                            cx={point.x}
                                                            cy={point.y}
                                                            r={radius}
                                                            fill={categoryColor}
                                                            stroke="#ffffff"
                                                            strokeWidth={2.5}
                                                            filter={`url(#shadow-${point.id})`}
                                                        />

                                                        {/* Inner highlight for 3D effect */}
                                                        <circle
                                                            cx={point.x}
                                                            cy={point.y}
                                                            r={radius - 1}
                                                            fill={`url(#highlight-${point.id})`}
                                                            style={{ pointerEvents: 'none' }}
                                                        />

                                                        {/* Priority indicator dot (bottom-right) */}
                                                        <circle
                                                            cx={point.x + radius * 0.6}
                                                            cy={point.y + radius * 0.6}
                                                            r={4}
                                                            fill={priorityColor}
                                                            stroke="#ffffff"
                                                            strokeWidth={1.5}
                                                            style={{ pointerEvents: 'none' }}
                                                        />

                                                        {/* Marker text (number, letter, icon, or none) */}
                                                        {markerText && (
                                                            <text
                                                                x={point.x}
                                                                y={point.y + fontSize * 0.35}
                                                                textAnchor="middle"
                                                                fill="#ffffff"
                                                                fontSize={markerStyle === 'icon' ? fontSize + 2 : fontSize}
                                                                fontWeight="bold"
                                                                fontFamily={markerStyle === 'icon' ? 'Georgia, serif' : 'Arial, sans-serif'}
                                                                fontStyle={markerStyle === 'icon' ? 'italic' : 'normal'}
                                                                style={{ pointerEvents: 'none' }}
                                                            >
                                                                {markerText}
                                                            </text>
                                                        )}

                                                        {/* Label with dark background pill */}
                                                        {point.label && (
                                                            <g>
                                                                {/* Background pill */}
                                                                <rect
                                                                    x={point.x - (point.label.length * 3.5 + 8)}
                                                                    y={point.y - radius - 22}
                                                                    width={point.label.length * 7 + 16}
                                                                    height={18}
                                                                    rx={9}
                                                                    ry={9}
                                                                    fill="rgba(0,0,0,0.75)"
                                                                    style={{ pointerEvents: 'none' }}
                                                                />
                                                                {/* Category color indicator on label */}
                                                                <circle
                                                                    cx={point.x - (point.label.length * 3.5) + 2}
                                                                    cy={point.y - radius - 13}
                                                                    r={3}
                                                                    fill={categoryColor}
                                                                    style={{ pointerEvents: 'none' }}
                                                                />
                                                                {/* Label text */}
                                                                <text
                                                                    x={point.x + 6}
                                                                    y={point.y - radius - 9}
                                                                    textAnchor="middle"
                                                                    fill="#ffffff"
                                                                    fontSize="11"
                                                                    fontFamily="Arial, sans-serif"
                                                                    style={{ pointerEvents: 'none' }}
                                                                >
                                                                    {point.label}
                                                                </text>
                                                            </g>
                                                        )}
                                                    </g>
                                                );
                                            })}

                                            {/* Comments */}
                                            {comments.filter(c => c.page === currentPage).map(comment => {
                                                const status = COMMENT_STATUSES[comment.status] || COMMENT_STATUSES.pending;
                                                const isSelected = selectedComment === comment.id;

                                                return (
                                                    <g
                                                        key={comment.id}
                                                        style={{ cursor: 'pointer' }}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setSelectedComment(isSelected ? null : comment.id);
                                                        }}
                                                    >
                                                        {/* Comment bubble */}
                                                        <g transform={`translate(${comment.x}, ${comment.y})`}>
                                                            {/* Selection indicator */}
                                                            {isSelected && (
                                                                <circle
                                                                    cx={0}
                                                                    cy={0}
                                                                    r={18}
                                                                    fill="none"
                                                                    stroke="#0ea5e9"
                                                                    strokeWidth={2 / zoom}
                                                                    strokeDasharray={`${4 / zoom}`}
                                                                />
                                                            )}
                                                            {/* Comment pin */}
                                                            <circle
                                                                cx={0}
                                                                cy={0}
                                                                r={14}
                                                                fill={status.color}
                                                                stroke="#ffffff"
                                                                strokeWidth={2}
                                                            />
                                                            {/* Status icon */}
                                                            <text
                                                                x={0}
                                                                y={5}
                                                                textAnchor="middle"
                                                                fill="#ffffff"
                                                                fontSize="12"
                                                                fontWeight="bold"
                                                                style={{ pointerEvents: 'none' }}
                                                            >
                                                                {status.icon}
                                                            </text>
                                                            {/* Reply count badge */}
                                                            {comment.replies.length > 0 && (
                                                                <>
                                                                    <circle cx={10} cy={-10} r={8} fill="#ef4444" />
                                                                    <text x={10} y={-6} textAnchor="middle" fill="#fff" fontSize="10" fontWeight="bold">
                                                                        {comment.replies.length}
                                                                    </text>
                                                                </>
                                                            )}
                                                        </g>
                                                    </g>
                                                );
                                            })}

                                            {/* Drawing preview */}
                                            {isDrawing && drawStart && drawEnd && (
                                                <g>
                                                    {currentTool === OPERATIONS.SNIPPET && (
                                                        <rect
                                                            x={Math.min(drawStart.x, drawEnd.x)}
                                                            y={Math.min(drawStart.y, drawEnd.y)}
                                                            width={Math.abs(drawEnd.x - drawStart.x)}
                                                            height={Math.abs(drawEnd.y - drawStart.y)}
                                                            fill="rgba(14, 165, 233, 0.2)"
                                                            stroke="#0ea5e9"
                                                            strokeWidth={2 / zoom}
                                                            strokeDasharray={`${6 / zoom}`}
                                                        />
                                                    )}
                                                    {currentTool === OPERATIONS.MASK && (
                                                        <rect
                                                            x={Math.min(drawStart.x, drawEnd.x)}
                                                            y={Math.min(drawStart.y, drawEnd.y)}
                                                            width={Math.abs(drawEnd.x - drawStart.x)}
                                                            height={Math.abs(drawEnd.y - drawStart.y)}
                                                            fill="rgba(255, 255, 255, 0.8)"
                                                            stroke="#999"
                                                            strokeWidth={1 / zoom}
                                                        />
                                                    )}
                                                    {currentTool === OPERATIONS.RECTANGLE && (
                                                        <rect
                                                            x={Math.min(drawStart.x, drawEnd.x)}
                                                            y={Math.min(drawStart.y, drawEnd.y)}
                                                            width={Math.abs(drawEnd.x - drawStart.x)}
                                                            height={Math.abs(drawEnd.y - drawStart.y)}
                                                            fill={styles.fill === 'none' ? 'transparent' : styles.fill}
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                        />
                                                    )}
                                                    {currentTool === OPERATIONS.CIRCLE && (
                                                        <circle
                                                            cx={Math.min(drawStart.x, drawEnd.x) + Math.abs(drawEnd.x - drawStart.x) / 2}
                                                            cy={Math.min(drawStart.y, drawEnd.y) + Math.abs(drawEnd.y - drawStart.y) / 2}
                                                            r={Math.max(Math.abs(drawEnd.x - drawStart.x), Math.abs(drawEnd.y - drawStart.y)) / 2}
                                                            fill={styles.fill === 'none' ? 'transparent' : styles.fill}
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                        />
                                                    )}
                                                    {currentTool === OPERATIONS.LINE && (
                                                        <line
                                                            x1={drawStart.x}
                                                            y1={drawStart.y}
                                                            x2={drawEnd.x}
                                                            y2={drawEnd.y}
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                        />
                                                    )}
                                                    {currentTool === OPERATIONS.ARROW && (
                                                        <g style={{ color: styles.stroke }}>
                                                            <line
                                                                x1={drawStart.x}
                                                                y1={drawStart.y}
                                                                x2={drawEnd.x}
                                                                y2={drawEnd.y}
                                                                stroke={styles.stroke}
                                                                strokeWidth={styles.strokeWidth}
                                                                markerEnd="url(#arrowhead-end)"
                                                            />
                                                        </g>
                                                    )}
                                                </g>
                                            )}

                                            {/* Polyline Preview */}
                                            {currentTool === OPERATIONS.POLYLINE && polylinePoints.length > 0 && (
                                                <g>
                                                    {/* Completed segments */}
                                                    {polylinePoints.length >= 2 && (
                                                        <path
                                                            d={polylinePoints.map((p, i) => (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y).join(' ')}
                                                            fill="none"
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                            strokeLinecap="round"
                                                            strokeLinejoin="round"
                                                        />
                                                    )}
                                                    {/* Point markers */}
                                                    {polylinePoints.map((p, i) => (
                                                        <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill="#0ea5e9" stroke="#fff" strokeWidth={1 / zoom} />
                                                    ))}
                                                    {/* Instructions */}
                                                    <text x={polylinePoints[0].x} y={polylinePoints[0].y - 15} fill="#0ea5e9" fontSize={12 / zoom} textAnchor="start">
                                                        Double-click or Enter to finish
                                                    </text>
                                                </g>
                                            )}

                                            {/* Freehand Preview */}
                                            {isDrawingFreehand && freehandPath.length > 1 && (
                                                <path
                                                    d={freehandPath.map((p, i) => (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y).join(' ')}
                                                    fill="none"
                                                    stroke={styles.stroke}
                                                    strokeWidth={styles.strokeWidth}
                                                    strokeLinecap="round"
                                                    strokeLinejoin="round"
                                                    opacity={0.7}
                                                />
                                            )}

                                            {/* Polygon Preview */}
                                            {currentTool === OPERATIONS.POLYGON && polygonPoints.length > 0 && (
                                                <g>
                                                    {/* Completed segments and closing line */}
                                                    {polygonPoints.length >= 2 && (
                                                        <path
                                                            d={polygonPoints.map((p, i) => (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y).join(' ') + (polygonPoints.length >= 3 ? ' Z' : '')}
                                                            fill={polygonPoints.length >= 3 ? (styles.fill === 'none' ? 'transparent' : styles.fill) : 'none'}
                                                            fillOpacity={0.2}
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                            strokeLinejoin="round"
                                                            strokeDasharray={polygonPoints.length < 3 ? '5,5' : 'none'}
                                                        />
                                                    )}
                                                    {/* Point markers */}
                                                    {polygonPoints.map((p, i) => (
                                                        <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill="#22c55e" stroke="#fff" strokeWidth={1 / zoom} />
                                                    ))}
                                                    {/* Instructions */}
                                                    <text x={polygonPoints[0].x} y={polygonPoints[0].y - 15} fill="#22c55e" fontSize={12 / zoom} textAnchor="start">
                                                        {polygonPoints.length < 3 ? 'Click to add points (min 3)' : 'Enter to close polygon'}
                                                    </text>
                                                </g>
                                            )}

                                            {/* Arc Preview */}
                                            {currentTool === OPERATIONS.ARC && arcPoints.length > 0 && (
                                                <g>
                                                    {/* Preview curve */}
                                                    {arcPoints.length === 2 && (
                                                        <path
                                                            d={`M ${arcPoints[0].x} ${arcPoints[0].y} Q ${arcPoints[1].x} ${arcPoints[1].y} ${arcPoints[1].x} ${arcPoints[1].y}`}
                                                            fill="none"
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                            strokeDasharray="5,5"
                                                            opacity={0.5}
                                                        />
                                                    )}
                                                    {/* Point markers */}
                                                    {arcPoints.map((p, i) => (
                                                        <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill={i === 1 ? '#22c55e' : '#0ea5e9'} stroke="#fff" strokeWidth={1 / zoom} />
                                                    ))}
                                                    {/* Instructions */}
                                                    <text x={arcPoints[0].x} y={arcPoints[0].y - 15} fill="#0ea5e9" fontSize={12 / zoom} textAnchor="start">
                                                        {arcPoints.length === 1 ? 'Click for control point' : 'Click for end point'}
                                                    </text>
                                                </g>
                                            )}

                                            {/* Bezier Preview */}
                                            {currentTool === OPERATIONS.BEZIER && bezierPoints.length > 0 && (
                                                <g>
                                                    {/* Preview curve */}
                                                    {bezierPoints.length >= 2 && (
                                                        <path
                                                            d={bezierPoints.length === 2
                                                                ? `M ${bezierPoints[0].x} ${bezierPoints[0].y} L ${bezierPoints[1].x} ${bezierPoints[1].y}`
                                                                : bezierPoints.length === 3
                                                                ? `M ${bezierPoints[0].x} ${bezierPoints[0].y} Q ${bezierPoints[1].x} ${bezierPoints[1].y} ${bezierPoints[2].x} ${bezierPoints[2].y}`
                                                                : `M ${bezierPoints[0].x} ${bezierPoints[0].y} C ${bezierPoints[1].x} ${bezierPoints[1].y}, ${bezierPoints[2].x} ${bezierPoints[2].y}, ${bezierPoints[3].x} ${bezierPoints[3].y}`
                                                            }
                                                            fill="none"
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                            strokeDasharray="5,5"
                                                            opacity={0.6}
                                                        />
                                                    )}
                                                    {/* Control point lines */}
                                                    {bezierPoints.length >= 2 && (
                                                        <line x1={bezierPoints[0].x} y1={bezierPoints[0].y} x2={bezierPoints[1].x} y2={bezierPoints[1].y}
                                                            stroke="#0ea5e9" strokeWidth={1 / zoom} strokeDasharray={`${3 / zoom}`} />
                                                    )}
                                                    {bezierPoints.length >= 3 && (
                                                        <line x1={bezierPoints[2].x} y1={bezierPoints[2].y} x2={bezierPoints[bezierPoints.length - 1].x} y2={bezierPoints[bezierPoints.length - 1].y}
                                                            stroke="#0ea5e9" strokeWidth={1 / zoom} strokeDasharray={`${3 / zoom}`} />
                                                    )}
                                                    {/* Point markers */}
                                                    {bezierPoints.map((p, i) => (
                                                        <circle key={i} cx={p.x} cy={p.y} r={4 / zoom}
                                                            fill={i === 0 || i === 3 ? '#0ea5e9' : '#22c55e'}
                                                            stroke="#fff" strokeWidth={1 / zoom} />
                                                    ))}
                                                    {/* Instructions */}
                                                    <text x={bezierPoints[0].x} y={bezierPoints[0].y - 15} fill="#0ea5e9" fontSize={12 / zoom} textAnchor="start">
                                                        {bezierPoints.length === 1 ? 'Click for control point 1' :
                                                         bezierPoints.length === 2 ? 'Click for control point 2' :
                                                         'Click for end point'}
                                                    </text>
                                                </g>
                                            )}

                                            {/* Cloud Preview */}
                                            {currentTool === OPERATIONS.CLOUD && cloudPoints.length > 0 && (
                                                <g>
                                                    {/* Preview polygon */}
                                                    {cloudPoints.length >= 2 && (
                                                        <path
                                                            d={cloudPoints.map((p, i) => (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y).join(' ')}
                                                            fill="rgba(255, 200, 200, 0.1)"
                                                            stroke={styles.stroke || '#ef4444'}
                                                            strokeWidth={styles.strokeWidth}
                                                            strokeDasharray="5,5"
                                                            opacity={0.6}
                                                        />
                                                    )}
                                                    {/* Point markers */}
                                                    {cloudPoints.map((p, i) => (
                                                        <circle key={i} cx={p.x} cy={p.y} r={4 / zoom} fill="#ef4444" stroke="#fff" strokeWidth={1 / zoom} />
                                                    ))}
                                                    {/* Instructions */}
                                                    <text x={cloudPoints[0].x} y={cloudPoints[0].y - 15} fill="#ef4444" fontSize={12 / zoom} textAnchor="start">
                                                        Double-click or Enter to close cloud
                                                    </text>
                                                </g>
                                            )}

                                            {/* Leader Preview */}
                                            {currentTool === OPERATIONS.LEADER && leaderPoints.length > 0 && (
                                                <g>
                                                    {/* Preview line */}
                                                    {leaderPoints.length >= 2 && (
                                                        <path
                                                            d={leaderPoints.map((p, i) => (i === 0 ? 'M' : 'L') + p.x + ' ' + p.y).join(' ')}
                                                            fill="none"
                                                            stroke={styles.stroke}
                                                            strokeWidth={styles.strokeWidth}
                                                            strokeDasharray="5,5"
                                                            opacity={0.6}
                                                        />
                                                    )}
                                                    {/* Point markers */}
                                                    {leaderPoints.map((p, i) => (
                                                        <circle key={i} cx={p.x} cy={p.y} r={4 / zoom}
                                                            fill={i === 0 ? '#0ea5e9' : '#22c55e'}
                                                            stroke="#fff" strokeWidth={1 / zoom} />
                                                    ))}
                                                    {/* Instructions */}
                                                    <text x={leaderPoints[0].x} y={leaderPoints[0].y - 15} fill="#0ea5e9" fontSize={12 / zoom} textAnchor="start">
                                                        {leaderPoints.length === 1 ? 'Click for elbow point' : 'Click for text endpoint'}
                                                    </text>
                                                </g>
                                            )}

                                            {/* Alignment Guides */}
                                            {alignmentGuides.map((guide, idx) => (
                                                guide.type === 'vertical' ? (
                                                    <line
                                                        key={`guide-v-${idx}`}
                                                        x1={guide.x}
                                                        y1={0}
                                                        x2={guide.x}
                                                        y2={currentPageData?.height || 2000}
                                                        stroke="#f43f5e"
                                                        strokeWidth={1 / zoom}
                                                        strokeDasharray={`${4 / zoom}`}
                                                        pointerEvents="none"
                                                    />
                                                ) : (
                                                    <line
                                                        key={`guide-h-${idx}`}
                                                        x1={0}
                                                        y1={guide.y}
                                                        x2={currentPageData?.width || 2000}
                                                        y2={guide.y}
                                                        stroke="#f43f5e"
                                                        strokeWidth={1 / zoom}
                                                        strokeDasharray={`${4 / zoom}`}
                                                        pointerEvents="none"
                                                    />
                                                )
                                            ))}

                                            {/* Selection Box */}
                                            {selectionBox && (
                                                <rect
                                                    x={Math.min(selectionBox.x1, selectionBox.x2)}
                                                    y={Math.min(selectionBox.y1, selectionBox.y2)}
                                                    width={Math.abs(selectionBox.x2 - selectionBox.x1)}
                                                    height={Math.abs(selectionBox.y2 - selectionBox.y1)}
                                                    fill="rgba(14, 165, 233, 0.1)"
                                                    stroke="#0ea5e9"
                                                    strokeWidth={1 / zoom}
                                                    strokeDasharray={`${4 / zoom}`}
                                                />
                                            )}
                                        </svg>
                                        
                                        {/* Snippet overlays (positioned divs for drag interaction) */}
                                        {snippets.filter(s => s.visible !== false).map(snippet => {
                                            const isSelected = selectedId === snippet.id || selectedIds.some(s => s.id === snippet.id && s.type === 'snippet');
                                            const showBorder = isSelected || !snippet.hideBorder;
                                            const snippetRotation = snippet.rotation || 0;
                                            return (
                                            <div
                                                key={snippet.id}
                                                className={`absolute ${showBorder ? 'snippet-overlay' : ''} ${isSelected ? 'ring-2 ring-accent ring-offset-2 ring-offset-transparent' : ''}`}
                                                style={{
                                                    left: snippet.x,
                                                    top: snippet.y,
                                                    width: snippet.width,
                                                    height: snippet.height,
                                                    zIndex: LAYERS.SNIPPETS,
                                                    cursor: currentTool === OPERATIONS.SELECT ? 'move' : 'default',
                                                    pointerEvents: currentTool === OPERATIONS.SELECT ? 'auto' : 'none',
                                                    border: showBorder ? `2px dashed ${isSelected ? '#0ea5e9' : '#666'}` : 'none',
                                                    overflow: 'hidden',
                                                    transform: snippetRotation ? `rotate(${snippetRotation}deg)` : undefined,
                                                    transformOrigin: 'center center'
                                                }}
                                            >
                                                {/* Render captured image content */}
                                                {snippet.imageData ? (
                                                    <img
                                                        src={snippet.imageData}
                                                        alt={snippet.name}
                                                        style={{
                                                            width: '100%',
                                                            height: '100%',
                                                            objectFit: 'fill',
                                                            pointerEvents: 'none'
                                                        }}
                                                        draggable={false}
                                                    />
                                                ) : (
                                                    <div style={{
                                                        width: '100%',
                                                        height: '100%',
                                                        background: 'rgba(14, 165, 233, 0.1)',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        fontSize: '10px',
                                                        color: '#666'
                                                    }}>
                                                        No image
                                                    </div>
                                                )}
                                                <div className="absolute -top-6 left-0 text-xs bg-accent text-white px-2 py-0.5 rounded whitespace-nowrap">
                                                    {snippet.name}
                                                </div>
                                            </div>
                                        );})}
                                    </div>
                                )}
                            </div>
                            
                            {/* Status Bar */}
                            <footer className="h-8 bg-panel-bg border-t border-panel-border flex items-center px-4 text-xs text-gray-400 gap-4">
                                <span className="mono">Zoom: {Math.round(zoom * 100)}%</span>
                                {pdfData && (
                                    <>
                                        <span>Page: {currentPage + 1} / {pdfData.pageCount}</span>
                                        <span>Size: {currentPageData?.width} × {currentPageData?.height}</span>
                                    </>
                                )}
                                <span>Tool: {currentTool}</span>
                                {selectedIds.length > 1 && (
                                    <span className="text-accent">{selectedIds.length} items selected</span>
                                )}
                                {/* Auto-save status */}
                                {pdfData && (
                                    <span className="flex items-center gap-2">
                                        {hasUnsavedChanges ? (
                                            <span className="text-yellow-500">● Unsaved changes</span>
                                        ) : lastSaveTime ? (
                                            <span className="text-green-500">✓ Saved {lastSaveTime.toLocaleTimeString()}</span>
                                        ) : null}
                                        {autoSaveVersions.length > 0 && (
                                            <button
                                                className="text-gray-400 hover:text-white underline"
                                                onClick={() => setShowVersionHistory(true)}
                                            >
                                                History ({autoSaveVersions.length})
                                            </button>
                                        )}
                                    </span>
                                )}
                                {/* Calibration status */}
                                {scaleCalibration.isCalibrated ? (
                                    <span className="text-green-400 flex items-center gap-1">
                                        <span className="w-2 h-2 bg-green-400 rounded-full"></span>
                                        Scale: {scaleCalibration.pixelsPerMeter.toFixed(1)} px/{scaleCalibration.unit === 'meters' ? 'm' : 'ft'}
                                    </span>
                                ) : (
                                    <span className="text-yellow-500 flex items-center gap-1">
                                        <span className="w-2 h-2 bg-yellow-500 rounded-full"></span>
                                        Not Calibrated
                                    </span>
                                )}
                                <div className="flex-1" />
                                <span>Symbols: {symbols.length}</span>
                                <span>Meas: {measurements.length}</span>
                                <span>Info: {infoPoints.length}</span>
                            </footer>
                        </main>

                        {/* Right Resize Handle */}
                        <div
                            className={`w-1.5 cursor-col-resize flex-shrink-0 transition-colors ${isResizingRight ? 'bg-accent' : 'bg-panel-border hover:bg-accent/70'}`}
                            onMouseDown={() => setIsResizingRight(true)}
                            title="Drag to resize"
                        />

                        {/* Right Panel - Properties */}
                        <aside
                            className="bg-panel-bg border-l border-panel-border flex flex-col flex-shrink-0"
                            style={{ width: rightSidebarWidth }}
                        >
                            <div className="p-3 border-b border-panel-border bg-[#1a1a1a] flex items-center gap-2">
                                <div className="w-4 h-4 text-accent"><Icons.Settings /></div>
                                <h3 className="text-sm font-medium text-gray-300">Properties</h3>
                                {selectedIds.length > 1 ? (
                                    <span className="ml-auto px-2 py-0.5 text-[10px] bg-purple-500/20 text-purple-400 rounded-full">
                                        {selectedIds.length} selected
                                    </span>
                                ) : selectedItem && (
                                    <span className="ml-auto px-2 py-0.5 text-[10px] bg-accent/20 text-accent rounded-full">
                                        {selectedType}
                                    </span>
                                )}
                            </div>
                            <div className="flex-1 overflow-y-auto">
                                {selectedIds.length > 1 ? (
                                    /* Batch Edit Panel */
                                    <div className="p-4 space-y-4">
                                        <div className="text-xs text-gray-400 uppercase tracking-wider mb-2">
                                            Batch Edit ({selectedIds.length} items)
                                        </div>

                                        {/* Batch Color */}
                                        <div className="space-y-2">
                                            <div className="text-xs text-gray-500">Apply Color to All</div>
                                            <div className="flex gap-2">
                                                <input
                                                    type="color"
                                                    defaultValue="#3b82f6"
                                                    onChange={(e) => {
                                                        const color = e.target.value;
                                                        applyToSelected(item => ({ stroke: color, color: color }));
                                                    }}
                                                    className="w-10 h-8"
                                                />
                                                <button
                                                    className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded"
                                                    onClick={() => applyToSelected(item => ({ stroke: '#ef4444' }))}
                                                >Red</button>
                                                <button
                                                    className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded"
                                                    onClick={() => applyToSelected(item => ({ stroke: '#22c55e' }))}
                                                >Green</button>
                                                <button
                                                    className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded"
                                                    onClick={() => applyToSelected(item => ({ stroke: '#3b82f6' }))}
                                                >Blue</button>
                                            </div>
                                        </div>

                                        {/* Batch Stroke Width */}
                                        <div className="space-y-2">
                                            <div className="text-xs text-gray-500">Stroke Width</div>
                                            <div className="flex gap-2">
                                                {[1, 2, 3, 5, 8].map(w => (
                                                    <button
                                                        key={w}
                                                        className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded"
                                                        onClick={() => applyToSelected(item => ({ strokeWidth: w }))}
                                                    >{w}px</button>
                                                ))}
                                            </div>
                                        </div>

                                        {/* Batch Visibility */}
                                        <div className="space-y-2">
                                            <div className="text-xs text-gray-500">Visibility</div>
                                            <div className="flex gap-2">
                                                <button
                                                    className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded flex items-center justify-center gap-1"
                                                    onClick={() => applyToSelected(item => ({ visible: true }))}
                                                >
                                                    <Icons.Eye /> Show All
                                                </button>
                                                <button
                                                    className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded flex items-center justify-center gap-1"
                                                    onClick={() => applyToSelected(item => ({ visible: false }))}
                                                >
                                                    <Icons.EyeOff /> Hide All
                                                </button>
                                            </div>
                                        </div>

                                        {/* Batch Lock */}
                                        <div className="space-y-2">
                                            <div className="text-xs text-gray-500">Lock State</div>
                                            <div className="flex gap-2">
                                                <button
                                                    className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded flex items-center justify-center gap-1"
                                                    onClick={() => applyToSelected(item => ({ locked: true }))}
                                                >
                                                    <Icons.Lock /> Lock All
                                                </button>
                                                <button
                                                    className="flex-1 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded flex items-center justify-center gap-1"
                                                    onClick={() => applyToSelected(item => ({ locked: false }))}
                                                >
                                                    <Icons.Unlock /> Unlock All
                                                </button>
                                            </div>
                                        </div>

                                        {/* Batch Delete */}
                                        <div className="pt-4 border-t border-panel-border">
                                            <button
                                                className="w-full px-3 py-2 text-sm bg-red-500/20 text-red-400 hover:bg-red-500/30 rounded flex items-center justify-center gap-2"
                                                onClick={() => {
                                                    if (confirm(`Delete ${selectedIds.length} selected items?`)) {
                                                        history.push({ snippets: [...snippets], masks: [...masks], elements: [...elements], infoPoints: [...infoPoints], symbols: [...symbols], measurements: [...measurements], cableAnnotations: [...cableAnnotations] });
                                                        const snippetIds = selectedIds.filter(s => s.type === 'snippet').map(s => s.id);
                                                        const maskIds = selectedIds.filter(s => s.type === 'mask').map(s => s.id);
                                                        const elementIds = selectedIds.filter(s => s.type === 'element').map(s => s.id);
                                                        const infoPointIds = selectedIds.filter(s => s.type === 'infoPoint').map(s => s.id);
                                                        const symbolIds = selectedIds.filter(s => s.type === 'symbol').map(s => s.id);
                                                        const measurementIds = selectedIds.filter(s => s.type === 'measurement').map(s => s.id);
                                                        setSnippets(prev => prev.filter(s => !snippetIds.includes(s.id)));
                                                        setMasks(prev => prev.filter(m => !maskIds.includes(m.id)));
                                                        setElements(prev => prev.filter(e => !elementIds.includes(e.id)));
                                                        setInfoPoints(prev => prev.filter(p => !infoPointIds.includes(p.id)));
                                                        setSymbols(prev => prev.filter(s => !symbolIds.includes(s.id)));
                                                        setMeasurements(prev => prev.filter(m => !measurementIds.includes(m.id)));
                                                        setSelectedIds([]);
                                                        setSelectedId(null);
                                                        setSelectedType(null);
                                                    }
                                                }}
                                            >
                                                <Icons.Trash /> Delete All Selected
                                            </button>
                                        </div>

                                        {/* Selection Summary */}
                                        <div className="pt-4 border-t border-panel-border text-xs text-gray-500">
                                            <div className="mb-2">Selection breakdown:</div>
                                            {(() => {
                                                const counts = {};
                                                selectedIds.forEach(s => {
                                                    counts[s.type] = (counts[s.type] || 0) + 1;
                                                });
                                                return Object.entries(counts).map(([type, count]) => (
                                                    <div key={type} className="flex justify-between">
                                                        <span className="capitalize">{type}s</span>
                                                        <span>{count}</span>
                                                    </div>
                                                ));
                                            })()}
                                        </div>
                                    </div>
                                ) : (
                                    <PropertiesPanel
                                        selection={selectedItem}
                                        onUpdate={handleUpdateSelected}
                                        styles={styles}
                                        onStyleChange={(updates) => setStyles(prev => ({ ...prev, ...updates }))}
                                    />
                                )}
                            </div>
                            
                            {/* Page Navigation */}
                            {pdfData && pdfData.pageCount > 1 && (
                                <div className="p-3 border-t border-panel-border">
                                    <div className="text-xs text-gray-500 uppercase tracking-wider mb-2">Pages</div>
                                    <div className="flex items-center gap-2">
                                        <button
                                            className="page-nav-btn p-2 bg-gray-700 rounded"
                                            onClick={() => setCurrentPage(prev => Math.max(0, prev - 1))}
                                            disabled={currentPage === 0}
                                        >
                                            <div className="w-4 h-4"><Icons.ChevronLeft /></div>
                                        </button>
                                        <span className="flex-1 text-center text-sm">
                                            {currentPage + 1} / {pdfData.pageCount}
                                        </span>
                                        <button
                                            className="page-nav-btn p-2 bg-gray-700 rounded"
                                            onClick={() => setCurrentPage(prev => Math.min(pdfData.pageCount - 1, prev + 1))}
                                            disabled={currentPage === pdfData.pageCount - 1}
                                        >
                                            <div className="w-4 h-4"><Icons.ChevronRight /></div>
                                        </button>
                                    </div>
                                </div>
                            )}
                            
                            {/* Keyboard Shortcuts Reference */}
                            <div className="p-3 border-t border-panel-border">
                                <div className="text-xs text-gray-500 uppercase tracking-wider mb-2">Shortcuts</div>
                                <div className="space-y-1 text-xs text-gray-400">
                                    <div className="flex justify-between"><span>V</span><span>Select</span></div>
                                    <div className="flex justify-between"><span>S</span><span>Snippet</span></div>
                                    <div className="flex justify-between"><span>M</span><span>Mask</span></div>
                                    <div className="flex justify-between"><span>R</span><span>Rectangle</span></div>
                                    <div className="flex justify-between"><span>L</span><span>Line</span></div>
                                    <div className="flex justify-between"><span>C</span><span>Circle</span></div>
                                    <div className="flex justify-between"><span>0</span><span>Fit View</span></div>
                                    <div className="flex justify-between"><span>Del</span><span>Delete</span></div>
                                    <div className="flex justify-between"><span>Ctrl+Z</span><span>Undo</span></div>
                                    <div className="flex justify-between"><span>Ctrl+S</span><span>Save</span></div>
                                </div>
                            </div>
                        </aside>
                    </div>

                    {/* Info Summary Modal */}
                    <InfoSummaryModal
                        isOpen={showInfoSummary}
                        onClose={() => setShowInfoSummary(false)}
                        infoPoints={infoPoints}
                        onSelectItem={handleSelectItem}
                    />

                    {/* Calibration Dialog */}
                    <CalibrationDialog
                        isOpen={showCalibrationDialog}
                        onClose={() => {
                            setShowCalibrationDialog(false);
                            setCalibrationStep(0);
                            setCalibrationPoints([]);
                        }}
                        onConfirm={handleCalibrationComplete}
                        calibrationPoints={calibrationPoints}
                    />

                    {/* Template Save Dialog */}
                    {showTemplateDialog && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={() => setShowTemplateDialog(false)}>
                            <div className="bg-panel-bg rounded-lg shadow-xl w-96" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-panel-border">
                                    <h2 className="text-lg font-semibold">Save as Template</h2>
                                </div>
                                <div className="p-4 space-y-4">
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Template Name</label>
                                        <input
                                            type="text"
                                            className="w-full bg-gray-800 border border-panel-border rounded px-3 py-2 text-white"
                                            value={templateName}
                                            onChange={(e) => setTemplateName(e.target.value)}
                                            placeholder="Enter template name"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Description (optional)</label>
                                        <textarea
                                            className="w-full bg-gray-800 border border-panel-border rounded px-3 py-2 text-white resize-none"
                                            rows="3"
                                            value={templateDescription}
                                            onChange={(e) => setTemplateDescription(e.target.value)}
                                            placeholder="Enter description"
                                        />
                                    </div>
                                    <div className="text-xs text-gray-500">
                                        This template will include: {elements.length} elements, {symbols.length} symbols, {infoPoints.length} info points, {measurements.length} measurements
                                    </div>
                                </div>
                                <div className="p-4 border-t border-panel-border flex justify-end gap-2">
                                    <button
                                        className="px-4 py-2 text-gray-400 hover:text-white"
                                        onClick={() => {
                                            setShowTemplateDialog(false);
                                            setTemplateName('');
                                            setTemplateDescription('');
                                        }}
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        className="px-4 py-2 bg-accent text-white rounded hover:bg-accent-hover"
                                        onClick={handleSaveTemplate}
                                    >
                                        Save Template
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Version History Panel */}
                    {showVersionHistory && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={() => setShowVersionHistory(false)}>
                            <div className="bg-panel-bg rounded-lg shadow-xl w-[500px] max-h-[70vh] overflow-hidden" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-panel-border flex justify-between items-center">
                                    <h2 className="text-lg font-semibold">Auto-Save History</h2>
                                    <button
                                        className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-700 rounded"
                                        onClick={() => setShowVersionHistory(false)}
                                    >×</button>
                                </div>
                                <div className="p-4 overflow-y-auto max-h-[calc(70vh-60px)]">
                                    {autoSaveVersions.length === 0 ? (
                                        <div className="text-gray-500 text-sm text-center py-8">
                                            No auto-save versions yet.<br/>
                                            Versions are saved every 2 minutes.
                                        </div>
                                    ) : (
                                        <div className="space-y-2">
                                            {autoSaveVersions.map((version, index) => (
                                                <div
                                                    key={version.timestamp}
                                                    className="p-3 bg-gray-800 rounded-lg hover:bg-gray-700 cursor-pointer transition-colors"
                                                    onClick={() => restoreFromVersion(version)}
                                                >
                                                    <div className="flex items-center justify-between">
                                                        <div>
                                                            <div className="text-sm font-medium">
                                                                {index === 0 ? 'Latest' : `Version ${autoSaveVersions.length - index}`}
                                                            </div>
                                                            <div className="text-xs text-gray-400">{version.date}</div>
                                                        </div>
                                                        <div className="text-right">
                                                            <div className="text-xs text-gray-500">{version.pdfName}</div>
                                                            <div className="text-xs text-gray-500">
                                                                {(version.data.elements?.length || 0) + (version.data.symbols?.length || 0) + (version.data.snippets?.length || 0)} items
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    <div className="mt-4 pt-4 border-t border-panel-border">
                                        <button
                                            className="w-full px-3 py-2 text-sm bg-red-500/20 text-red-400 hover:bg-red-500/30 rounded"
                                            onClick={() => {
                                                if (confirm('Clear all auto-save history?')) {
                                                    setAutoSaveVersions([]);
                                                    localStorage.removeItem('markupToolAutoSaveVersions');
                                                }
                                            }}
                                        >
                                            Clear History
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Keyboard Shortcuts Panel */}
                    {showShortcutsPanel && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={() => setShowShortcutsPanel(false)}>
                            <div className="bg-panel-bg rounded-lg shadow-xl w-[600px] max-h-[80vh] overflow-hidden" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-panel-border flex justify-between items-center">
                                    <h2 className="text-lg font-semibold">Keyboard Shortcuts</h2>
                                    <button
                                        className="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-700 rounded"
                                        onClick={() => setShowShortcutsPanel(false)}
                                    >×</button>
                                </div>
                                <div className="p-4 overflow-y-auto max-h-[calc(80vh-60px)]">
                                    <div className="grid grid-cols-2 gap-6">
                                        {/* Tools */}
                                        <div>
                                            <h3 className="text-sm font-medium text-accent mb-2">Tools</h3>
                                            <div className="space-y-1 text-sm">
                                                <div className="flex justify-between"><span className="text-gray-400">Select</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">V</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Snippet</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">S</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Mask</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">M</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Rectangle</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">R</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Circle</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">C</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Line</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">L</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Arrow</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">A</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Text</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">T</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Callout</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">B</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Dimension</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">J</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Info Point</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">I</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Measure</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">D</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Symbol</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">P</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Comment</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">K</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Polyline</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Y</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Freehand</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">F</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Polygon</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">O</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Arc</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">U</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Measure Area</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Shift+A</kbd></div>
                                            </div>
                                        </div>
                                        {/* View & Edit */}
                                        <div>
                                            <h3 className="text-sm font-medium text-accent mb-2">View & Edit</h3>
                                            <div className="space-y-1 text-sm">
                                                <div className="flex justify-between"><span className="text-gray-400">Toggle Grid</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">G</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Snap to Grid</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">;</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Smart Guides</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">'</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Cancel/Deselect</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Esc</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Delete</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Del</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Rotate 90°</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">R</kbd><span className="text-xs text-gray-500">(when selected)</span></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Flip Horizontal</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">H</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Flip Vertical</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Shift+H</kbd></div>
                                            </div>

                                            <h3 className="text-sm font-medium text-accent mt-4 mb-2">File</h3>
                                            <div className="space-y-1 text-sm">
                                                <div className="flex justify-between"><span className="text-gray-400">Save</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Ctrl+S</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Open</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Ctrl+O</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Undo</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Ctrl+Z</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Redo</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Ctrl+Shift+Z</kbd></div>
                                            </div>

                                            <h3 className="text-sm font-medium text-accent mt-4 mb-2">Groups</h3>
                                            <div className="space-y-1 text-sm">
                                                <div className="flex justify-between"><span className="text-gray-400">Group</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Ctrl+G</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Ungroup</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Ctrl+Shift+G</kbd></div>
                                            </div>

                                            <h3 className="text-sm font-medium text-accent mt-4 mb-2">Navigation</h3>
                                            <div className="space-y-1 text-sm">
                                                <div className="flex justify-between"><span className="text-gray-400">Move element</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">Arrow keys</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">Toggle Minimap</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">N</kbd></div>
                                                <div className="flex justify-between"><span className="text-gray-400">This panel</span><kbd className="px-2 py-0.5 bg-gray-700 rounded">?</kbd></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* New Comment Dialog */}
                    {showCommentDialog && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={() => setShowCommentDialog(false)}>
                            <div className="bg-panel-bg rounded-lg shadow-xl w-96" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-panel-border">
                                    <h2 className="text-lg font-semibold">Add Comment</h2>
                                </div>
                                <div className="p-4">
                                    <textarea
                                        className="w-full bg-gray-800 border border-panel-border rounded px-3 py-2 text-white resize-none"
                                        rows="4"
                                        value={newCommentText}
                                        onChange={(e) => setNewCommentText(e.target.value)}
                                        placeholder="Enter your comment..."
                                        autoFocus
                                    />
                                </div>
                                <div className="p-4 border-t border-panel-border flex justify-end gap-2">
                                    <button
                                        className="px-4 py-2 text-gray-400 hover:text-white"
                                        onClick={() => {
                                            setShowCommentDialog(false);
                                            setNewCommentText('');
                                        }}
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        className="px-4 py-2 bg-accent text-white rounded hover:bg-accent-hover"
                                        onClick={handleAddComment}
                                        disabled={!newCommentText.trim()}
                                    >
                                        Add Comment
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Selected Comment Panel (floating) */}
                    {selectedComment && (() => {
                        const comment = comments.find(c => c.id === selectedComment);
                        if (!comment) return null;
                        const status = COMMENT_STATUSES[comment.status] || COMMENT_STATUSES.pending;

                        return (
                            <div
                                className="fixed bottom-20 right-8 w-80 bg-panel-bg rounded-lg shadow-xl border border-panel-border z-40"
                                onClick={e => e.stopPropagation()}
                            >
                                {/* Header */}
                                <div className="p-3 border-b border-panel-border flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                        <div
                                            className="w-6 h-6 rounded-full flex items-center justify-center text-xs"
                                            style={{ backgroundColor: status.color }}
                                        >
                                            {status.icon}
                                        </div>
                                        <span className="font-medium text-sm">{comment.author}</span>
                                    </div>
                                    <button
                                        onClick={() => setSelectedComment(null)}
                                        className="text-gray-400 hover:text-white p-1"
                                    >
                                        <div className="w-4 h-4"><Icons.X /></div>
                                    </button>
                                </div>

                                {/* Comment content */}
                                <div className="p-3 border-b border-panel-border">
                                    <p className="text-sm text-gray-300">{comment.text}</p>
                                    <div className="text-xs text-gray-500 mt-2">
                                        {new Date(comment.createdAt).toLocaleString()}
                                    </div>
                                </div>

                                {/* Status selector */}
                                <div className="p-3 border-b border-panel-border">
                                    <label className="text-xs text-gray-400 mb-2 block">Status</label>
                                    <div className="flex gap-1">
                                        {Object.entries(COMMENT_STATUSES).map(([key, val]) => (
                                            <button
                                                key={key}
                                                className={`flex-1 py-1 px-2 text-xs rounded ${comment.status === key ? 'ring-2 ring-white' : 'opacity-60 hover:opacity-100'}`}
                                                style={{ backgroundColor: val.color }}
                                                onClick={() => handleUpdateCommentStatus(comment.id, key)}
                                            >
                                                {val.icon}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Replies */}
                                {comment.replies.length > 0 && (
                                    <div className="p-3 border-b border-panel-border max-h-40 overflow-y-auto">
                                        <div className="text-xs text-gray-400 mb-2">Replies ({comment.replies.length})</div>
                                        <div className="space-y-2">
                                            {comment.replies.map(reply => (
                                                <div key={reply.id} className="bg-gray-800 rounded p-2">
                                                    <div className="flex items-center justify-between mb-1">
                                                        <span className="text-xs font-medium text-gray-300">{reply.author}</span>
                                                        <span className="text-[10px] text-gray-500">
                                                            {new Date(reply.createdAt).toLocaleDateString()}
                                                        </span>
                                                    </div>
                                                    <p className="text-xs text-gray-400">{reply.text}</p>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {/* Add reply */}
                                <div className="p-3 border-b border-panel-border">
                                    <div className="flex gap-2">
                                        <input
                                            type="text"
                                            className="flex-1 bg-gray-800 border border-panel-border rounded px-2 py-1 text-sm text-white"
                                            placeholder="Add reply..."
                                            value={replyText}
                                            onChange={(e) => setReplyText(e.target.value)}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter' && replyText.trim()) {
                                                    handleAddReply(comment.id);
                                                }
                                            }}
                                        />
                                        <button
                                            className="px-3 py-1 bg-accent text-white text-xs rounded hover:bg-accent-hover"
                                            onClick={() => handleAddReply(comment.id)}
                                            disabled={!replyText.trim()}
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>

                                {/* Actions */}
                                <div className="p-3 flex justify-end">
                                    <button
                                        className="px-3 py-1 text-xs text-red-400 hover:text-red-300"
                                        onClick={() => handleDeleteComment(comment.id)}
                                    >
                                        Delete Comment
                                    </button>
                                </div>
                            </div>
                        );
                    })()}

                    {/* Context Menu */}
                    {contextMenu && (
                        <div
                            className="fixed bg-panel-bg border border-panel-border rounded-lg shadow-xl z-50 py-1 min-w-[160px]"
                            style={{ left: contextMenu.x, top: contextMenu.y }}
                            onClick={(e) => e.stopPropagation()}
                        >
                            {contextMenu.type === 'canvas' ? (
                                // Canvas context menu
                                <>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            if (clipboard) {
                                                const coords = screenToCanvas(contextMenu.x, contextMenu.y);
                                                // Paste at cursor position
                                                const pastedItem = { ...clipboard, id: generateId(), x: coords.x, y: coords.y, page: currentPage };
                                                if (clipboard.type === 'snippet') {
                                                    setSnippets(prev => [...prev, pastedItem]);
                                                } else if (clipboard.type === 'mask') {
                                                    setMasks(prev => [...prev, pastedItem]);
                                                } else if (clipboard.type === 'infoPoint') {
                                                    setInfoPoints(prev => [...prev, pastedItem]);
                                                } else if (clipboard.type === 'symbol') {
                                                    setSymbols(prev => [...prev, pastedItem]);
                                                } else {
                                                    setElements(prev => [...prev, pastedItem]);
                                                }
                                                setSelectedId(pastedItem.id);
                                            }
                                            setContextMenu(null);
                                        }}
                                        disabled={!clipboard}
                                    >
                                        <span className="w-4 text-center">📋</span>
                                        <span className={clipboard ? '' : 'text-gray-500'}>Paste Here</span>
                                        <span className="ml-auto text-xs text-gray-500">Ctrl+V</span>
                                    </button>
                                    <div className="border-t border-panel-border my-1"></div>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { setShowGrid(prev => !prev); setContextMenu(null); }}
                                    >
                                        <span className="w-4 text-center">{showGrid ? '✓' : ''}</span>
                                        <span>Show Grid</span>
                                        <span className="ml-auto text-xs text-gray-500">G</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { setSnapEnabled(prev => !prev); setContextMenu(null); }}
                                    >
                                        <span className="w-4 text-center">{snapEnabled ? '✓' : ''}</span>
                                        <span>Snap to Grid</span>
                                        <span className="ml-auto text-xs text-gray-500">;</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { setSmartGuidesEnabled(prev => !prev); setContextMenu(null); }}
                                    >
                                        <span className="w-4 text-center">{smartGuidesEnabled ? '✓' : ''}</span>
                                        <span>Smart Guides</span>
                                        <span className="ml-auto text-xs text-gray-500">'</span>
                                    </button>
                                    <div className="border-t border-panel-border my-1"></div>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { setZoom(1); setPanOffset({ x: 0, y: 0 }); setContextMenu(null); }}
                                    >
                                        <span className="w-4 text-center">🔍</span>
                                        <span>Reset View</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { setZoom(prev => Math.min(5, prev * 1.2)); setContextMenu(null); }}
                                    >
                                        <span className="w-4 text-center">➕</span>
                                        <span>Zoom In</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => { setZoom(prev => Math.max(0.1, prev / 1.2)); setContextMenu(null); }}
                                    >
                                        <span className="w-4 text-center">➖</span>
                                        <span>Zoom Out</span>
                                    </button>
                                </>
                            ) : (
                                // Element context menu
                                <>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            // Copy selected element
                                            const el = contextMenu.elementType === 'snippet' ? snippets.find(s => s.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'mask' ? masks.find(m => m.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'infoPoint' ? infoPoints.find(p => p.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'symbol' ? symbols.find(s => s.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'measurement' ? measurements.find(m => m.id === contextMenu.elementId) :
                                                       elements.find(e => e.id === contextMenu.elementId);
                                            if (el) setClipboard({ ...el });
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">📋</span>
                                        <span>Copy</span>
                                        <span className="ml-auto text-xs text-gray-500">Ctrl+C</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            // Duplicate element
                                            const el = contextMenu.elementType === 'snippet' ? snippets.find(s => s.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'mask' ? masks.find(m => m.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'infoPoint' ? infoPoints.find(p => p.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'symbol' ? symbols.find(s => s.id === contextMenu.elementId) :
                                                       contextMenu.elementType === 'measurement' ? measurements.find(m => m.id === contextMenu.elementId) :
                                                       elements.find(e => e.id === contextMenu.elementId);
                                            if (el) {
                                                const duplicated = { ...el, id: generateId(), x: (el.x || 0) + 20, y: (el.y || 0) + 20 };
                                                if (contextMenu.elementType === 'snippet') setSnippets(prev => [...prev, duplicated]);
                                                else if (contextMenu.elementType === 'mask') setMasks(prev => [...prev, duplicated]);
                                                else if (contextMenu.elementType === 'infoPoint') setInfoPoints(prev => [...prev, duplicated]);
                                                else if (contextMenu.elementType === 'symbol') setSymbols(prev => [...prev, duplicated]);
                                                else if (contextMenu.elementType === 'measurement') setMeasurements(prev => [...prev, duplicated]);
                                                else setElements(prev => [...prev, duplicated]);
                                                setSelectedId(duplicated.id);
                                            }
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">📑</span>
                                        <span>Duplicate</span>
                                        <span className="ml-auto text-xs text-gray-500">Ctrl+D</span>
                                    </button>
                                    <div className="border-t border-panel-border my-1"></div>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            // Rotate 90 degrees
                                            const rotateEl = (el) => ({ ...el, rotation: ((el.rotation || 0) + 90) % 360 });
                                            if (contextMenu.elementType === 'snippet') setSnippets(prev => prev.map(s => s.id === contextMenu.elementId ? rotateEl(s) : s));
                                            else if (contextMenu.elementType === 'mask') setMasks(prev => prev.map(m => m.id === contextMenu.elementId ? rotateEl(m) : m));
                                            else if (contextMenu.elementType === 'symbol') setSymbols(prev => prev.map(s => s.id === contextMenu.elementId ? rotateEl(s) : s));
                                            else setElements(prev => prev.map(e => e.id === contextMenu.elementId ? rotateEl(e) : e));
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">🔄</span>
                                        <span>Rotate 90°</span>
                                        <span className="ml-auto text-xs text-gray-500">R</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            // Flip horizontal
                                            const flipEl = (el) => ({ ...el, scaleX: (el.scaleX || 1) * -1 });
                                            if (contextMenu.elementType === 'snippet') setSnippets(prev => prev.map(s => s.id === contextMenu.elementId ? flipEl(s) : s));
                                            else if (contextMenu.elementType === 'mask') setMasks(prev => prev.map(m => m.id === contextMenu.elementId ? flipEl(m) : m));
                                            else if (contextMenu.elementType === 'symbol') setSymbols(prev => prev.map(s => s.id === contextMenu.elementId ? flipEl(s) : s));
                                            else setElements(prev => prev.map(e => e.id === contextMenu.elementId ? flipEl(e) : e));
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">↔️</span>
                                        <span>Flip Horizontal</span>
                                        <span className="ml-auto text-xs text-gray-500">H</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            // Flip vertical
                                            const flipEl = (el) => ({ ...el, scaleY: (el.scaleY || 1) * -1 });
                                            if (contextMenu.elementType === 'snippet') setSnippets(prev => prev.map(s => s.id === contextMenu.elementId ? flipEl(s) : s));
                                            else if (contextMenu.elementType === 'mask') setMasks(prev => prev.map(m => m.id === contextMenu.elementId ? flipEl(m) : m));
                                            else if (contextMenu.elementType === 'symbol') setSymbols(prev => prev.map(s => s.id === contextMenu.elementId ? flipEl(s) : s));
                                            else setElements(prev => prev.map(e => e.id === contextMenu.elementId ? flipEl(e) : e));
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">↕️</span>
                                        <span>Flip Vertical</span>
                                        <span className="ml-auto text-xs text-gray-500">Shift+H</span>
                                    </button>
                                    <div className="border-t border-panel-border my-1"></div>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            // Toggle visibility
                                            const toggleVis = (el) => ({ ...el, visible: !(el.visible !== false) });
                                            if (contextMenu.elementType === 'snippet') setSnippets(prev => prev.map(s => s.id === contextMenu.elementId ? toggleVis(s) : s));
                                            else if (contextMenu.elementType === 'mask') setMasks(prev => prev.map(m => m.id === contextMenu.elementId ? toggleVis(m) : m));
                                            else if (contextMenu.elementType === 'infoPoint') setInfoPoints(prev => prev.map(p => p.id === contextMenu.elementId ? toggleVis(p) : p));
                                            else if (contextMenu.elementType === 'symbol') setSymbols(prev => prev.map(s => s.id === contextMenu.elementId ? toggleVis(s) : s));
                                            else if (contextMenu.elementType === 'measurement') setMeasurements(prev => prev.map(m => m.id === contextMenu.elementId ? toggleVis(m) : m));
                                            else setElements(prev => prev.map(e => e.id === contextMenu.elementId ? toggleVis(e) : e));
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">👁️</span>
                                        <span>Toggle Visibility</span>
                                    </button>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 flex items-center gap-2"
                                        onClick={() => {
                                            // Toggle lock
                                            const toggleLock = (el) => ({ ...el, locked: !el.locked });
                                            if (contextMenu.elementType === 'snippet') setSnippets(prev => prev.map(s => s.id === contextMenu.elementId ? toggleLock(s) : s));
                                            else if (contextMenu.elementType === 'mask') setMasks(prev => prev.map(m => m.id === contextMenu.elementId ? toggleLock(m) : m));
                                            else if (contextMenu.elementType === 'infoPoint') setInfoPoints(prev => prev.map(p => p.id === contextMenu.elementId ? toggleLock(p) : p));
                                            else if (contextMenu.elementType === 'symbol') setSymbols(prev => prev.map(s => s.id === contextMenu.elementId ? toggleLock(s) : s));
                                            else if (contextMenu.elementType === 'measurement') setMeasurements(prev => prev.map(m => m.id === contextMenu.elementId ? toggleLock(m) : m));
                                            else setElements(prev => prev.map(e => e.id === contextMenu.elementId ? toggleLock(e) : e));
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">🔒</span>
                                        <span>Toggle Lock</span>
                                    </button>
                                    <div className="border-t border-panel-border my-1"></div>
                                    <button
                                        className="w-full px-3 py-1.5 text-left text-sm hover:bg-gray-700 text-red-400 flex items-center gap-2"
                                        onClick={() => {
                                            // Delete element
                                            history.push({ snippets: [...snippets], masks: [...masks], elements: [...elements], infoPoints: [...infoPoints], symbols: [...symbols], measurements: [...measurements], cableAnnotations: [...cableAnnotations] });
                                            if (contextMenu.elementType === 'snippet') setSnippets(prev => prev.filter(s => s.id !== contextMenu.elementId));
                                            else if (contextMenu.elementType === 'mask') setMasks(prev => prev.filter(m => m.id !== contextMenu.elementId));
                                            else if (contextMenu.elementType === 'infoPoint') setInfoPoints(prev => prev.filter(p => p.id !== contextMenu.elementId));
                                            else if (contextMenu.elementType === 'symbol') setSymbols(prev => prev.filter(s => s.id !== contextMenu.elementId));
                                            else if (contextMenu.elementType === 'measurement') setMeasurements(prev => prev.filter(m => m.id !== contextMenu.elementId));
                                            else setElements(prev => prev.filter(e => e.id !== contextMenu.elementId));
                                            setSelectedId(null);
                                            setSelectedType(null);
                                            setContextMenu(null);
                                        }}
                                    >
                                        <span className="w-4 text-center">🗑️</span>
                                        <span>Delete</span>
                                        <span className="ml-auto text-xs text-gray-500">Del</span>
                                    </button>
                                </>
                            )}
                        </div>
                    )}

                    {/* Minimap Navigator */}
                    {showMinimap && pdfData && (
                        <div
                            className="fixed bottom-4 right-4 bg-panel-bg border border-panel-border rounded-lg shadow-xl z-30 overflow-hidden"
                            style={{ width: 200, height: 150 }}
                        >
                            <div className="absolute top-1 left-2 text-[10px] text-gray-500 uppercase tracking-wider">Minimap</div>
                            <button
                                className="absolute top-1 right-1 w-5 h-5 flex items-center justify-center text-gray-400 hover:text-white rounded text-xs"
                                onClick={() => setShowMinimap(false)}
                            >×</button>
                            <div
                                className="w-full h-full cursor-pointer relative"
                                onClick={(e) => {
                                    const rect = e.currentTarget.getBoundingClientRect();
                                    const clickX = e.clientX - rect.left;
                                    const clickY = e.clientY - rect.top;

                                    // Calculate PDF dimensions
                                    const pdfWidth = currentPageData ? currentPageData.width : 1000;
                                    const pdfHeight = currentPageData ? currentPageData.height : 800;

                                    // Scale factors
                                    const scaleX = pdfWidth / rect.width;
                                    const scaleY = pdfHeight / rect.height;

                                    // Convert click to PDF coordinates, then center viewport there
                                    const targetX = clickX * scaleX;
                                    const targetY = clickY * scaleY;

                                    // Get current viewport dimensions
                                    const viewportWidth = (window.innerWidth - leftSidebarWidth - rightSidebarWidth) / zoom;
                                    const viewportHeight = window.innerHeight / zoom;

                                    // Calculate new pan to center on clicked point
                                    setPanOffset({
                                        x: -(targetX * zoom - (window.innerWidth - leftSidebarWidth - rightSidebarWidth) / 2),
                                        y: -(targetY * zoom - window.innerHeight / 2)
                                    });
                                }}
                            >
                                {/* PDF thumbnail representation */}
                                <div className="absolute inset-3 bg-gray-800 rounded">
                                    {/* Simplified representation of content */}
                                    {snippets.filter(s => s.page === currentPage).map((s, i) => {
                                        const pdfW = currentPageData?.width || 1000;
                                        const pdfH = currentPageData?.height || 800;
                                        const minimapW = 194; // 200 - padding
                                        const minimapH = 144; // 150 - padding
                                        return (
                                            <div
                                                key={`mini-snippet-${i}`}
                                                className="absolute bg-blue-500/30"
                                                style={{
                                                    left: `${(s.x / pdfW) * 100}%`,
                                                    top: `${(s.y / pdfH) * 100}%`,
                                                    width: `${(s.width / pdfW) * 100}%`,
                                                    height: `${(s.height / pdfH) * 100}%`
                                                }}
                                            />
                                        );
                                    })}
                                    {elements.filter(el => el.page === currentPage).map((el, i) => {
                                        const pdfW = currentPageData?.width || 1000;
                                        const pdfH = currentPageData?.height || 800;
                                        if (el.type === 'rectangle' || el.type === 'circle' || el.type === 'text' || el.type === 'callout') {
                                            return (
                                                <div
                                                    key={`mini-el-${i}`}
                                                    className="absolute"
                                                    style={{
                                                        left: `${(el.x / pdfW) * 100}%`,
                                                        top: `${(el.y / pdfH) * 100}%`,
                                                        width: `${((el.width || 20) / pdfW) * 100}%`,
                                                        height: `${((el.height || 20) / pdfH) * 100}%`,
                                                        backgroundColor: el.color || '#3b82f6',
                                                        opacity: 0.5
                                                    }}
                                                />
                                            );
                                        }
                                        return null;
                                    })}
                                    {infoPoints.filter(ip => ip.page === currentPage).map((ip, i) => {
                                        const pdfW = currentPageData?.width || 1000;
                                        const pdfH = currentPageData?.height || 800;
                                        return (
                                            <div
                                                key={`mini-ip-${i}`}
                                                className="absolute w-1 h-1 rounded-full bg-yellow-500"
                                                style={{
                                                    left: `${(ip.x / pdfW) * 100}%`,
                                                    top: `${(ip.y / pdfH) * 100}%`
                                                }}
                                            />
                                        );
                                    })}
                                    {symbols.filter(sym => sym.page === currentPage).map((sym, i) => {
                                        const pdfW = currentPageData?.width || 1000;
                                        const pdfH = currentPageData?.height || 800;
                                        return (
                                            <div
                                                key={`mini-sym-${i}`}
                                                className="absolute w-1.5 h-1.5 bg-green-500"
                                                style={{
                                                    left: `${(sym.x / pdfW) * 100}%`,
                                                    top: `${(sym.y / pdfH) * 100}%`
                                                }}
                                            />
                                        );
                                    })}

                                    {/* Current viewport indicator */}
                                    {(() => {
                                        const pdfW = currentPageData?.width || 1000;
                                        const pdfH = currentPageData?.height || 800;
                                        const minimapW = 194;
                                        const minimapH = 144;

                                        // Calculate visible area in PDF coordinates
                                        const viewportWidth = (window.innerWidth - leftSidebarWidth - rightSidebarWidth);
                                        const viewportHeight = window.innerHeight;

                                        // Convert viewport to PDF coordinates
                                        const visibleWidth = viewportWidth / zoom;
                                        const visibleHeight = viewportHeight / zoom;
                                        const visibleX = -panOffset.x / zoom;
                                        const visibleY = -panOffset.y / zoom;

                                        return (
                                            <div
                                                className="absolute border-2 border-accent rounded pointer-events-none"
                                                style={{
                                                    left: `${Math.max(0, (visibleX / pdfW) * 100)}%`,
                                                    top: `${Math.max(0, (visibleY / pdfH) * 100)}%`,
                                                    width: `${Math.min(100, (visibleWidth / pdfW) * 100)}%`,
                                                    height: `${Math.min(100, (visibleHeight / pdfH) * 100)}%`,
                                                    backgroundColor: 'rgba(59, 130, 246, 0.1)'
                                                }}
                                            />
                                        );
                                    })()}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Minimap toggle button when hidden */}
                    {!showMinimap && pdfData && (
                        <button
                            className="fixed bottom-4 right-4 w-10 h-10 bg-panel-bg border border-panel-border rounded-lg shadow-xl z-30 flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-700"
                            onClick={() => setShowMinimap(true)}
                            title="Show Minimap"
                        >
                            <svg viewBox="0 0 24 24" className="w-5 h-5" fill="none" stroke="currentColor" strokeWidth="2">
                                <rect x="3" y="3" width="18" height="18" rx="2"/>
                                <rect x="14" y="14" width="6" height="6" rx="1" fill="currentColor" opacity="0.5"/>
                            </svg>
                        </button>
                    )}
                </div>
            );
        };

        // ============================================
        // MOUNT APPLICATION
        // ============================================
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CableMarkupEditor />);
    </script>
</body>
</html>
